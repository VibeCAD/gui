This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
public/
  vite.svg
src/
  ai/
    ai.service.ts
  assets/
    react.svg
  babylon/
    hooks/
      useBabylonScene.ts
    boundaryUtils.ts
    gizmoManager.ts
    glbImporter.ts
    housingFactory.ts
    objectFactory.ts
    sceneManager.ts
    stlExporter.ts
    textureManager.ts
  components/
    modals/
      CustomRoomModal.tsx
    sidebar/
      AISidebar.tsx
      ExportButton.tsx
      ImportButton.tsx
      PropertiesPanel.tsx
      SceneGraph.tsx
      TextureLibrary.tsx
      TextureUpload.tsx
    ui/
      CompassOverlay.tsx
  config/
    defaultTextures.ts
  hooks/
    useKeyboardShortcuts.tsx
  state/
    sceneStore.ts
  types/
    types.ts
  App.css
  App.tsx
  index.css
  main.tsx
  verb-nurbs.d.ts
  vite-env.d.ts
.gitignore
eslint.config.js
import.md
index.html
package.json
README.md
SRC_DOCUMENTATION.md
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="src/babylon/boundaryUtils.ts">
import { Mesh, Vector3, Matrix } from 'babylonjs'
import type { Boundary, ConnectionPoint } from '../types/types'

/**
 * Computes an axis-aligned bounding box for the given mesh in world space
 * and derives size & center information. This is cheap and works for most
 * primitives whose pivot is centred. For rotated/parented meshes callers should
 * pass the root or call after reset of rotation.
 */
export const computeMeshBoundary = (mesh: Mesh): Boundary => {
  // Ensure world matrix up-to-date
  mesh.computeWorldMatrix(true)
  const boundingInfo = mesh.getBoundingInfo()
  const bbox = boundingInfo.boundingBox

  const wMin = bbox.minimumWorld
  const wMax = bbox.maximumWorld

  const worldToLocal = new Matrix()
  mesh.getWorldMatrix().invertToRef(worldToLocal)
  const min = Vector3.TransformCoordinates(wMin, worldToLocal)
  const max = Vector3.TransformCoordinates(wMax, worldToLocal)

  const size = max.subtract(min)
  const center = min.add(size.scale(0.5))

  return {
    aabb: { min, max, size, center }
  }
}

/**
 * Computes a bounding box that encloses the given mesh **and all of its children**.
 * All returned vectors are expressed in the root mesh's local-space so that
 * connection-points can be attached directly to the root.
 */
export const computeCompositeBoundary = (root: Mesh): Boundary => {
  root.computeWorldMatrix(true)

  const childMeshes = root.getChildMeshes(false)
  if (childMeshes.length === 0) {
    return computeMeshBoundary(root)
  }

  const worldToLocal = new Matrix()
  root.getWorldMatrix().invertToRef(worldToLocal)

  let minLocal = new Vector3(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY)
  let maxLocal = new Vector3(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY)

  childMeshes.forEach((m) => {
    m.computeWorldMatrix(true)
    const bbox = m.getBoundingInfo().boundingBox
    const wMin = bbox.minimumWorld
    const wMax = bbox.maximumWorld

    // Transform both extremes into root local space
    const lMin = Vector3.TransformCoordinates(wMin, worldToLocal)
    const lMax = Vector3.TransformCoordinates(wMax, worldToLocal)

    minLocal = Vector3.Minimize(minLocal, lMin)
    minLocal = Vector3.Minimize(minLocal, lMax)
    maxLocal = Vector3.Maximize(maxLocal, lMin)
    maxLocal = Vector3.Maximize(maxLocal, lMax)
  })

  const size = maxLocal.subtract(minLocal)
  const center = minLocal.add(size.scale(0.5))

  return {
    aabb: { min: minLocal, max: maxLocal, size, center }
  }
}

/**
 * Generates a pragmatic set of connection-points based purely on the AABB.
 * Resulting positions are expressed in the mesh's LOCAL space so that
 * SceneManager.computeSnapTransform can transform them correctly.
 */
export const generateDefaultConnectionPoints = (mesh: Mesh, boundary?: Boundary): ConnectionPoint[] => {
  const b = boundary ?? computeMeshBoundary(mesh)
  const { size, center } = b.aabb

  const halfX = size.x / 2
  const halfY = size.y / 2
  const halfZ = size.z / 2

  const cps: ConnectionPoint[] = [
    // ¬±X faces
    { id: 'px', position: new Vector3(center.x + halfX, center.y, center.z), normal: new Vector3( 1, 0, 0), kind: 'face' },
    { id: 'nx', position: new Vector3(center.x - halfX, center.y, center.z), normal: new Vector3(-1, 0, 0), kind: 'face' },
    // ¬±Y faces (top / bottom)
    { id: 'py', position: new Vector3(center.x, center.y + halfY, center.z), normal: new Vector3(0,  1, 0), kind: 'face' },
    { id: 'ny', position: new Vector3(center.x, center.y - halfY, center.z), normal: new Vector3(0, -1, 0), kind: 'face' },
    // ¬±Z faces
    { id: 'pz', position: new Vector3(center.x, center.y, center.z + halfZ), normal: new Vector3(0, 0,  1), kind: 'face' },
    { id: 'nz', position: new Vector3(center.x, center.y, center.z - halfZ), normal: new Vector3(0, 0, -1), kind: 'face' }
  ]

  return cps
}

/**
 * Convenience helper that computes + attaches default CPs to the provided mesh.
 * Returns the generated list for reference.
 */
export const attachBoundingConnectionPoints = (mesh: Mesh): ConnectionPoint[] => {
  const cps = generateDefaultConnectionPoints(mesh)
  if (!mesh.metadata) mesh.metadata = {}
  ;(mesh.metadata as any).connectionPoints = cps
  return cps
}
</file>

<file path="src/babylon/stlExporter.ts">
import { Scene, Mesh, Vector3 } from 'babylonjs';
import 'babylonjs-serializers';
import type { SceneObject } from '../types/types';

/**
 * STLExporter class handles exporting scene objects to STL format
 */
export class STLExporter {
  private scene: Scene;

  constructor(scene: Scene) {
    this.scene = scene;
  }

  /**
   * Exports all scene objects (except ground) as a single STL file
   * @param sceneObjects Array of scene objects to export
   * @param filename Optional filename (defaults to "scene-export.stl")
   */
  async exportSceneToSTL(sceneObjects: SceneObject[], filename: string = 'scene-export.stl'): Promise<void> {
    try {
      // Filter out ground objects
      const exportableObjects = sceneObjects.filter(obj => 
        obj.type !== 'ground'
      );

      if (exportableObjects.length === 0) {
        throw new Error('No objects to export');
      }

      // Collect all meshes
      const meshesToExport: Mesh[] = [];
      
      for (const obj of exportableObjects) {
        // Get the mesh from the scene by ID
        const mesh = this.scene.getMeshById(obj.id);
        if (mesh && mesh instanceof Mesh && mesh.geometry) {
          meshesToExport.push(mesh);
        }
      }

      if (meshesToExport.length === 0) {
        throw new Error('No valid meshes found to export');
      }

      // Merge all meshes into a single mesh for export
      const mergedMesh = this.mergeMeshesForExport(meshesToExport);
      
      if (!mergedMesh) {
        throw new Error('Failed to merge meshes for export');
      }

      // Use Babylon's STL export - cast to global BABYLON.Mesh type
      const stlString = (window as any).BABYLON.STLExport.CreateSTL([mergedMesh as any], true, mergedMesh.name);
      
      // Create a blob and download
      const blob = new Blob([stlString], { type: 'application/octet-stream' });
      this.downloadBlob(blob, filename);

      // Clean up the temporary merged mesh
      mergedMesh.dispose();
      
      console.log(`‚úÖ Successfully exported ${meshesToExport.length} objects to ${filename}`);
    } catch (error) {
      console.error('‚ùå Error exporting to STL:', error);
      throw error;
    }
  }

  /**
   * Merges multiple meshes into a single mesh for export
   * @param meshes Array of meshes to merge
   * @returns A single merged mesh
   */
  private mergeMeshesForExport(meshes: Mesh[]): Mesh | null {
    if (meshes.length === 0) return null;
    
    // Clone meshes to avoid modifying originals
    const clonedMeshes = meshes.map((mesh, index) => {
      const clone = mesh.clone(`export-clone-${index}`, null);
      
      // Apply the mesh's world matrix to bake transformations
      if (clone && clone.geometry) {
        clone.bakeCurrentTransformIntoVertices();
      }
      
      return clone;
    }).filter(mesh => mesh !== null) as Mesh[];

    if (clonedMeshes.length === 0) return null;

    // Merge all cloned meshes
    const mergedMesh = Mesh.MergeMeshes(
      clonedMeshes,
      true,  // dispose source meshes
      true,  // allow different materials
      undefined,  // no parent
      false,  // don't optimize vertex data
      true   // use precise bounding info
    );

    if (mergedMesh) {
      mergedMesh.name = 'scene-export';
    }

    return mergedMesh;
  }

  /**
   * Downloads a blob as a file
   * @param blob The blob to download
   * @param filename The filename for the download
   */
  private downloadBlob(blob: Blob, filename: string): void {
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    
    // Trigger download
    document.body.appendChild(link);
    link.click();
    
    // Clean up
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }

  /**
   * Checks if STL export is available
   * @returns true if STL export is supported
   */
  public static isSTLExportAvailable(): boolean {
    return typeof (window as any).BABYLON !== 'undefined' && 
           typeof (window as any).BABYLON.STLExport !== 'undefined' &&
           typeof (window as any).BABYLON.STLExport.CreateSTL === 'function';
  }
}

/**
 * Factory function to create a new STLExporter instance
 * @param scene The Babylon.js scene
 * @returns A new STLExporter instance
 */
export function createSTLExporter(scene: Scene): STLExporter {
  return new STLExporter(scene);
}
</file>

<file path="src/babylon/textureManager.ts">
import { Scene, Texture, StandardMaterial, PBRMaterial, BaseTexture } from 'babylonjs';
import type { TextureAsset, TextureType } from '../types/types';

/**
 * TextureManager handles loading, caching, and application of textures in the Babylon.js scene
 */
export class TextureManager {
    private scene: Scene;
    private loadedTextures: Map<string, Texture>;
    private textureReferences: Map<string, number>; // Reference counting for cleanup
    
    constructor(scene: Scene) {
        this.scene = scene;
        this.loadedTextures = new Map();
        this.textureReferences = new Map();
    }
    
    /**
     * Validates a texture file before loading
     */
    validateTextureFile(file: File): { valid: boolean; error?: string } {
        // Check file size (10MB limit)
        const maxSize = 10 * 1024 * 1024; // 10MB
        if (file.size > maxSize) {
            return { 
                valid: false, 
                error: `File size exceeds 10MB limit (${(file.size / (1024 * 1024)).toFixed(2)}MB)` 
            };
        }
        
        // Check file type
        const validTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'];
        if (!validTypes.includes(file.type)) {
            const extension = file.name.split('.').pop()?.toLowerCase() || '';
            const validExtensions = ['jpg', 'jpeg', 'png', 'webp'];
            
            if (!validExtensions.includes(extension)) {
                return { 
                    valid: false, 
                    error: 'Invalid file format. Supported formats: JPG, PNG, WebP' 
                };
            }
        }
        
        return { valid: true };
    }
    
    /**
     * Loads a texture from a File object
     */
    async loadTextureFromFile(file: File): Promise<TextureAsset> {
        // Validate file first
        const validation = this.validateTextureFile(file);
        if (!validation.valid) {
            throw new Error(validation.error);
        }
        
        // Create object URL for the file
        const url = URL.createObjectURL(file);
        
        try {
            // Load image to get dimensions
            const img = new Image();
            const loadPromise = new Promise<{ width: number; height: number }>((resolve, reject) => {
                img.onload = () => {
                    resolve({ width: img.width, height: img.height });
                };
                img.onerror = () => {
                    reject(new Error('Failed to load image'));
                };
            });
            
            img.src = url;
            const dimensions = await loadPromise;
            
            // Check texture dimensions
            const maxDimension = 4096;
            if (dimensions.width > maxDimension || dimensions.height > maxDimension) {
                URL.revokeObjectURL(url);
                throw new Error(`Texture dimensions exceed ${maxDimension}x${maxDimension} pixels`);
            }
            
            // Warn about non-power-of-two textures
            if (!this.isPowerOfTwo(dimensions.width) || !this.isPowerOfTwo(dimensions.height)) {
                console.warn('Texture dimensions are not power of two. This may cause issues on some devices.');
            }
            
            // Create texture asset
            const textureAsset: TextureAsset = {
                id: '', // Will be set by the store
                name: file.name,
                url: url,
                type: 'diffuse', // Default type
                fileSize: file.size,
                dimensions: dimensions,
                uploadedAt: Date.now()
            };
            
            return textureAsset;
        } catch (error) {
            // Clean up URL on error
            URL.revokeObjectURL(url);
            throw error;
        }
    }
    
    /**
     * Creates a Babylon.js texture from a TextureAsset
     */
    createBabylonTexture(textureAsset: TextureAsset): Texture {
        console.log('üî® TextureManager.createBabylonTexture called with:', {
            id: textureAsset.id,
            name: textureAsset.name,
            url: textureAsset.url
        });
        
        // Check if texture is already loaded
        const cached = this.loadedTextures.get(textureAsset.id);
        if (cached) {
            console.log('üì¶ Returning cached texture:', textureAsset.id);
            this.incrementReference(textureAsset.id);
            return cached;
        }
        
        console.log('üÜï Creating new texture for:', textureAsset.name);
        
        // Create new texture
        const texture = new Texture(
            textureAsset.url,
            this.scene,
            false, // noMipmap - we'll use mipmaps for better quality
            true,  // invertY - required for most textures
            Texture.TRILINEAR_SAMPLINGMODE // Best quality sampling
        );
        
        // Set texture properties
        texture.name = textureAsset.name;
        texture.wrapU = Texture.WRAP_ADDRESSMODE;
        texture.wrapV = Texture.WRAP_ADDRESSMODE;
        
        // Add event handlers for debugging
        texture.onLoadObservable.add(() => {
            console.log('‚úÖ Texture loaded successfully:', textureAsset.name);
        });
        
        // Cache the texture
        this.loadedTextures.set(textureAsset.id, texture);
        this.incrementReference(textureAsset.id);
        
        console.log('üìå Texture cached with ID:', textureAsset.id);
        
        return texture;
    }
    
    /**
     * Applies a diffuse texture to a material
     */
    applyDiffuseTexture(material: StandardMaterial | PBRMaterial, texture: Texture): void {
        if (material instanceof StandardMaterial) {
            material.diffuseTexture = texture;
        } else if (material instanceof PBRMaterial) {
            material.albedoTexture = texture;
        }
    }
    
    /**
     * Applies a normal texture to a material
     */
    applyNormalTexture(material: StandardMaterial | PBRMaterial, texture: Texture): void {
        if (material instanceof StandardMaterial) {
            material.bumpTexture = texture;
        } else if (material instanceof PBRMaterial) {
            material.bumpTexture = texture;
        }
    }
    
    /**
     * Applies a specular texture to a material
     */
    applySpecularTexture(material: StandardMaterial | PBRMaterial, texture: Texture): void {
        if (material instanceof StandardMaterial) {
            material.specularTexture = texture;
        } else if (material instanceof PBRMaterial) {
            material.reflectivityTexture = texture;
        }
    }
    
    /**
     * Applies an emissive texture to a material
     */
    applyEmissiveTexture(material: StandardMaterial | PBRMaterial, texture: Texture): void {
        if (material instanceof StandardMaterial) {
            material.emissiveTexture = texture;
        } else if (material instanceof PBRMaterial) {
            material.emissiveTexture = texture;
        }
    }
    
    /**
     * Sets texture scale on a texture
     */
    setTextureScale(texture: Texture, scale: { u: number; v: number }): void {
        texture.uScale = scale.u;
        texture.vScale = scale.v;
    }
    
    /**
     * Sets texture offset on a texture
     */
    setTextureOffset(texture: Texture, offset: { u: number; v: number }): void {
        texture.uOffset = offset.u;
        texture.vOffset = offset.v;
    }
    
    /**
     * Disposes a texture and cleans up resources
     */
    disposeTexture(textureId: string): void {
        this.decrementReference(textureId);
        
        // Only dispose if no more references
        const refCount = this.textureReferences.get(textureId) || 0;
        if (refCount <= 0) {
            const texture = this.loadedTextures.get(textureId);
            if (texture) {
                // Revoke object URL if it exists
                const url = texture.url;
                if (url && url.startsWith('blob:')) {
                    URL.revokeObjectURL(url);
                }
                
                // Dispose the texture
                texture.dispose();
                
                // Remove from cache
                this.loadedTextures.delete(textureId);
                this.textureReferences.delete(textureId);
            }
        }
    }
    
    /**
     * Clears all texture cache and disposes resources
     */
    clearTextureCache(): void {
        this.loadedTextures.forEach((texture, id) => {
            // Revoke object URL if it exists
            const url = texture.url;
            if (url && url.startsWith('blob:')) {
                URL.revokeObjectURL(url);
            }
            
            // Dispose the texture
            texture.dispose();
        });
        
        this.loadedTextures.clear();
        this.textureReferences.clear();
    }
    
    /**
     * Gets a texture from cache
     */
    getTextureFromCache(textureId: string): Texture | null {
        return this.loadedTextures.get(textureId) || null;
    }
    
    /**
     * Generates a unique texture ID
     */
    generateTextureId(): string {
        return `texture-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
    
    /**
     * Gets the current texture memory usage estimate
     */
    getTextureMemoryUsage(): number {
        let totalBytes = 0;
        
        this.loadedTextures.forEach((texture) => {
            // Estimate based on texture dimensions and format
            // Assuming RGBA format (4 bytes per pixel)
            const width = texture.getSize().width;
            const height = texture.getSize().height;
            const bytesPerPixel = 4;
            
            // Include mipmap memory (roughly 1.33x the base texture)
            const mipmapMultiplier = texture.noMipmap ? 1 : 1.33;
            
            totalBytes += width * height * bytesPerPixel * mipmapMultiplier;
        });
        
        return totalBytes;
    }
    
    /**
     * Checks if a number is a power of two
     */
    private isPowerOfTwo(n: number): boolean {
        return n > 0 && (n & (n - 1)) === 0;
    }
    
    /**
     * Increments reference count for a texture
     */
    private incrementReference(textureId: string): void {
        const current = this.textureReferences.get(textureId) || 0;
        this.textureReferences.set(textureId, current + 1);
    }
    
    /**
     * Decrements reference count for a texture
     */
    private decrementReference(textureId: string): void {
        const current = this.textureReferences.get(textureId) || 0;
        this.textureReferences.set(textureId, Math.max(0, current - 1));
    }
}

/**
 * Factory function to create a TextureManager instance
 */
export function createTextureManager(scene: Scene): TextureManager {
    return new TextureManager(scene);
}
</file>

<file path="src/components/sidebar/ExportButton.tsx">
import React, { useState } from 'react';

interface ExportButtonProps {
  onExport: () => Promise<void>;
  disabled?: boolean;
  objectCount?: number;
}

export const ExportButton: React.FC<ExportButtonProps> = ({ 
  onExport, 
  disabled = false,
  objectCount = 0 
}) => {
  const [isExporting, setIsExporting] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleClick = async () => {
    if (isExporting || disabled || objectCount === 0) return;
    
    setIsExporting(true);
    setError(null);
    
    try {
      await onExport();
      // Success - error handling is done in the parent component
    } catch (err) {
      console.error('Export error:', err);
      setError('Export failed');
    } finally {
      setIsExporting(false);
    }
  };

  const getButtonText = () => {
    if (isExporting) return 'Exporting...';
    if (objectCount === 0) return 'No Objects to Export';
    return `Export to STL (${objectCount} object${objectCount !== 1 ? 's' : ''})`;
  };

  const isButtonDisabled = disabled || isExporting || objectCount === 0;

  return (
    <div className="export-button-container">
      <button
        className={`export-button ${isButtonDisabled ? 'disabled' : ''}`}
        onClick={handleClick}
        disabled={isButtonDisabled}
        title={objectCount === 0 ? 'Add objects to the scene to export' : 'Export all objects as STL file'}
      >
        <span className="button-icon">üíæ</span>
        <span className="button-text">{getButtonText()}</span>
      </button>
      
      {error && (
        <div className="export-error">
          {error}
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/components/sidebar/ImportButton.tsx">
import React, { useRef, useState } from 'react';
import { useSceneStore } from '../../state/sceneStore';

interface ImportButtonProps {
  onImport: (file: File) => Promise<void>;
  disabled?: boolean;
}

export const ImportButton: React.FC<ImportButtonProps> = ({ onImport, disabled }) => {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const [localError, setLocalError] = useState<string | null>(null);
  const { isImporting } = useSceneStore();

  const handleClick = () => {
    setLocalError(null);
    fileInputRef.current?.click();
  };

  const handleFileSelect = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    try {
      await onImport(file);
    } catch (error) {
      setLocalError(error instanceof Error ? error.message : 'Failed to import file');
    }

    // Reset input to allow selecting the same file again
    event.target.value = '';
  };

  return (
    <>
      <input
        ref={fileInputRef}
        type="file"
        accept=".glb,.stl,.obj"
        onChange={handleFileSelect}
        style={{ display: 'none' }}
      />
      
      <button 
        onClick={handleClick} 
        className="import-button"
        disabled={disabled || isImporting}
      >
        {isImporting ? (
          <>
            <span>‚è≥</span>
            Importing...
          </>
        ) : (
          <>
            <span>üì•</span>
            Import 3D Model
          </>
        )}
      </button>

      {localError && (
        <div className="import-error">
          {localError}
        </div>
      )}
    </>
  );
};
</file>

<file path="src/components/sidebar/TextureUpload.tsx">
import React, { useRef, useState, useCallback } from 'react';
import { useSceneStore } from '../../state/sceneStore';
import { createTextureManager } from '../../babylon/textureManager';
import type { TextureAsset } from '../../types/types';

interface TextureUploadProps {
    onUpload?: (textureAsset: TextureAsset) => void;
    maxFileSize?: number; // in bytes, default 10MB
    acceptedFormats?: string[];
    className?: string;
}

export const TextureUpload: React.FC<TextureUploadProps> = ({
    onUpload,
    maxFileSize = 10 * 1024 * 1024, // 10MB
    acceptedFormats = ['.jpg', '.jpeg', '.png', '.webp'],
    className = ''
}) => {
    const fileInputRef = useRef<HTMLInputElement>(null);
    const [isDragging, setIsDragging] = useState(false);
    const [preview, setPreview] = useState<string | null>(null);
    const [uploadError, setUploadError] = useState<string | null>(null);
    
    const {
        isUploadingTexture,
        textureUploadError,
        setIsUploadingTexture,
        setTextureUploadError,
        uploadTexture,
        addTextureAsset,
        addToResponseLog
    } = useSceneStore();
    
    // Clear error after 5 seconds
    React.useEffect(() => {
        if (uploadError || textureUploadError) {
            const timer = setTimeout(() => {
                setUploadError(null);
                setTextureUploadError(null);
            }, 5000);
            return () => clearTimeout(timer);
        }
    }, [uploadError, textureUploadError, setTextureUploadError]);
    
    const handleFile = async (file: File) => {
        setUploadError(null);
        setTextureUploadError(null);
        
        // Quick validation
        if (file.size > maxFileSize) {
            const error = `File too large: ${(file.size / (1024 * 1024)).toFixed(2)}MB (max ${(maxFileSize / (1024 * 1024)).toFixed(0)}MB)`;
            setUploadError(error);
            return;
        }
        
        const extension = '.' + file.name.split('.').pop()?.toLowerCase();
        if (!acceptedFormats.includes(extension)) {
            const error = `Invalid format. Accepted: ${acceptedFormats.join(', ')}`;
            setUploadError(error);
            return;
        }
        
        try {
            setIsUploadingTexture(true);
            
            // Create temporary texture manager for validation and processing
            // In real implementation, this would be passed from the scene
            const tempManager = {
                validateTextureFile: (file: File) => {
                    const maxSize = 10 * 1024 * 1024;
                    if (file.size > maxSize) {
                        return { valid: false, error: 'File too large' };
                    }
                    return { valid: true };
                },
                loadTextureFromFile: async (file: File): Promise<TextureAsset> => {
                    // Create preview
                    const url = URL.createObjectURL(file);
                    setPreview(url);
                    
                    // Get image dimensions
                    const img = new Image();
                    const dimensions = await new Promise<{ width: number; height: number }>((resolve, reject) => {
                        img.onload = () => resolve({ width: img.width, height: img.height });
                        img.onerror = () => reject(new Error('Failed to load image'));
                        img.src = url;
                    });
                    
                    const textureAsset: TextureAsset = {
                        id: `texture-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
                        name: file.name,
                        url: url,
                        type: 'diffuse',
                        fileSize: file.size,
                        dimensions,
                        uploadedAt: Date.now()
                    };
                    
                    return textureAsset;
                }
            };
            
            // Validate file
            const validation = tempManager.validateTextureFile(file);
            if (!validation.valid) {
                throw new Error(validation.error);
            }
            
            // Load texture
            const textureAsset = await tempManager.loadTextureFromFile(file);
            
            // Add to store
            addTextureAsset(textureAsset);
            addToResponseLog(`‚úÖ Uploaded texture: ${file.name}`);
            
            // Call callback if provided
            if (onUpload) {
                onUpload(textureAsset);
            }
            
            // Clear preview after successful upload
            setTimeout(() => setPreview(null), 2000);
            
        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Upload failed';
            setUploadError(errorMessage);
            setTextureUploadError(errorMessage);
            addToResponseLog(`‚ùå Texture upload failed: ${errorMessage}`);
        } finally {
            setIsUploadingTexture(false);
        }
    };
    
    const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (file) {
            handleFile(file);
        }
        // Reset input
        event.target.value = '';
    };
    
    const handleDragOver = useCallback((e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(true);
    }, []);
    
    const handleDragLeave = useCallback((e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
    }, []);
    
    const handleDrop = useCallback((e: React.DragEvent) => {
        e.preventDefault();
        e.stopPropagation();
        setIsDragging(false);
        
        const file = e.dataTransfer.files[0];
        if (file) {
            handleFile(file);
        }
    }, []);
    
    const triggerFileInput = () => {
        fileInputRef.current?.click();
    };
    
    const displayError = uploadError || textureUploadError;
    
    return (
        <div className={`texture-upload-container ${className}`}>
            <input
                ref={fileInputRef}
                type="file"
                accept={acceptedFormats.join(',')}
                onChange={handleFileSelect}
                style={{ display: 'none' }}
            />
            
            <div
                className={`texture-upload-area ${isDragging ? 'dragging' : ''} ${isUploadingTexture ? 'uploading' : ''}`}
                onDragOver={handleDragOver}
                onDragLeave={handleDragLeave}
                onDrop={handleDrop}
                onClick={triggerFileInput}
            >
                {isUploadingTexture ? (
                    <div className="upload-progress">
                        <div className="spinner"></div>
                        <span>Uploading...</span>
                    </div>
                ) : preview ? (
                    <div className="preview-container">
                        <img src={preview} alt="Preview" className="texture-preview" />
                        <span className="upload-success">‚úì Uploaded</span>
                    </div>
                ) : (
                    <div className="upload-prompt">
                        <span className="upload-icon">üìÅ</span>
                        <span className="upload-text">
                            {isDragging ? 'Drop to upload' : 'Drop texture here or click to browse'}
                        </span>
                        <span className="upload-hint">
                            {acceptedFormats.join(', ')} ‚Ä¢ Max {(maxFileSize / (1024 * 1024)).toFixed(0)}MB
                        </span>
                    </div>
                )}
            </div>
            
            {displayError && (
                <div className="texture-upload-error">
                    <span className="error-icon">‚ö†Ô∏è</span>
                    <span className="error-text">{displayError}</span>
                </div>
            )}
        </div>
    );
};
</file>

<file path="src/components/ui/CompassOverlay.tsx">
import React from 'react';

interface CompassOverlayProps {
  className?: string;
}

export const CompassOverlay: React.FC<CompassOverlayProps> = ({ className = '' }) => {
  // For now, we'll show a static compass. In the future, this could be dynamic based on camera rotation
  // The compass shows world-space directions: North = +Z, East = +X, South = -Z, West = -X
  
  return (
    <div className={`fixed top-4 right-4 bg-black bg-opacity-70 rounded-lg p-3 text-white text-sm font-mono select-none pointer-events-none z-50 ${className}`}>
      <div className="flex flex-col items-center space-y-1">
        <div className="text-xs text-gray-300 mb-1">Compass</div>
        <div className="relative w-12 h-12">
          {/* Compass circle */}
          <div className="absolute inset-0 border-2 border-gray-400 rounded-full"></div>
          
          {/* North indicator */}
          <div className="absolute top-0 left-1/2 transform -translate-x-1/2 -translate-y-1">
            <div className="w-0 h-0 border-l-2 border-r-2 border-b-3 border-transparent border-b-red-400"></div>
            <div className="text-xs text-red-400 font-bold text-center mt-0.5">N</div>
          </div>
          
          {/* East indicator */}
          <div className="absolute right-0 top-1/2 transform translate-x-1 -translate-y-1/2">
            <div className="w-0 h-0 border-t-2 border-b-2 border-l-3 border-transparent border-l-blue-400"></div>
            <div className="text-xs text-blue-400 font-bold text-center ml-1">E</div>
          </div>
          
          {/* South indicator */}
          <div className="absolute bottom-0 left-1/2 transform -translate-x-1/2 translate-y-1">
            <div className="text-xs text-green-400 font-bold text-center mb-0.5">S</div>
            <div className="w-0 h-0 border-l-2 border-r-2 border-t-3 border-transparent border-t-green-400"></div>
          </div>
          
          {/* West indicator */}
          <div className="absolute left-0 top-1/2 transform -translate-x-1 -translate-y-1/2">
            <div className="text-xs text-yellow-400 font-bold text-center mr-1">W</div>
            <div className="w-0 h-0 border-t-2 border-b-2 border-r-3 border-transparent border-r-yellow-400"></div>
          </div>
          
          {/* Center dot */}
          <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-1 h-1 bg-gray-300 rounded-full"></div>
        </div>
        
        {/* Direction legend */}
        <div className="text-xs text-gray-400 text-center leading-tight">
          <div>N: +Z</div>
          <div>E: +X</div>
        </div>
      </div>
    </div>
  );
};
</file>

<file path="src/config/defaultTextures.ts">
import type { TextureAsset } from '../types/types';

/**
 * Default texture configurations that ship with the application
 * These textures are stored in the public/textures directory and are available to all users
 */

export interface DefaultTextureConfig {
  id: string;
  name: string;
  category: 'wood' | 'fabric' | 'brick' | 'metal' | 'concrete' | 'other';
  filename: string; // Filename in public/textures/{category}/
  type: 'diffuse';
  tags: string[]; // For search/filtering
}

export const DEFAULT_TEXTURES: DefaultTextureConfig[] = [
  // Wood textures
  {
    id: 'default-wood-floor-01',
    name: 'Wood Floor - Natural',
    category: 'wood',
    filename: 'wood-floor-natural.jpg',
    type: 'diffuse',
    tags: ['floor', 'wood', 'planks', 'natural', 'hardwood']
  },
  
  // Fabric textures
  {
    id: 'default-fabric-carpet-01',
    name: 'Carpet - Gray Textured',
    category: 'fabric',
    filename: 'carpet-gray-textured.jpg',
    type: 'diffuse',
    tags: ['carpet', 'fabric', 'gray', 'floor', 'textile', 'woven']
  },
  
  // Brick textures
  {
    id: 'default-brick-wall-01',
    name: 'Brick Wall - Red Standard',
    category: 'brick',
    filename: 'brick-wall-red-standard.jpg',
    type: 'diffuse',
    tags: ['brick', 'wall', 'red', 'masonry', 'exterior', 'classic']
  }
];

/**
 * Converts a default texture config to a TextureAsset
 * Note: dimensions will be set after the texture loads
 */
export function defaultTextureToAsset(config: DefaultTextureConfig): TextureAsset {
  const url = `/textures/${config.category}/${config.filename}`;
  
  return {
    id: config.id,
    name: config.name,
    url: url,
    type: config.type,
    fileSize: 0, // Will be updated when loaded
    dimensions: { width: 0, height: 0 }, // Will be updated when loaded
    uploadedAt: 0 // Default textures don't have upload time
  };
}

/**
 * Get all default textures as TextureAssets
 */
export function getAllDefaultTextures(): TextureAsset[] {
  return DEFAULT_TEXTURES.map(defaultTextureToAsset);
}

/**
 * Get default textures by category
 */
export function getDefaultTexturesByCategory(category: string): TextureAsset[] {
  return DEFAULT_TEXTURES
    .filter(t => t.category === category)
    .map(defaultTextureToAsset);
}

/**
 * Search default textures by tags
 */
export function searchDefaultTextures(searchTerm: string): TextureAsset[] {
  const term = searchTerm.toLowerCase();
  return DEFAULT_TEXTURES
    .filter(t => 
      t.name.toLowerCase().includes(term) ||
      t.tags.some(tag => tag.toLowerCase().includes(term))
    )
    .map(defaultTextureToAsset);
}
</file>

<file path="src/index.css">
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}
</file>

<file path="src/verb-nurbs.d.ts">
declare global {
  interface Window {
    verb: {
      geom: {
        NurbsSurface: {
          new(data: any): {
            tessellate(options?: {
              minDivsU?: number;
              minDivsV?: number;
              refine?: boolean;
            }): {
              points: number[][];
              faces: number[][];
              normals: number[][];
              uvs: number[][];
            };
            
            controlPoints(): number[][][];
            knotsU(): number[];
            knotsV(): number[];
            degreeU(): number;
            degreeV(): number;
            weights(): number[][];
          };
          
          byKnotsControlPointsWeights(
            degreeU: number,
            degreeV: number,
            knotsU: number[],
            knotsV: number[],
            controlPoints: number[][][],
            weights?: number[][]
          ): {
            tessellate(options?: {
              minDivsU?: number;
              minDivsV?: number;
              refine?: boolean;
            }): {
              points: number[][];
              faces: number[][];
              normals: number[][];
              uvs: number[][];
            };
            
            controlPoints(): number[][][];
            knotsU(): number[];
            knotsV(): number[];
            degreeU(): number;
            degreeV(): number;
            weights(): number[][];
          };
        };
      };
    };
  }
}
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'
import { globalIgnores } from 'eslint/config'

export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      js.configs.recommended,
      tseslint.configs.recommended,
      reactHooks.configs['recommended-latest'],
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
  },
])
</file>

<file path="SRC_DOCUMENTATION.md">
# Source Code Documentation

This document provides a detailed breakdown of the `src` directory, outlining the structure, purpose, and functionality of each file and folder.

## Project Overview

This is a 3D modeling application with a focus on AI-powered scene manipulation. It uses React for the user interface, Babylon.js for the 3D rendering and interaction, and a Zustand store for state management.

## High-Level Directory Structure

```
src/
‚îú‚îÄ‚îÄ ai/
‚îú‚îÄ‚îÄ assets/
‚îú‚îÄ‚îÄ babylon/
‚îú‚îÄ‚îÄ components/
‚îú‚îÄ‚îÄ hooks/
‚îú‚îÄ‚îÄ nurbs/
‚îú‚îÄ‚îÄ state/
‚îú‚îÄ‚îÄ types/
‚îú‚îÄ‚îÄ App.css
‚îú‚îÄ‚îÄ App.tsx
‚îú‚îÄ‚îÄ index.css
‚îú‚îÄ‚îÄ main.tsx
‚îú‚îÄ‚îÄ verb-nurbs.d.ts
‚îî‚îÄ‚îÄ vite-env.d.ts
```

## Top-Level Files

### `main.tsx`

This is the main entry point for the React application. It finds the root DOM element and renders the `App` component within React's `StrictMode`. It also imports the global stylesheet `index.css`.

### `App.tsx`

This is the root component of the application. It's a large, central component that orchestrates the entire application.

**Key Responsibilities:**

*   **Main Layout:** It renders the main application layout, which consists of a top toolbar, the main content area with the 3D canvas, and a sidebar.
*   **State Management:** It connects to the `useSceneStore` (Zustand) to get and set application state. This includes scene objects, selections, UI state, etc.
*   **3D Scene Integration:** It uses the `useBabylonScene` hook to initialize and manage the Babylon.js scene, which is rendered onto a `<canvas>` element.
*   **Core Functionality:** It contains the logic for creating, deleting, and duplicating objects in the scene. It also handles camera controls and some UI interactions like dropdown menus.
*   **Component Orchestration:** It renders the `TopToolbar` and `AISidebar` components, passing down necessary state and functions.
*   **API Key Handling:** It displays an initial screen to input an OpenAI API key, which is required for the AI features.

### `App.css` & `index.css`

These files contain the CSS styles for the application.
*   `index.css`: Contains base styles and resets.
*   `App.css`: Contains styles for the main application components, including the layout, toolbar, sidebar, and 3D canvas container.

### `verb-nurbs.d.ts`

This file contains TypeScript type definitions for the `verb-nurbs` library. The presence of this file suggests that the application previously had or has some functionality related to NURBS (Non-Uniform Rational B-Splines) for creating complex curves and surfaces. However, comments in `App.tsx` indicate that this functionality might be deprecated or removed.

### `vite-env.d.ts`

This file is for Vite-specific environment variables and TypeScript configurations, ensuring that Vite's features are correctly typed.

## Directory Breakdown

### `src/ai`

This directory contains the services related to AI integration, specifically for translating natural language commands into actions within the 3D scene.

#### `ai.service.ts`

This file is central to the AI functionality. It defines the `AIService` class which is responsible for communicating with the OpenAI API.

*   **`AIService` Class:**
    *   Takes an OpenAI API key in its constructor.
    *   **`describeScene()`:** Generates a textual description of the current 3D scene's objects. This description is used to provide context to the AI.
    *   **`generateSystemPrompt()`:** Creates a detailed system prompt for the AI. This prompt instructs the AI on its role as a 3D scene assistant, the available commands (`move`, `color`, `scale`, `create`, `delete`), and the expected JSON output format.
    *   **`getSceneCommands()`:** This is the primary method of the service. It takes a natural language prompt from the user, combines it with the system prompt and scene description, sends it to the `gpt-3.5-turbo` model, and then parses the AI's JSON response into an array of `SceneCommand` objects.
    *   The service also includes utility functions for cleaning and parsing the AI's response.

*   **`SceneCommand` Interface:** Defines the TypeScript interface for the structured commands that the AI can issue.

*   **`createAIService()`:** A factory function for creating a new instance of the `AIService`.

### `src/babylon`

This directory is the core of the 3D rendering functionality, containing all the code related to Babylon.js. It manages the scene, objects, user interactions within the 3D canvas, and provides React hooks to connect the 3D world with the application's UI and state.

#### `sceneManager.ts`

This file contains the `SceneManager` class, which acts as a low-level wrapper around the Babylon.js scene. It handles the direct, imperative management of the 3D scene.

*   **`SceneManager` Class:**
    *   **Initialization:** The `initialize` method sets up the core Babylon.js components: `Engine`, `Scene`, `ArcRotateCamera`, `HemisphericLight`, and the `GizmoManager`.
    *   **Mesh Management:** It maintains a `meshMap` to associate `SceneObject` IDs with Babylon.js `Mesh` objects. It includes methods like `addMesh`, `removeMeshById`, and `updateMeshProperties` to manipulate objects in the scene.
    *   **Event Handling:** It sets up pointer observers to detect clicks and hovers on objects within the scene, and exposes callbacks (`setObjectClickCallback`, `setObjectHoverCallback`) to be handled by higher-level logic (specifically, the `useBabylonScene` hook).
    *   **Visuals:** Provides methods to control scene-wide visual aspects like `setWireframeMode` and creating a `createVisualGrid`.
    *   **Camera:** Includes a `setCameraView` method for changing the camera's perspective.
    *   **Disposal:** Has a `dispose` method to clean up all Babylon.js resources.

While this class manages the scene, it is primarily used internally by the `useBabylonScene` hook and not directly by the UI components.

#### `objectFactory.ts`

This file provides a set of factory functions to create primitive 3D shapes.

*   **`createPrimitiveMesh`:** A central factory function that takes a `PrimitiveType` (e.g., `'cube'`, `'sphere'`) and returns a Babylon.js `Mesh` instance.
*   It has individual functions for each shape (`createCube`, `createSphere`, etc.).
*   It abstracts away the `MeshBuilder` calls and provides a single, consistent way to create objects, applying common properties like position, scale, rotation, and color.
*   It explicitly does not handle NURBS creation.

#### `gizmoManager.ts`

This file contains a `GizmoController` class and a `useGizmoManager` hook, which together provide a modern, hook-based approach to managing the transformation gizmos.

*   **`GizmoController` Class:** A dedicated class to manage the lifecycle and state of the Babylon.js `GizmoManager`. It handles enabling/disabling the correct gizmo, attaching it to a mesh, and managing the observers for drag events.
*   **`useGizmoManager` Hook:** This hook integrates the `GizmoController` into the React application. It listens to state changes from `useSceneStore` (like the selected object or current transform mode) and updates the gizmo accordingly. It also handles the callback from the gizmo drag events, updating the object's properties in the store.

#### `babylon/hooks/useBabylonScene.ts`

This is a crucial custom React hook that serves as the primary bridge between the React application (UI and state) and the Babylon.js scene. It encapsulates almost all of the 3D scene logic.

*   **Responsibilities:**
    *   **Initialization:** It initializes the `SceneManager` when the React component mounts and the canvas is ready. It also creates a default scene with a ground and a single cube.
    *   **State Synchronization (Two-way):**
        *   **Store to Scene:** It subscribes to the `useSceneStore` and automatically reflects changes in the 3D scene. For example, if an object is added to the `sceneObjects` array in the store, this hook calls the `sceneManager` to create and add the corresponding mesh to the Babylon scene. It also syncs properties like wireframe mode, grid visibility, and selection highlights.
        *   **Scene to Store:** It uses callbacks from the `sceneManager` (for clicks and hovers) to update the state in the `useSceneStore`. For example, when a user clicks an object in the 3D view, the hook updates the `selectedObjectId` in the store.
    *   **Interaction Logic:** Contains the implementation for how user interactions (like clicks) translate into state changes (like selecting an object).
    *   **Gizmo Integration:** It uses the `useGizmoManager` hook to manage the transformation gizmos.
    *   **API Exposure:** It returns a clean API (`setCameraView`) that can be used by UI components to command the scene.

This hook allows the rest of the application to interact with the 3D scene in a declarative, React-friendly way, without needing to directly interface with the imperative Babylon.js APIs.

### `src/components`

This directory contains all the React components that make up the user interface of the application. The components are organized into logical subdirectories: `layout`, `sidebar`, and `toolbar`.

#### `components/layout`

This directory is intended to hold high-level layout components.

*   **`AppLayout.tsx`**: This file is currently empty. It is likely a placeholder for a future layout component that would structure the main parts of the application's UI.

#### `components/sidebar`

This directory contains the components that make up the main sidebar of the application.

*   **`AISidebar.tsx`**: This is a major component that acts as the control center for the application.
    *   It's a collapsible sidebar that contains other key UI elements.
    *   **AI Command Input:** It provides a `textarea` for users to enter natural language commands. It handles the logic of sending these prompts to the `AIService`, receiving the structured commands, and then executing them by calling the appropriate actions in the `useSceneStore`.
    *   **Child Components:** It renders the `SceneGraph` and `PropertiesPanel` components.
    *   **Info Display:** It also displays a list of keyboard shortcuts and a log of the AI responses.

*   **`SceneGraph.tsx`**: This component renders a list of all the objects in the scene (often called a scene outliner).
    *   It gets the list of `sceneObjects` from the `useSceneStore`.
    *   For each object, it displays its name, type, and color.
    *   It provides controls to select, hide/show, and lock/unlock each object directly from the list.

*   **`PropertiesPanel.tsx`**: This component is a classic properties inspector.
    *   When an object is selected, this panel displays its detailed properties (position, rotation, scale, color).
    *   Users can edit these properties using number and color inputs, which provides precise control over the objects. The changes are immediately reflected in the 3D scene by updating the state in the `useSceneStore`.
    *   It includes special UI for editing NURBS properties, such as tessellation quality and control point positions.
    *   It also has a mode for when multiple objects are selected, providing tools for bulk editing.

#### `components/toolbar`

This directory is intended to hold the components for the main top toolbar.

*   **`TopToolbar.tsx`** & **`ToolbarDropdown.tsx`**: Both of these files are currently empty. The functionality for the top toolbar, including its dropdown menus, is currently implemented directly within a `renderTopToolbar` function inside `App.tsx`. It is likely that the intention is to refactor this logic into these dedicated components.

### `src/hooks`

This directory contains global custom React hooks that can be used by any component.

#### `useKeyboardShortcuts.tsx`

This custom hook is responsible for setting up and managing all global keyboard shortcuts for the application.

*   It adds a `keydown` event listener to the window when it's active.
*   It connects to the `useSceneStore` to trigger actions based on key presses.
*   It handles shortcuts for:
    *   Switching between transform modes (`M` for move, `R` for rotate, `S` for scale).
    *   Deleting selected objects (`Delete`, `Backspace`).
    *   Toggling grid snapping (`Ctrl/Cmd + G`).
    *   Deselecting objects (`Escape`).
*   It is used in `App.tsx` to enable these shortcuts globally.

### `src/nurbs`

This directory was likely intended to hold utility functions related to NURBS (Non-Uniform Rational B-Splines) surfaces.

*   **`nurbs.utils.ts`**: This file is currently empty. This, along with comments in other parts of the codebase, strongly suggests that NURBS functionality was either planned and not implemented, or has been deprecated and removed.

### `src/state`

This directory holds the global state management for the application.

#### `sceneStore.ts`

This is one of the most important files in the application. It defines and creates the global application state using Zustand, a popular state management library for React. This store serves as the single source of truth for the entire application.

*   **Zustand Store (`useSceneStore`):** A custom hook that gives any component access to the shared state and the actions to update it.
*   **`SceneState` Interface:** Defines the shape of the global state, which includes:
    *   **Scene Data:** `sceneObjects` array, `selectedObjectId`, `selectedObjectIds`.
    *   **Interaction State:** `transformMode`, `multiSelectMode`, `snapToGrid`, etc.
    *   **UI State:** `sidebarCollapsed`, `activeDropdown`.
    *   **AI State:** `isLoading`, `apiKey`, `responseLog`.
*   **`SceneActions` Interface:** Defines all the functions that can be used to update the state. Having explicit action functions ensures that state changes are predictable and traceable.
*   **Getters:** The store also includes getter functions to compute derived state (e.g., `getSelectedObject()`, `hasSelection()`).
*   **Devtools:** The store is wrapped with `devtools` middleware, which allows for debugging the state and actions using the Redux DevTools browser extension.

### `src/types`

This directory contains TypeScript definition files, providing a single source for all the custom types used across the application.

#### `types.ts`

This file defines the core data structures and types that are shared throughout the codebase.

*   **Type Aliases:** Defines several type aliases for string literals, such as `TransformMode` and `PrimitiveType`, which helps enforce consistency.
*   **`SceneObject` Interface:** This is a crucial interface that defines the structure of a 3D object in the application's state. It includes properties like `id`, `type`, transform data (`position`, `rotation`, `scale`), and optional data for NURBS surfaces (`verbData`).
*   **Other Interfaces:** It also defines interfaces for `ControlPointVisualization` and `MultiSelectInitialState` to support more complex functionalities.
*   **Constants:** It exports a `materialPresets` array, which provides a predefined list of colors for the UI.

### `src/assets`

This directory contains static assets, such as images and icons, used in the application.

*   **`react.svg`**: This is the standard React logo. It appears to be a leftover from the default Vite project setup and is not currently used within the application's UI.
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2022",
    "useDefineForClassFields": true,
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}
</file>

<file path="tsconfig.json">
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2023",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "verbatimModuleSyntax": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "erasableSyntaxOnly": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})
</file>

<file path="src/babylon/glbImporter.ts">
import { Scene, SceneLoader, AssetContainer, Mesh, StandardMaterial, Color3, Vector3 } from 'babylonjs';
import type { SceneObject, ImportError, ImportErrorType, PrimitiveType, Boundary } from '../types/types';
import { integrateImportedMesh } from './objectFactory';
import { SceneManager } from './sceneManager';
import { computeMeshBoundary, computeCompositeBoundary } from './boundaryUtils';

/**
 * ModelImporter class handles the import and processing of 3D model files (GLB, STL, OBJ)
 */
export class ModelImporter {
  private scene: Scene;
  private sceneManager: SceneManager;
  private maxFileSize: number = 5 * 1024 * 1024; // 5 MB in bytes
  private referenceSize: number = 2.0; // Reference cube size for scaling

  constructor(scene: Scene, sceneManager: SceneManager) {
    this.scene = scene;
    this.sceneManager = sceneManager;
  }

  /**
   * Calculates the bounding box for an imported mesh
   * Handles both single meshes and meshes with children
   * @param mesh The mesh to calculate bounds for
   * @returns The calculated boundary information
   */
  private calculateMeshBounds(mesh: Mesh): Boundary {
    // Force computation of world matrix to ensure accurate bounds
    mesh.computeWorldMatrix(true);
    
    // Check if mesh has children that should be included in bounds
    const hasChildren = mesh.getChildMeshes(false).length > 0;
    
    if (hasChildren) {
      console.log('üì¶ Calculating composite boundary for mesh with children');
      return computeCompositeBoundary(mesh);
    } else {
      console.log('üì¶ Calculating simple boundary for single mesh');
      return computeMeshBoundary(mesh);
    }
  }

  /**
   * Calculates the appropriate scale factor to fit the mesh within reference cube
   * @param boundary The boundary information of the mesh
   * @param targetSize The target size to fit within (default: 2.0)
   * @returns The uniform scale factor to apply
   */
  private calculateScaleFactor(boundary: Boundary, targetSize: number = 2.0): number {
    const { size } = boundary.aabb;
    
    // Find the maximum dimension
    const maxDimension = Math.max(size.x, size.y, size.z);
    
    console.log(`üìè Mesh dimensions: ${size.x.toFixed(3)} x ${size.y.toFixed(3)} x ${size.z.toFixed(3)}`);
    console.log(`üìè Max dimension: ${maxDimension.toFixed(3)}`);
    
    // Avoid division by zero for extremely small objects
    if (maxDimension < 0.001) {
      console.warn('‚ö†Ô∏è Object has extremely small dimensions, using default scale');
      return 1.0;
    }
    
    // Calculate scale factor to fit within target size
    const scaleFactor = targetSize / maxDimension;
    
    // Apply limits to prevent extreme scaling
    const MIN_SCALE = 0.01;  // Prevent invisible objects
    const MAX_SCALE = 100.0; // Prevent numerical issues
    
    const clampedScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scaleFactor));
    
    if (clampedScale !== scaleFactor) {
      console.warn(`‚ö†Ô∏è Scale factor clamped from ${scaleFactor.toFixed(3)} to ${clampedScale.toFixed(3)}`);
    }
    
    console.log(`üîß Scale factor: ${clampedScale.toFixed(3)}`);
    
    return clampedScale;
  }

  /**
   * Applies auto-scaling to fit the mesh within the reference cube size
   * @param mesh The mesh to scale
   * @param autoScale Whether to apply auto-scaling (default: true)
   * @returns The scale factor applied (1.0 if no scaling)
   */
  private applyAutoScaling(mesh: Mesh, autoScale: boolean = true): number {
    if (!autoScale) {
      console.log('üö´ Auto-scaling disabled');
      return 1.0;
    }
    
    console.log('üéØ Applying auto-scaling to imported mesh');
    
    // Calculate the mesh bounds
    const boundary = this.calculateMeshBounds(mesh);
    
    // Calculate the scale factor
    const scaleFactor = this.calculateScaleFactor(boundary, this.referenceSize);
    
    // Apply the scale uniformly to maintain aspect ratio
    mesh.scaling = new Vector3(scaleFactor, scaleFactor, scaleFactor);
    
    // Log the result
    const newBounds = this.calculateMeshBounds(mesh);
    console.log(`‚úÖ Scaled mesh to fit within ${this.referenceSize} x ${this.referenceSize} x ${this.referenceSize} units`);
    console.log(`üì¶ New dimensions: ${newBounds.aabb.size.x.toFixed(3)} x ${newBounds.aabb.size.y.toFixed(3)} x ${newBounds.aabb.size.z.toFixed(3)}`);
    
    return scaleFactor;
  }

  /**
   * Centers the mesh at the origin based on its bounding box
   * @param mesh The mesh to center
   */
  private centerMesh(mesh: Mesh): void {
    console.log('üéØ Centering mesh at origin');
    
    // Calculate current bounds
    const boundary = this.calculateMeshBounds(mesh);
    const center = boundary.aabb.center;
    
    // Adjust position to center the mesh
    mesh.position = mesh.position.subtract(center);
    
    console.log(`‚úÖ Mesh centered - offset by (${-center.x.toFixed(3)}, ${-center.y.toFixed(3)}, ${-center.z.toFixed(3)})`);
  }

  /**
   * Imports a 3D model file and converts it to a SceneObject
   * @param file The 3D model file to import (GLB, STL, or OBJ)
   * @param autoScale Whether to automatically scale the model to fit reference cube (default: true)
   * @returns The imported mesh as a SceneObject
   */
  async importModel(file: File, autoScale: boolean = true): Promise<SceneObject> {
    // Validate file size (5MB limit)
    const maxSize = 5 * 1024 * 1024; // 5MB in bytes
    if (file.size > maxSize) {
      throw new Error('FILE_TOO_LARGE');
    }

    // Get file extension
    const fileExtension = this.getFileExtension(file.name);
    if (!fileExtension) {
      throw new Error('INVALID_FORMAT');
    }

    try {
      console.log(`üìÅ Importing ${file.name} (${(file.size / 1024 / 1024).toFixed(2)}MB)`);
      
      // Read file as base64 data URL
      const dataUrl = await new Promise<string>((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result as string);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });

      // Load the 3D model file using LoadAssetContainer
      const container: AssetContainer = await SceneLoader.LoadAssetContainerAsync(
        "",
        dataUrl,
        this.scene,
        undefined,
        fileExtension
      );

      // Add all assets to the scene
      container.addAllToScene();

      // Filter to get only actual meshes (not transform nodes)
      const meshes = container.meshes.filter(
        m => m instanceof Mesh && m.geometry
      ) as Mesh[];
      
      if (meshes.length === 0) {
        throw new Error('INVALID_FORMAT');
      }

      console.log(`üî® Found ${meshes.length} mesh(es) to process`);

      // Merge all meshes into a single mesh
      const mergedMesh = this.mergeMeshes(meshes);
      
      // Strip materials and apply default gray material
      this.applyDefaultMaterial(mergedMesh);

      // Log pre-scaling dimensions
      if (autoScale) {
        const preBounds = this.calculateMeshBounds(mergedMesh);
        console.log(`üìè Pre-scaling dimensions: ${preBounds.aabb.size.x.toFixed(3)} x ${preBounds.aabb.size.y.toFixed(3)} x ${preBounds.aabb.size.z.toFixed(3)}`);
      }

      // Apply auto-scaling to fit within reference cube
      const scaleFactor = this.applyAutoScaling(mergedMesh, autoScale);
      
      // Optionally center the mesh at origin (after scaling)
      // This is commented out for now to maintain backward compatibility
      // Uncomment if you want imported objects centered at origin
      // this.centerMesh(mergedMesh);

      // Generate a unique ID for the object
      const modelType = fileExtension.substring(1); // Remove the dot
      const objectId = `imported-${modelType}-${Date.now()}`;
      
      console.log(`üì¶ Registering imported mesh as: ${objectId}`);
      console.log(`üìê Final scale factor: ${scaleFactor.toFixed(3)}`);
      
      // Register the mesh with the scene manager
      this.sceneManager.addPreExistingMesh(mergedMesh, objectId);
      
      // Apply standard integration options
      // Note: We don't pass scale when auto-scaling is enabled because we've already applied it to the mesh
      const integrationOptions: any = {
        name: objectId,
        position: new Vector3(0, 0, 0),
        rotation: new Vector3(0, 0, 0),
        color: '#808080'
      };
      
      // Only set scale if auto-scaling is disabled
      if (!autoScale) {
        integrationOptions.scale = new Vector3(1, 1, 1);
      }
      
      integrateImportedMesh(mergedMesh, integrationOptions);

      // Create and return the SceneObject
      // The scale reflects the actual mesh scaling that was applied
      const sceneObject: SceneObject = {
        id: objectId,
        type: `imported-${modelType}` as PrimitiveType,
        position: mergedMesh.position.clone(),
        rotation: mergedMesh.rotation.clone(), 
        scale: mergedMesh.scaling.clone(),
        color: '#808080',
        isNurbs: false
      };

      console.log(`‚úÖ Import complete: ${objectId}`);

      return sceneObject;
    } catch (error) {
      console.error('Error importing 3D model:', error);
      
      // Check for specific error messages
      if (error instanceof Error) {
        if (error.message.includes('Unable to load') || 
            error.message.includes('importScene has failed') ||
            error.message.includes('JSON parse')) {
          // This might be a format issue
          throw new Error('INVALID_FORMAT');
        }
      }
      
      throw new Error('LOADING_FAILED');
    }
  }

  /**
   * Gets the file extension with validation
   * @param filename The filename to extract extension from
   * @returns The file extension (e.g., '.glb', '.stl', '.obj') or null if invalid
   */
  private getFileExtension(filename: string): string | null {
    const extension = filename.toLowerCase().match(/\.(glb|stl|obj)$/);
    return extension ? extension[0] : null;
  }

  /**
   * Validates that the file size is within the allowed limit
   * @param file The file to validate
   * @returns true if valid, false if too large
   */
  private validateFileSize(file: File): boolean {
    return file.size <= this.maxFileSize;
  }

  /**
   * Loads a GLB file using Babylon.js SceneLoader
   * @param file The GLB file to load
   * @returns Promise that resolves to an array of loaded meshes
   */
  private async loadGLBFile(file: File): Promise<Mesh[]> {
    try {
      // Create a blob URL from the file
      const url = URL.createObjectURL(file);
      
      try {
        // Load the GLB file as an asset container
        const assetContainer = await SceneLoader.LoadAssetContainerAsync(
          url,
          '',
          this.scene,
          null,
          '.glb'
        );
        
        // Extract meshes from the container
        const meshes: Mesh[] = assetContainer.meshes.filter(
          (mesh): mesh is Mesh => mesh instanceof Mesh && mesh.geometry !== undefined
        );
        
        // Add all assets to the scene
        assetContainer.addAllToScene();
        
        // Clean up the blob URL
        URL.revokeObjectURL(url);
        
        // Return only the actual meshes (not transform nodes or other types)
        return meshes;
      } catch (loadError) {
        // Clean up the blob URL in case of error
        URL.revokeObjectURL(url);
        throw loadError;
      }
    } catch (error) {
      console.error('Error loading GLB file:', error);
      throw this.createImportError('INVALID_FORMAT', 'IMPORT FAILED');
    }
  }

  /**
   * Merges multiple meshes into a single mesh
   * @param meshes Array of meshes to merge
   * @returns A single merged mesh
   */
  private mergeMeshes(meshes: Mesh[]): Mesh {
    if (meshes.length === 0) {
      // No meshes to merge, create an empty mesh
      return new Mesh('imported-model-empty', this.scene);
    }
    
    if (meshes.length === 1) {
      // Only one mesh, just rename and return it
      meshes[0].name = 'imported-model';
      return meshes[0];
    }
    
    // Multiple meshes need to be merged
    // First, make sure all meshes are enabled and have geometry
    const validMeshes = meshes.filter(mesh => mesh.isEnabled() && mesh.geometry);
    
    if (validMeshes.length === 0) {
      // No valid meshes to merge
      return new Mesh('imported-model-empty', this.scene);
    }
    
    // Create a new merged mesh using Babylon's merge function
    const mergedMesh = Mesh.MergeMeshes(
      validMeshes,
      true,  // dispose source meshes
      true,  // allow different materials (we'll replace them anyway)
      undefined,  // no parent
      false,  // don't optimize vertex data
      true   // use precise bounding info
    );
    
    if (!mergedMesh) {
      // Merge failed, return an empty mesh
      console.warn('Mesh merging failed, creating empty mesh');
      return new Mesh('imported-model-empty', this.scene);
    }
    
    // Set the name of the merged mesh
    mergedMesh.name = 'imported-model';
    
    // Reset position, rotation, and scaling to ensure clean import
    mergedMesh.position = Vector3.Zero();
    mergedMesh.rotation = Vector3.Zero();
    mergedMesh.scaling = Vector3.One();
    
    return mergedMesh;
  }

  /**
   * Applies a default material to the mesh, removing any existing materials
   * @param mesh The mesh to apply the material to
   */
  private applyDefaultMaterial(mesh: Mesh): void {
    // Dispose of any existing material to free up memory
    if (mesh.material) {
      mesh.material.dispose();
    }
    
    // Create a new standard material
    const defaultMaterial = new StandardMaterial('imported-model-material', this.scene);
    
    // Set the default color to gray (#808080)
    defaultMaterial.diffuseColor = Color3.FromHexString('#808080');
    
    // Set some reasonable defaults for the material
    defaultMaterial.specularColor = new Color3(0.2, 0.2, 0.2);
    defaultMaterial.ambientColor = new Color3(0.1, 0.1, 0.1);
    defaultMaterial.backFaceCulling = true;
    
    // Apply the material to the mesh
    mesh.material = defaultMaterial;
    
    // Ensure the mesh is set up for proper rendering
    mesh.receiveShadows = true;
    
    // Make sure the mesh is pickable for selection
    mesh.isPickable = true;
    
    // Enable collision detection
    mesh.checkCollisions = true;
  }

  /**
   * Converts a Babylon.js mesh to a SceneObject format
   * @param mesh The mesh to convert
   * @returns A SceneObject representation of the mesh
   */
  private convertToSceneObject(mesh: Mesh): SceneObject {
    // Generate a unique ID for the imported object
    const timestamp = Date.now();
    const randomId = Math.random().toString(36).substr(2, 9);
    const id = `imported-glb-${timestamp}-${randomId}`;
    
    // Get the mesh position, rotation, and scaling
    // These should already be at origin from the merge process, but we'll use the actual values
    const position = mesh.position.clone();
    const rotation = mesh.rotation.clone();
    const scale = mesh.scaling.clone();
    
    // Get the color from the material we applied
    let color = '#808080'; // Default gray
    if (mesh.material && mesh.material instanceof StandardMaterial) {
      const diffuseColor = mesh.material.diffuseColor;
      color = diffuseColor.toHexString();
    }
    
    // Set the mesh name to match the ID for consistency
    mesh.name = id;
    
    // Create and return the SceneObject
    const sceneObject: SceneObject = {
      id,
      type: 'imported-glb' as PrimitiveType, // Default type for unused method
      position,
      scale,
      rotation,
      color,
      mesh,
      isNurbs: false
    };
    
    return sceneObject;
  }

  /**
   * Creates an ImportError object with proper type and message
   * @param type The type of import error
   * @param message The error message
   * @returns ImportError object
   */
  private createImportError(type: ImportErrorType, message: string): ImportError {
    return {
      type,
      message
    };
  }

  /**
   * Type guard to check if an error is an ImportError
   * @param error The error to check
   * @returns true if the error is an ImportError
   */
  private isImportError(error: any): error is ImportError {
    return error && typeof error === 'object' && 'type' in error && 'message' in error;
  }
}

/**
 * Factory function to create a new ModelImporter instance
 * @param scene The Babylon.js scene
 * @param sceneManager The scene manager instance
 * @returns A new ModelImporter instance
 */
export function createModelImporter(scene: Scene, sceneManager: SceneManager): ModelImporter {
  return new ModelImporter(scene, sceneManager);
}

// Export with old name for backwards compatibility
export const GLBImporter = ModelImporter;
export const createGLBImporter = createModelImporter;
</file>

<file path="src/components/sidebar/SceneGraph.tsx">
import React from 'react';
import { useSceneStore } from '../../state/sceneStore';

export const SceneGraph: React.FC = () => {
  const {
    sceneObjects,
    selectedObjectId,
    selectedObjectIds,
    multiSelectMode,
    objectVisibility,
    objectLocked,
    setSelectedObjectId,
    setObjectVisibility,
    setObjectLocked,
    clearSelection,
    clearAllObjects,
    isObjectVisible,
    isObjectLocked,
  } = useSceneStore();

  const selectObjectById = (objectId: string) => {
    const object = sceneObjects.find(obj => obj.id === objectId);
    if (object) {
      setSelectedObjectId(objectId);
      console.log('üìã Selected from sidebar:', objectId);
    }
  };

  const toggleObjectVisibility = (objectId: string) => {
    const isCurrentlyVisible = isObjectVisible(objectId);
    setObjectVisibility(objectId, !isCurrentlyVisible);
    const obj = sceneObjects.find(o => o.id === objectId);
    if (obj?.mesh) {
      obj.mesh.isVisible = !isCurrentlyVisible;
    }
  };

  const toggleObjectLock = (objectId: string) => {
    const isCurrentlyLocked = isObjectLocked(objectId);
    setObjectLocked(objectId, !isCurrentlyLocked);
    if (!isCurrentlyLocked) {
      clearSelection();
    }
  };

  const visibleObjects = sceneObjects.filter(obj => obj.type !== 'ground');

  return (
    <div className="ai-control-group">
      <label>Scene Objects ({visibleObjects.length}):</label>
      <div className="selection-mode-hint">
        üí° {multiSelectMode ? 'Multi-select mode: Ctrl+Click to select multiple' : 'Click objects to select them'}
      </div>
      <div className="scene-objects">
        {visibleObjects.map(obj => {
          const isSelected = selectedObjectId === obj.id || selectedObjectIds.includes(obj.id);
          const isVisible = objectVisibility[obj.id] !== false;
          const isLocked = objectLocked[obj.id] || false;
          
          return (
            <div 
              key={obj.id} 
              className={`scene-object ${isSelected ? 'selected' : ''} ${isLocked ? 'locked' : ''} ${!isVisible ? 'hidden' : ''}`}
              onClick={() => selectObjectById(obj.id)}
              title={`${isLocked ? '[LOCKED] ' : ''}${!isVisible ? '[HIDDEN] ' : ''}Click to select this object`}
            >
              <span className="object-type">{obj.type}</span>
              <span className="object-id">{obj.id}</span>
              <div className="object-controls">
                <button
                  className={`object-control-btn ${isVisible ? 'visible' : 'hidden'}`}
                  onClick={(e) => {
                    e.stopPropagation();
                    toggleObjectVisibility(obj.id);
                  }}
                  title={isVisible ? 'Hide object' : 'Show object'}
                >
                  {isVisible ? 'üëÅÔ∏è' : 'üö´'}
                </button>
                <button
                  className={`object-control-btn ${isLocked ? 'locked' : 'unlocked'}`}
                  onClick={(e) => {
                    e.stopPropagation();
                    toggleObjectLock(obj.id);
                  }}
                  title={isLocked ? 'Unlock object' : 'Lock object'}
                >
                  {isLocked ? 'üîí' : 'üîì'}
                </button>
              </div>
              <div className="object-color" style={{ backgroundColor: obj.color }}></div>
            </div>
          );
        })}
        {visibleObjects.length === 0 && (
          <div className="no-objects">
            No objects in scene<br/>
            <small>Use the Create menu to add objects</small>
          </div>
        )}
      </div>
      <div className="object-stats">
        <small>
          Selected: {selectedObjectId ? 1 : selectedObjectIds.length} | 
          Hidden: {Object.values(objectVisibility).filter(v => v === false).length} | 
          Locked: {Object.values(objectLocked).filter(v => v === true).length}
        </small>
      </div>
      <button 
        onClick={clearAllObjects}
        className="clear-all-button"
        disabled={visibleObjects.length === 0}
      >
        Clear All Objects
      </button>
    </div>
  );
};
</file>

<file path="src/components/sidebar/TextureLibrary.tsx">
import React, { useState, useMemo } from 'react';
import { useSceneStore } from '../../state/sceneStore';
import type { TextureAsset, TextureType } from '../../types/types';

interface TextureLibraryProps {
    onApply?: (textureId: string, textureType: TextureType) => void;
    className?: string;
}

export const TextureLibrary: React.FC<TextureLibraryProps> = ({
    onApply,
    className = ''
}) => {
    const [searchTerm, setSearchTerm] = useState('');
    const [selectedTextureType, setSelectedTextureType] = useState<TextureType>('diffuse');
    const [renameTextureId, setRenameTextureId] = useState<string | null>(null);
    const [renameName, setRenameName] = useState('');
    const [showDefaultTextures, setShowDefaultTextures] = useState(true);
    const [showUserTextures, setShowUserTextures] = useState(true);
    
    const {
        textureAssets,
        selectedTextureId,
        selectedObjectId,
        selectedObjectIds,
        setSelectedTextureId,
        removeTextureAsset,
        renameTextureAsset,
        applyTextureToObject,
        addToResponseLog,
        hasSelection
    } = useSceneStore();
    
    // Convert Map to array and filter based on search, separating default and user textures
    const { defaultTextures, userTextures } = useMemo(() => {
        const texturesArray = Array.from(textureAssets.values());
        
        // Separate default textures (those with IDs starting with 'default-') from user textures
        const defaults = texturesArray.filter(t => t.id.startsWith('default-'));
        const users = texturesArray.filter(t => !t.id.startsWith('default-'));
        
        // Apply search filter if needed
        if (searchTerm) {
            const term = searchTerm.toLowerCase();
            return {
                defaultTextures: defaults.filter(texture => 
                    texture.name.toLowerCase().includes(term)
                ),
                userTextures: users.filter(texture => 
                    texture.name.toLowerCase().includes(term)
                )
            };
        }
        
        return {
            defaultTextures: defaults,
            userTextures: users
        };
    }, [textureAssets, searchTerm]);
    
    const handleTextureClick = (textureId: string) => {
        setSelectedTextureId(textureId === selectedTextureId ? null : textureId);
    };
    
    const handleApplyTexture = () => {
        if (!selectedTextureId) {
            addToResponseLog('‚ö†Ô∏è Please select a texture to apply');
            return;
        }
        
        if (!hasSelection()) {
            addToResponseLog('‚ö†Ô∏è Please select an object to apply texture to');
            return;
        }
        
        // Apply to single or multiple objects
        const objectIds = selectedObjectId ? [selectedObjectId] : selectedObjectIds;
        
        objectIds.forEach(objectId => {
            applyTextureToObject(objectId, selectedTextureId, selectedTextureType);
        });
        
        const texture = textureAssets.get(selectedTextureId);
        const objectCount = objectIds.length;
        addToResponseLog(`‚úÖ Applied ${texture?.name || 'texture'} (${selectedTextureType}) to ${objectCount} object${objectCount > 1 ? 's' : ''}`);
        
        // Call callback if provided
        if (onApply) {
            onApply(selectedTextureId, selectedTextureType);
        }
    };
    
    const handleDeleteTexture = (textureId: string, e: React.MouseEvent) => {
        e.stopPropagation(); // Prevent texture selection
        
        // Don't allow deleting default textures
        if (textureId.startsWith('default-')) {
            addToResponseLog('‚ö†Ô∏è Default textures cannot be deleted');
            return;
        }
        
        const texture = textureAssets.get(textureId);
        if (window.confirm(`Delete texture "${texture?.name}"?`)) {
            removeTextureAsset(textureId);
            addToResponseLog(`üóëÔ∏è Deleted texture: ${texture?.name}`);
            
            // Clear selection if deleted texture was selected
            if (selectedTextureId === textureId) {
                setSelectedTextureId(null);
            }
        }
    };
    
    const handleRename = (textureId: string, e: React.MouseEvent) => {
        e.stopPropagation();
        
        // Don't allow renaming default textures
        if (textureId.startsWith('default-')) {
            return;
        }
        
        const texture = textureAssets.get(textureId);
        if (texture) {
            setRenameTextureId(textureId);
            setRenameName(texture.name);
        }
    };
    
    const handleRenameSubmit = (textureId: string) => {
        if (renameName.trim()) {
            renameTextureAsset(textureId, renameName.trim());
            addToResponseLog(`‚úèÔ∏è Renamed texture to: ${renameName.trim()}`);
        }
        setRenameTextureId(null);
        setRenameName('');
    };
    
    const formatFileSize = (bytes: number): string => {
        if (bytes === 0) return 'N/A'; // For default textures
        if (bytes < 1024) return bytes + ' B';
        if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
        return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
    };
    
    const formatDate = (timestamp: number): string => {
        if (timestamp === 0) return 'Built-in'; // For default textures
        const date = new Date(timestamp);
        const now = new Date();
        const diffMs = now.getTime() - date.getTime();
        const diffMins = Math.floor(diffMs / 60000);
        
        if (diffMins < 1) return 'Just now';
        if (diffMins < 60) return `${diffMins} min ago`;
        if (diffMins < 1440) return `${Math.floor(diffMins / 60)} hours ago`;
        return date.toLocaleDateString();
    };
    
    const renderTextureItem = (texture: TextureAsset, isDefault: boolean = false) => (
        <div
            key={texture.id}
            className={`texture-item ${selectedTextureId === texture.id ? 'selected' : ''} ${isDefault ? 'default-texture' : ''}`}
            onClick={() => handleTextureClick(texture.id)}
        >
            <div className="texture-thumbnail">
                <img src={texture.url} alt={texture.name} />
            </div>
            
            <div className="texture-info">
                {renameTextureId === texture.id ? (
                    <input
                        type="text"
                        value={renameName}
                        onChange={(e) => setRenameName(e.target.value)}
                        onBlur={() => handleRenameSubmit(texture.id)}
                        onKeyPress={(e) => {
                            if (e.key === 'Enter') {
                                handleRenameSubmit(texture.id);
                            }
                        }}
                        onClick={(e) => e.stopPropagation()}
                        className="texture-rename-input"
                        autoFocus
                    />
                ) : (
                    <div className="texture-name" title={texture.name}>
                        {texture.name}
                    </div>
                )}
                
                <div className="texture-meta">
                    <span>{texture.dimensions.width}√ó{texture.dimensions.height}</span>
                    <span>{formatFileSize(texture.fileSize)}</span>
                </div>
                
                <div className="texture-date">
                    {formatDate(texture.uploadedAt)}
                </div>
            </div>
            
            {!isDefault && (
                <div className="texture-actions">
                    <button
                        className="texture-action-btn rename"
                        onClick={(e) => handleRename(texture.id, e)}
                        title="Rename"
                    >
                        ‚úèÔ∏è
                    </button>
                    <button
                        className="texture-action-btn delete"
                        onClick={(e) => handleDeleteTexture(texture.id, e)}
                        title="Delete"
                    >
                        üóëÔ∏è
                    </button>
                </div>
            )}
        </div>
    );
    
    return (
        <div className={`texture-library-container ${className}`}>
            <div className="texture-library-header">
                <input
                    type="text"
                    placeholder="Search textures..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="texture-search-input"
                />
                
                <div className="texture-type-selector">
                    <label>Type:</label>
                    <select 
                        value={selectedTextureType} 
                        onChange={(e) => setSelectedTextureType(e.target.value as TextureType)}
                        className="texture-type-select"
                    >
                        <option value="diffuse">Diffuse</option>
                        <option value="normal">Normal</option>
                        <option value="specular">Specular</option>
                        <option value="emissive">Emissive</option>
                    </select>
                </div>
            </div>
            
            {defaultTextures.length === 0 && userTextures.length === 0 ? (
                <div className="texture-library-empty">
                    <span className="empty-icon">üñºÔ∏è</span>
                    <span className="empty-text">
                        {searchTerm ? 'No textures found' : 'Loading textures...'}
                    </span>
                </div>
            ) : (
                <div className="texture-sections">
                    {/* Default Textures Section */}
                    {defaultTextures.length > 0 && (
                        <div className="texture-section">
                            <div 
                                className="texture-section-header" 
                                onClick={() => setShowDefaultTextures(!showDefaultTextures)}
                            >
                                <span className="section-toggle">{showDefaultTextures ? '‚ñº' : '‚ñ∂'}</span>
                                <h4>Default Textures ({defaultTextures.length})</h4>
                            </div>
                            {showDefaultTextures && (
                                <div className="texture-grid">
                                    {defaultTextures.map(texture => renderTextureItem(texture, true))}
                                </div>
                            )}
                        </div>
                    )}
                    
                    {/* User Textures Section */}
                    {userTextures.length > 0 && (
                        <div className="texture-section">
                            <div 
                                className="texture-section-header" 
                                onClick={() => setShowUserTextures(!showUserTextures)}
                            >
                                <span className="section-toggle">{showUserTextures ? '‚ñº' : '‚ñ∂'}</span>
                                <h4>My Textures ({userTextures.length})</h4>
                            </div>
                            {showUserTextures && (
                                <div className="texture-grid">
                                    {userTextures.map(texture => renderTextureItem(texture, false))}
                                </div>
                            )}
                        </div>
                    )}
                </div>
            )}
            
            {selectedTextureId && hasSelection() && (
                <div className="texture-apply-section">
                    <button
                        className="texture-apply-button"
                        onClick={handleApplyTexture}
                    >
                        Apply {selectedTextureType} Texture
                    </button>
                </div>
            )}
        </div>
    );
};
</file>

<file path="src/hooks/useKeyboardShortcuts.tsx">
import { useEffect } from 'react'
import { useSceneStore } from '../state/sceneStore'

export const useKeyboardShortcuts = () => {
  const {
    // State
    snapToGrid,
    selectedObjectId,
    selectedObjectIds,
    activeDropdown,
    
    // Actions
    setSnapToGrid,
    setTransformMode,
    clearSelection,
    removeObject,
    setActiveDropdown,
    hasSelection
  } = useSceneStore()

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      // Skip if user is typing in an input or textarea
      if (event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement) {
        return
      }

      const key = event.key.toLowerCase()
      const isCtrlOrCmd = event.ctrlKey || event.metaKey

      switch (key) {
        case 'g':
          if (isCtrlOrCmd) {
            event.preventDefault()
            setSnapToGrid(!snapToGrid)
            console.log('‚ö° Keyboard: Snap to grid toggled:', !snapToGrid)
          }
          break

        case 'delete':
        case 'backspace':
          if (hasSelection()) {
            event.preventDefault()
            const objectsToDelete = selectedObjectId ? [selectedObjectId] : selectedObjectIds
            objectsToDelete.forEach(id => removeObject(id))
            clearSelection()
            console.log('‚ö° Keyboard: Deleted selected objects:', objectsToDelete)
          }
          break

        case 'r':
          if (!isCtrlOrCmd) {
            event.preventDefault()
            setTransformMode('rotate')
            console.log('‚ö° Keyboard: Transform mode set to rotate')
          }
          break

        case 's':
          if (!isCtrlOrCmd) {
            event.preventDefault()
            setTransformMode('scale')
            console.log('‚ö° Keyboard: Transform mode set to scale')
          }
          break

        case 'm':
          if (!isCtrlOrCmd) {
            event.preventDefault()
            setTransformMode('move')
            console.log('‚ö° Keyboard: Transform mode set to move')
          }
          break

        case 'escape':
          event.preventDefault()
          clearSelection()
          setActiveDropdown(null)
          console.log('‚ö° Keyboard: Cleared selection and closed dropdowns')
          break

        default:
          // No action for other keys
          break
      }
    }

    // Add event listener
    window.addEventListener('keydown', handleKeyDown)
    
    // Cleanup event listener on unmount
    return () => {
      window.removeEventListener('keydown', handleKeyDown)
    }
  }, [
    snapToGrid,
    selectedObjectId,
    selectedObjectIds,
    activeDropdown,
    setSnapToGrid,
    setTransformMode,
    clearSelection,
    removeObject,
    setActiveDropdown,
    hasSelection
  ])

  // This hook doesn't return anything, it just sets up the event listeners
  return null
}
</file>

<file path="import.md">
# 3D Model Import Process Documentation

## Overview
The vibeCAD application supports importing 3D models in GLB, STL, and OBJ formats. The import process is designed to handle files up to 5MB, convert them to a unified format, and integrate them seamlessly into the scene.

## Supported Formats
- **GLB** (Binary GLTF) - Optimized 3D models with embedded textures and materials
- **STL** (Stereolithography) - Common format for 3D printing, geometry only
- **OBJ** (Wavefront) - Widely supported format with material support

## File Size Limit
- Maximum: 5MB (5 * 1024 * 1024 bytes)

## Import Process Flow

```mermaid
graph TD
    A[User Clicks Import Button] --> B[File Picker Opens]
    B --> C{File Selected?}
    C -->|No| Z[Process Ends]
    C -->|Yes| D[File Validation]
    
    D --> E{File Size < 5MB?}
    E -->|No| F[Show FILE_TOO_LARGE Error]
    F --> Z
    
    E -->|Yes| G{Valid Extension?}
    G -->|No| H[Show INVALID_FORMAT Error]
    H --> Z
    
    G -->|Yes| I[Read File as Data URL]
    I --> J[Load with Babylon.js]
    
    J --> K{Loading Success?}
    K -->|No| L[Show LOADING_FAILED Error]
    L --> Z
    
    K -->|Yes| M[Extract Meshes]
    M --> N{Meshes Found?}
    N -->|No| O[Show INVALID_FORMAT Error]
    O --> Z
    
    N -->|Yes| P[Merge All Meshes]
    P --> Q[Apply Default Material]
    Q --> Q1[Calculate Bounding Box]
    Q1 --> Q2[Auto-Scale to 2x2x2 Reference]
    Q2 --> R[Generate Unique ID]
    R --> S[Add to Scene Manager]
    S --> T[Add to Store]
    T --> U[Update UI]
    U --> V[Success Message]
    V --> Z
    
    style A fill:#4CAF50
    style V fill:#4CAF50
    style F fill:#f44336
    style H fill:#f44336
    style L fill:#f44336
    style O fill:#f44336
    style Q1 fill:#2196F3
    style Q2 fill:#2196F3
```

## Key Files and Their Roles

### 1. **UI Components**

#### `/src/components/sidebar/ImportButton.tsx`
- **Purpose**: Provides the UI button and file input handling
- **Key Functions**:
  - `handleClick()`: Triggers the hidden file input
  - `handleFileSelect()`: Handles file selection and calls the import callback
- **Features**:
  - Shows loading state during import
  - Displays local error messages
  - Accepts `.glb`, `.stl`, `.obj` files

#### `/src/components/sidebar/AISidebar.tsx`
- **Purpose**: Contains the import button and manages the import flow
- **Key Functions**:
  - `handleImportGLB()`: Main import orchestrator
- **Responsibilities**:
  - Creates the ModelImporter instance
  - Manages import state (loading, errors)
  - Adds imported object to scene store
  - Updates response log

### 2. **Import Logic**

#### `/src/babylon/glbImporter.ts`
- **Purpose**: Core import logic and 3D model processing
- **Classes**:
  - `ModelImporter`: Main class handling the import process
- **Key Methods**:
  - `importModel()`: Main entry point for importing (now with optional autoScale parameter)
  - `getFileExtension()`: Validates and extracts file extension
  - `mergeMeshes()`: Combines multiple meshes into one
  - `applyDefaultMaterial()`: Strips materials and applies gray material
  - `calculateMeshBounds()`: Calculates bounding box for imported mesh (NEW)
  - `calculateScaleFactor()`: Determines scale factor to fit in 2x2x2 cube (NEW)
  - `applyAutoScaling()`: Applies uniform scaling to maintain aspect ratio (NEW)
  - `centerMesh()`: Centers mesh at origin based on bounding box (NEW)
- **Process**:
  1. Validates file size (5MB limit)
  2. Reads file as base64 data URL
  3. Uses Babylon.js SceneLoader to parse the file
  4. Merges all meshes into a single mesh
  5. Applies default gray material
  6. Auto-scales to fit within 2x2x2 reference cube (NEW)
  7. Generates unique ID based on file type

### 3. **3D Scene Integration**

#### `/src/babylon/sceneManager.ts`
- **Purpose**: Manages the Babylon.js scene and meshes
- **Import-Related Features**:
  - Imports `babylonjs-loaders` to register file format loaders
  - `addMesh()`: Handles 'imported-glb', 'imported-stl', 'imported-obj' types
  - `addPreExistingMesh()`: Registers already-created meshes from imports

#### `/src/babylon/objectFactory.ts`
- **Purpose**: Factory for creating 3D objects
- **Import Integration**:
  - `integrateImportedMesh()`: Applies standard options to imported meshes
  - `createPrimitiveMesh()`: Routes imported types to error (they use different flow)

### 4. **State Management**

#### `/src/state/sceneStore.ts`
- **Purpose**: Global state management using Zustand
- **Import State**:
  - `isImporting`: Boolean flag for loading state
  - `importError`: Stores import error details
- **Import Actions**:
  - `startImport()`: Sets loading state
  - `importSuccess()`: Clears loading state
  - `setImportError()`: Sets error state
  - `clearImportError()`: Clears error state
  - `addObject()`: Adds imported object to scene

### 5. **Type Definitions**

#### `/src/types/types.ts`
- **Purpose**: TypeScript type definitions
- **Import Types**:
  - `PrimitiveType`: Includes 'imported-glb', 'imported-stl', 'imported-obj'
  - `ImportError`: Interface for import error structure
  - `ImportErrorType`: Union type for error types
  - `SceneObject`: Interface for all scene objects including imports

### 6. **Entry Point**

#### `/src/main.tsx`
- **Purpose**: Application entry point
- **Import Setup**:
  - Imports `babylonjs-loaders` at the very top
  - Ensures loaders are registered before any Babylon.js usage

### 7. **Styling**

#### `/src/App.css`
- **Purpose**: Application styles
- **Import Styles**:
  - `.import-button`: Button styling (green background)
  - `.import-error`: Error message styling
  - `.import-error-message`: Additional error display styling

## External Dependencies

### `/package.json`
- **babylonjs**: ^8.15.1 - Core 3D engine
- **babylonjs-loaders**: ^8.15.1 - File format loaders for GLB/STL/OBJ

## Import Process Detailed Steps

1. **User Interaction**
   - User clicks "Import 3D Model" button
   - File picker opens with filter for .glb, .stl, .obj files

2. **File Validation**
   - Check file size (must be < 5MB)
   - Validate file extension

3. **File Reading**
   - File is read as base64 data URL using FileReader API
   - This avoids blob URL issues with Babylon.js

4. **Babylon.js Loading**
   - SceneLoader.LoadAssetContainerAsync() parses the file
   - Appropriate loader (GLB/STL/OBJ) is automatically selected
   - All assets are added to the scene

5. **Mesh Processing**
   - Filter out non-mesh objects (cameras, lights, etc.)
   - Merge multiple meshes into single mesh using Mesh.MergeMeshes()
   - Reset transform to origin

6. **Material Processing**
   - Remove all existing materials
   - Apply uniform gray (#808080) StandardMaterial
   - Set material properties for proper rendering

7. **Auto-Scaling** (NEW)
   - Calculate bounding box using `computeMeshBoundary()` or `computeCompositeBoundary()`
   - Determine maximum dimension (width, height, or depth)
   - Calculate scale factor to fit within 2x2x2 reference cube
   - Apply uniform scaling to maintain aspect ratio
   - Optional: Center mesh at origin

8. **Scene Integration**
   - Generate unique ID: `imported-{type}-{timestamp}`
   - Register mesh with SceneManager
   - Apply standard object properties

9. **State Update**
   - Create SceneObject with proper type
   - Add to scene store
   - Update UI components

10. **User Feedback**
    - Show success message in response log
    - Clear loading state
    - Object appears in scene graph

## Error Handling

### Error Types
1. **FILE_TOO_LARGE**: File exceeds 5MB limit
2. **INVALID_FORMAT**: File format not recognized or no valid geometry
3. **LOADING_FAILED**: Generic loading error

### Error Display
- All errors show "IMPORT FAILED" message
- Errors are displayed below the import button
- Errors are logged to the AI response log

## Material Handling
- All imported materials are stripped
- Default gray color (#808080) is applied
- Users can change color after import using properties panel

## Unique Features
- Single mesh output regardless of input complexity
- Consistent naming convention across file types
- Integration with existing transform tools
- Full support for selection, manipulation, and AI commands

## File Relationship Diagram

```mermaid
graph LR
    subgraph "User Interface"
        A[ImportButton.tsx]
        B[AISidebar.tsx]
        C[SceneGraph.tsx]
        D[PropertiesPanel.tsx]
    end
    
    subgraph "Import Logic"
        E[glbImporter.ts]
        F[ModelImporter class]
    end
    
    subgraph "3D Scene"
        G[sceneManager.ts]
        H[objectFactory.ts]
        I[Babylon.js Scene]
    end
    
    subgraph "State Management"
        J[sceneStore.ts]
        K[Zustand Store]
    end
    
    subgraph "Type System"
        L[types.ts]
    end
    
    subgraph "Dependencies"
        M[babylonjs]
        N[babylonjs-loaders]
    end
    
    subgraph "Entry Point"
        O[main.tsx]
    end
    
    A -->|triggers| B
    B -->|creates| F
    F -->|processes file| E
    E -->|loads model| I
    E -->|registers mesh| G
    E -->|applies options| H
    B -->|updates state| J
    J -->|notifies| C
    J -->|notifies| D
    G -->|uses| I
    H -->|uses| I
    J -->|implements| K
    L -->|types for| A
    L -->|types for| B
    L -->|types for| E
    L -->|types for| J
    I -->|requires| M
    I -->|requires| N
    O -->|imports| N
    
    style A fill:#81C784
    style B fill:#81C784
    style E fill:#64B5F6
    style G fill:#FFB74D
    style J fill:#BA68C8
    style O fill:#F06292
```

## Summary

The import process in vibeCAD is a well-orchestrated flow that involves multiple layers:

1. **Presentation Layer**: UI components handle user interaction and display
2. **Business Logic Layer**: ModelImporter processes and validates files
3. **Integration Layer**: Scene management integrates models into Babylon.js
4. **State Layer**: Zustand store maintains application state
5. **Infrastructure Layer**: Babylon.js and its loaders handle the actual file parsing

This architecture ensures:
- Clean separation of concerns
- Robust error handling at each layer
- Consistent user experience
- Easy extensibility for new formats
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
    <script src="https://cdn.jsdelivr.net/npm/verb-nurbs@2.0.0/build/js/verb.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type-aware lint rules:

```js
export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...

      // Remove tseslint.configs.recommended and replace with this
      ...tseslint.configs.recommendedTypeChecked,
      // Alternatively, use this for stricter rules
      ...tseslint.configs.strictTypeChecked,
      // Optionally, add this for stylistic rules
      ...tseslint.configs.stylisticTypeChecked,

      // Other configs...
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```

You can also install [eslint-plugin-react-x](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-x) and [eslint-plugin-react-dom](https://github.com/Rel1cx/eslint-react/tree/main/packages/plugins/eslint-plugin-react-dom) for React-specific lint rules:

```js
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config([
  globalIgnores(['dist']),
  {
    files: ['**/*.{ts,tsx}'],
    extends: [
      // Other configs...
      // Enable lint rules for React
      reactX.configs['recommended-typescript'],
      // Enable lint rules for React DOM
      reactDom.configs.recommended,
    ],
    languageOptions: {
      parserOptions: {
        project: ['./tsconfig.node.json', './tsconfig.app.json'],
        tsconfigRootDir: import.meta.dirname,
      },
      // other options...
    },
  },
])
```
Singular change
</file>

<file path=".gitignore">
# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

.cursor/

# Build outputs
dist/
build/
*.tsbuildinfo

# Environment files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE and editor files
.vscode/
.idea/
*.swp
*.swo
*~

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
logs/
*.log

# Coverage directory used by tools like istanbul
coverage/
*.lcov
.nyc_output/

# Temporary folders
tmp/
temp/

# Cache directories
.cache/
.parcel-cache/
.vite/

# Runtime data
pids/
*.pid
*.seed
*.pid.lock

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

.cursor/
</file>

<file path="src/babylon/housingFactory.ts">
import { Scene, MeshBuilder, StandardMaterial, Color3, Mesh, Vector3, CSG } from 'babylonjs';
import type { MeshCreationOptions } from './objectFactory';
import type { Wall, Door, Window, HousingComponent, ModularHousingObject, DoorType, WindowType, WallType } from '../types/types';

/**
 * Creates a wall mesh with specified dimensions and properties
 */
export const createWall = (scene: Scene, wall: Wall, options: MeshCreationOptions = {}): Mesh => {
  const length = wall.startPoint.subtract(wall.endPoint).length();
  const wallMesh = MeshBuilder.CreateBox(`wall-${wall.id}`, {
    width: length,
    height: wall.height,
    depth: wall.thickness
  }, scene);

  // Position the wall at the midpoint between start and end points
  const midpoint = wall.startPoint.add(wall.endPoint).scale(0.5);
  wallMesh.position = midpoint;

  // Calculate rotation to align with wall direction
  const direction = wall.endPoint.subtract(wall.startPoint).normalize();
  const angle = Math.atan2(direction.x, direction.z);
  wallMesh.rotation.y = angle;

  // Apply material
  const material = new StandardMaterial(`wall-${wall.id}-material`, scene);
  material.diffuseColor = Color3.FromHexString(wall.color);
  wallMesh.material = material;

  return wallMesh;
};

/**
 * Creates a door mesh with specified properties
 */
export const createDoor = (scene: Scene, door: Door, options: MeshCreationOptions = {}): Mesh => {
  let doorMesh: Mesh;

  switch (door.type) {
    case 'single':
      doorMesh = MeshBuilder.CreateBox(`door-${door.id}`, {
        width: door.width,
        height: door.height,
        depth: door.thickness
      }, scene);
      break;
    case 'double':
      const leftDoor = MeshBuilder.CreateBox(`door-${door.id}-left`, {
        width: door.width / 2,
        height: door.height,
        depth: door.thickness
      }, scene);
      const rightDoor = MeshBuilder.CreateBox(`door-${door.id}-right`, {
        width: door.width / 2,
        height: door.height,
        depth: door.thickness
      }, scene);
      leftDoor.position.x = -door.width / 4;
      rightDoor.position.x = door.width / 4;
      doorMesh = Mesh.MergeMeshes([leftDoor, rightDoor], true, true) || leftDoor;
      break;
    case 'sliding':
      doorMesh = MeshBuilder.CreateBox(`door-${door.id}`, {
        width: door.width,
        height: door.height,
        depth: door.thickness / 2
      }, scene);
      break;
    case 'french':
      const leftFrench = MeshBuilder.CreateBox(`door-${door.id}-left`, {
        width: door.width / 2,
        height: door.height,
        depth: door.thickness
      }, scene);
      const rightFrench = MeshBuilder.CreateBox(`door-${door.id}-right`, {
        width: door.width / 2,
        height: door.height,
        depth: door.thickness
      }, scene);
      leftFrench.position.x = -door.width / 4;
      rightFrench.position.x = door.width / 4;
      doorMesh = Mesh.MergeMeshes([leftFrench, rightFrench], true, true) || leftFrench;
      break;
    case 'garage':
      doorMesh = MeshBuilder.CreateBox(`door-${door.id}`, {
        width: door.width,
        height: door.height,
        depth: door.thickness / 4
      }, scene);
      break;
    default:
      doorMesh = MeshBuilder.CreateBox(`door-${door.id}`, {
        width: door.width,
        height: door.height,
        depth: door.thickness
      }, scene);
  }

  doorMesh.position = door.position.clone();

  // Apply material
  const material = new StandardMaterial(`door-${door.id}-material`, scene);
  material.diffuseColor = Color3.FromHexString(door.color);
  doorMesh.material = material;

  return doorMesh;
};

/**
 * Creates a window mesh with specified properties
 */
export const createWindow = (scene: Scene, window: Window, options: MeshCreationOptions = {}): Mesh => {
  const frameThickness = window.hasFrame ? window.frameThickness : 0;
  
  let windowMesh: Mesh;

  if (window.hasFrame) {
    // Create frame
    const outerFrame = MeshBuilder.CreateBox(`window-${window.id}-outer`, {
      width: window.width,
      height: window.height,
      depth: frameThickness
    }, scene);

    const glassWidth = window.width - frameThickness * 2;
    const glassHeight = window.height - frameThickness * 2;

    if (glassWidth > 0 && glassHeight > 0) {
      const glass = MeshBuilder.CreateBox(`window-${window.id}-glass`, {
        width: glassWidth,
        height: glassHeight,
        depth: frameThickness / 2
      }, scene);

      // Make glass transparent
      const glassMaterial = new StandardMaterial(`window-${window.id}-glass-material`, scene);
      glassMaterial.diffuseColor = new Color3(0.8, 0.9, 1.0);
      glassMaterial.alpha = 0.3;
      glass.material = glassMaterial;

      windowMesh = Mesh.MergeMeshes([outerFrame, glass], true, false) || outerFrame;
    } else {
      windowMesh = outerFrame;
    }
  } else {
    // Just glass
    windowMesh = MeshBuilder.CreateBox(`window-${window.id}`, {
      width: window.width,
      height: window.height,
      depth: 0.02
    }, scene);

    const glassMaterial = new StandardMaterial(`window-${window.id}-material`, scene);
    glassMaterial.diffuseColor = new Color3(0.8, 0.9, 1.0);
    glassMaterial.alpha = 0.3;
    windowMesh.material = glassMaterial;
  }

  windowMesh.position = window.position.clone();

  // Apply frame material if has frame
  if (window.hasFrame && windowMesh.material) {
    const frameMaterial = new StandardMaterial(`window-${window.id}-frame-material`, scene);
    frameMaterial.diffuseColor = Color3.FromHexString(window.color);
    // Don't override glass material, just set the frame material
  }

  return windowMesh;
};

/**
 * Creates a ceiling mesh for a room
 */
export const createCeiling = (scene: Scene, walls: Wall[], height: number, thickness: number = 0.1, color: string = '#f0f0f0'): Mesh => {
  // Calculate room bounds from walls
  const points: Vector3[] = [];
  walls.forEach(wall => {
    points.push(wall.startPoint);
    points.push(wall.endPoint);
  });

  if (points.length === 0) {
    // Fallback: create a simple rectangular ceiling
    const ceiling = MeshBuilder.CreateBox('ceiling', {
      width: 4,
      height: thickness,
      depth: 4
    }, scene);
    ceiling.position.y = height;
    return ceiling;
  }

  // Find bounding box
  const minX = Math.min(...points.map(p => p.x));
  const maxX = Math.max(...points.map(p => p.x));
  const minZ = Math.min(...points.map(p => p.z));
  const maxZ = Math.max(...points.map(p => p.z));

  const width = maxX - minX;
  const depth = maxZ - minZ;

  const ceiling = MeshBuilder.CreateBox('ceiling', {
    width: width,
    height: thickness,
    depth: depth
  }, scene);

  ceiling.position = new Vector3(
    (minX + maxX) / 2,
    height,
    (minZ + maxZ) / 2
  );

  // Apply material
  const material = new StandardMaterial('ceiling-material', scene);
  material.diffuseColor = Color3.FromHexString(color);
  ceiling.material = material;

  return ceiling;
};

/**
 * Creates a floor mesh for a room
 */
export const createFloor = (scene: Scene, walls: Wall[], thickness: number = 0.05, color: string = '#8B4513'): Mesh => {
  // Calculate room bounds from walls
  const points: Vector3[] = [];
  walls.forEach(wall => {
    points.push(wall.startPoint);
    points.push(wall.endPoint);
  });

  if (points.length === 0) {
    // Fallback: create a simple rectangular floor
    const floor = MeshBuilder.CreateBox('floor', {
      width: 4,
      height: thickness,
      depth: 4
    }, scene);
    floor.position.y = thickness / 2;
    return floor;
  }

  // Find bounding box
  const minX = Math.min(...points.map(p => p.x));
  const maxX = Math.max(...points.map(p => p.x));
  const minZ = Math.min(...points.map(p => p.z));
  const maxZ = Math.max(...points.map(p => p.z));

  const width = maxX - minX;
  const depth = maxZ - minZ;

  const floor = MeshBuilder.CreateBox('floor', {
    width: width,
    height: thickness,
    depth: depth
  }, scene);

  floor.position = new Vector3(
    (minX + maxX) / 2,
    thickness / 2,
    (minZ + maxZ) / 2
  );

  // Apply material
  const material = new StandardMaterial('floor-material', scene);
  material.diffuseColor = Color3.FromHexString(color);
  floor.material = material;

  return floor;
};

/**
 * Modular Housing Builder class for creating complex housing assemblies
 */
export class ModularHousingBuilder {
  private scene: Scene;
  private housingObject: ModularHousingObject;
  private meshes: Mesh[] = [];

  constructor(scene: Scene, housingObject: ModularHousingObject) {
    this.scene = scene;
    this.housingObject = housingObject;
  }

  /**
   * Builds the complete housing object with all components
   */
  build(): Mesh {
    const meshes: Mesh[] = [];

    // Create walls
    this.housingObject.walls.forEach(wall => {
      const wallMesh = this.createWallWithOpenings(wall);
      meshes.push(wallMesh);
    });

    // Create floor if enabled
    if (this.housingObject.hasFloor) {
      const floorMesh = createFloor(
        this.scene,
        this.housingObject.walls,
        this.housingObject.floorThickness,
        this.housingObject.color
      );
      meshes.push(floorMesh);
    }

    // Create ceiling if enabled
    if (this.housingObject.hasCeiling) {
      const ceilingMesh = createCeiling(
        this.scene,
        this.housingObject.walls,
        this.housingObject.ceilingHeight,
        0.1,
        this.housingObject.color
      );
      meshes.push(ceilingMesh);
    }

    // Create foundation if enabled
    if (this.housingObject.hasFoundation) {
      const foundationMesh = this.createFoundation();
      meshes.push(foundationMesh);
    }

    // Merge all meshes into a single object
    const finalMesh = Mesh.MergeMeshes(meshes, true, true);
    
    if (finalMesh) {
      finalMesh.name = this.housingObject.id;
      finalMesh.position = this.housingObject.position.clone();
      finalMesh.rotation = this.housingObject.rotation.clone();
      finalMesh.scaling = this.housingObject.scale.clone();
    }

    return finalMesh || meshes[0];
  }

  /**
   * Creates a wall with door and window openings using CSG
   */
  private createWallWithOpenings(wall: Wall): Mesh {
    // Create the base wall
    const wallMesh = createWall(this.scene, wall);
    
    if (wall.doors.length === 0 && wall.windows.length === 0) {
      return wallMesh;
    }

    try {
      let wallCSG = CSG.FromMesh(wallMesh);

      // Subtract door openings
      wall.doors.forEach(door => {
        const doorOpening = this.createDoorOpening(door, wall);
        const doorCSG = CSG.FromMesh(doorOpening);
        wallCSG = wallCSG.subtract(doorCSG);
        doorOpening.dispose();
      });

      // Subtract window openings
      wall.windows.forEach(window => {
        const windowOpening = this.createWindowOpening(window, wall);
        const windowCSG = CSG.FromMesh(windowOpening);
        wallCSG = wallCSG.subtract(windowCSG);
        windowOpening.dispose();
      });

      const resultMesh = wallCSG.toMesh(`wall-${wall.id}-with-openings`, wallMesh.material, this.scene);
      wallMesh.dispose();
      
      return resultMesh;
    } catch (error) {
      console.warn('CSG operation failed for wall openings:', error);
      return wallMesh;
    }
  }

  /**
   * Creates a door opening mesh for CSG subtraction
   */
  private createDoorOpening(door: Door, wall: Wall): Mesh {
    const opening = MeshBuilder.CreateBox(`door-opening-${door.id}`, {
      width: door.width,
      height: door.height,
      depth: wall.thickness + 0.1 // Slightly thicker to ensure clean cut
    }, this.scene);

    // Position the opening relative to the wall
    const wallDirection = wall.endPoint.subtract(wall.startPoint).normalize();
    const wallMidpoint = wall.startPoint.add(wall.endPoint).scale(0.5);
    
    // Calculate position along the wall
    const positionAlongWall = wallDirection.scale(door.position.x);
    const openingPosition = wallMidpoint.add(positionAlongWall);
    openingPosition.y = door.height / 2; // Position at floor level
    
    opening.position = openingPosition;

    // Rotate to match wall orientation
    const angle = Math.atan2(wallDirection.x, wallDirection.z);
    opening.rotation.y = angle;

    return opening;
  }

  /**
   * Creates a window opening mesh for CSG subtraction
   */
  private createWindowOpening(window: Window, wall: Wall): Mesh {
    const opening = MeshBuilder.CreateBox(`window-opening-${window.id}`, {
      width: window.width,
      height: window.height,
      depth: wall.thickness + 0.1 // Slightly thicker to ensure clean cut
    }, this.scene);

    // Position the opening relative to the wall
    const wallDirection = wall.endPoint.subtract(wall.startPoint).normalize();
    const wallMidpoint = wall.startPoint.add(wall.endPoint).scale(0.5);
    
    // Calculate position along the wall
    const positionAlongWall = wallDirection.scale(window.position.x);
    const openingPosition = wallMidpoint.add(positionAlongWall);
    openingPosition.y = window.sillHeight + window.height / 2; // Position at sill height
    
    opening.position = openingPosition;

    // Rotate to match wall orientation
    const angle = Math.atan2(wallDirection.x, wallDirection.z);
    opening.rotation.y = angle;

    return opening;
  }

  /**
   * Creates a foundation mesh
   */
  private createFoundation(): Mesh {
    const points: Vector3[] = [];
    this.housingObject.walls.forEach(wall => {
      points.push(wall.startPoint);
      points.push(wall.endPoint);
    });

    if (points.length === 0) {
      return MeshBuilder.CreateBox('foundation', { width: 4, height: 0.5, depth: 4 }, this.scene);
    }

    // Find bounding box
    const minX = Math.min(...points.map(p => p.x));
    const maxX = Math.max(...points.map(p => p.x));
    const minZ = Math.min(...points.map(p => p.z));
    const maxZ = Math.max(...points.map(p => p.z));

    const width = maxX - minX + 0.5; // Add some padding
    const depth = maxZ - minZ + 0.5;

    const foundation = MeshBuilder.CreateBox('foundation', {
      width: width,
      height: this.housingObject.foundationHeight,
      depth: depth
    }, this.scene);

    foundation.position = new Vector3(
      (minX + maxX) / 2,
      -this.housingObject.foundationHeight / 2,
      (minZ + maxZ) / 2
    );

    // Apply material
    const material = new StandardMaterial('foundation-material', this.scene);
    material.diffuseColor = new Color3(0.5, 0.5, 0.5);
    foundation.material = material;

    return foundation;
  }

  /**
   * Adds a door to a wall
   */
  addDoor(wallId: string, door: Omit<Door, 'id' | 'wallId'>): string {
    const wall = this.housingObject.walls.find(w => w.id === wallId);
    if (!wall) {
      throw new Error(`Wall with ID ${wallId} not found`);
    }

    const newDoor: Door = {
      ...door,
      id: `door-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      wallId: wallId
    };

    wall.doors.push(newDoor);
    this.housingObject.doors.push(newDoor);

    return newDoor.id;
  }

  /**
   * Adds a window to a wall
   */
  addWindow(wallId: string, window: Omit<Window, 'id' | 'wallId'>): string {
    const wall = this.housingObject.walls.find(w => w.id === wallId);
    if (!wall) {
      throw new Error(`Wall with ID ${wallId} not found`);
    }

    const newWindow: Window = {
      ...window,
      id: `window-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      wallId: wallId
    };

    wall.windows.push(newWindow);
    this.housingObject.windows.push(newWindow);

    return newWindow.id;
  }

  /**
   * Removes a door from the housing object
   */
  removeDoor(doorId: string): boolean {
    const door = this.housingObject.doors.find(d => d.id === doorId);
    if (!door) return false;

    const wall = this.housingObject.walls.find(w => w.id === door.wallId);
    if (wall) {
      wall.doors = wall.doors.filter(d => d.id !== doorId);
    }

    this.housingObject.doors = this.housingObject.doors.filter(d => d.id !== doorId);
    return true;
  }

  /**
   * Removes a window from the housing object
   */
  removeWindow(windowId: string): boolean {
    const window = this.housingObject.windows.find(w => w.id === windowId);
    if (!window) return false;

    const wall = this.housingObject.walls.find(w => w.id === window.wallId);
    if (wall) {
      wall.windows = wall.windows.filter(w => w.id !== windowId);
    }

    this.housingObject.windows = this.housingObject.windows.filter(w => w.id !== windowId);
    return true;
  }

  /**
   * Changes wall thickness for all walls or a specific wall
   */
  changeWallThickness(thickness: number, wallId?: string): void {
    if (wallId) {
      const wall = this.housingObject.walls.find(w => w.id === wallId);
      if (wall) {
        wall.thickness = thickness;
      }
    } else {
      this.housingObject.walls.forEach(wall => {
        wall.thickness = thickness;
      });
      this.housingObject.wallThickness = thickness;
    }
  }

  /**
   * Toggles ceiling on/off
   */
  toggleCeiling(hasCeiling: boolean): void {
    this.housingObject.hasCeiling = hasCeiling;
  }

  /**
   * Toggles floor on/off
   */
  toggleFloor(hasFloor: boolean): void {
    this.housingObject.hasFloor = hasFloor;
  }
}

/**
 * Creates a basic house structure with walls, roof, and door opening
 */
export const createBasicHouse = (scene: Scene, options: MeshCreationOptions = {}): Mesh => {
  // Define house dimensions - normalized to unit scale
  const width = 2;
  const depth = 1.5;
  const height = 1.5;
  const roofHeight = 0.5;
  const wallThickness = 0.1;
  
  // Create the main house body
  const houseBody = MeshBuilder.CreateBox('house-body', { width, height, depth }, scene);
  houseBody.position = new Vector3(0, height / 2, 0);
  
  // Create door opening
  const doorWidth = 0.4;
  const doorHeight = 0.8;
  const doorOpening = MeshBuilder.CreateBox('door-opening', { 
    width: doorWidth, 
    height: doorHeight, 
    depth: wallThickness * 2 
  }, scene);
  doorOpening.position = new Vector3(0, doorHeight / 2, depth / 2);
  
  // Create house with door opening using CSG
  let houseWithDoor: Mesh;
  try {
    const houseCSG = CSG.FromMesh(houseBody);
    const doorCSG = CSG.FromMesh(doorOpening);
    const resultCSG = houseCSG.subtract(doorCSG);
    houseWithDoor = resultCSG.toMesh('house-with-door', houseBody.material, scene);
  } catch (error) {
    console.warn('CSG operation failed, using simple house body:', error);
    houseWithDoor = houseBody;
  }
  
  // Clean up temporary meshes
  houseBody.dispose();
  doorOpening.dispose();
  
  // Create roof
  const roof = MeshBuilder.CreateCylinder('roof', { 
    diameterTop: 0, 
    diameterBottom: Math.sqrt(width * width + depth * depth) + 0.2, 
    height: roofHeight,
    tessellation: 4
  }, scene);
  roof.position = new Vector3(0, height + roofHeight / 2, 0);
  roof.rotation.y = Math.PI / 4;
  
  // Merge house and roof
  const finalMesh = Mesh.MergeMeshes([houseWithDoor, roof], true, true);
  
     if (finalMesh) {
     finalMesh.name = options.name || 'basic-house';
     // Position at origin for proper gizmo handling
     finalMesh.position = Vector3.Zero();
     
     // Apply default house material if no material exists
     if (!finalMesh.material) {
       const material = new StandardMaterial(`${finalMesh.name}-material`, scene);
       material.diffuseColor = options.color ? Color3.FromHexString(options.color) : new Color3(0.8, 0.7, 0.6);
       finalMesh.material = material;
     }
     
     return finalMesh;
   }
  
  return houseWithDoor;
};

/**
 * Creates a single room structure
 */
export const createRoom = (scene: Scene, options: MeshCreationOptions = {}): Mesh => {
  // Normalized room dimensions
  const width = 2;
  const depth = 2;
  const height = 1.5;
  const wallThickness = 0.1;
  
  // Create outer walls
  const outerWalls = MeshBuilder.CreateBox('outer-walls', { width, height, depth }, scene);
  outerWalls.position = new Vector3(0, height / 2, 0);
  
  // Create inner space to subtract
  const innerSpace = MeshBuilder.CreateBox('inner-space', { 
    width: width - wallThickness * 2, 
    height: height + 0.2, 
    depth: depth - wallThickness * 2 
  }, scene);
  innerSpace.position = new Vector3(0, height / 2, 0);
  
  // Create room walls using CSG
  let roomMesh: Mesh;
  try {
    const outerCSG = CSG.FromMesh(outerWalls);
    const innerCSG = CSG.FromMesh(innerSpace);
    const wallsCSG = outerCSG.subtract(innerCSG);
    roomMesh = wallsCSG.toMesh('room-walls', outerWalls.material, scene);
  } catch (error) {
    console.warn('CSG operation failed for room, using simple box:', error);
    roomMesh = outerWalls;
  }
  
  // Clean up temporary meshes
  outerWalls.dispose();
  innerSpace.dispose();
  
  // Create floor
  const floor = MeshBuilder.CreateBox('floor', { width, height: 0.05, depth }, scene);
  floor.position = new Vector3(0, 0.025, 0);
  
  // Merge walls and floor
  const finalMesh = Mesh.MergeMeshes([roomMesh, floor], true, true);
  
     if (finalMesh) {
     finalMesh.name = options.name || 'room';
     finalMesh.position = Vector3.Zero();
     
     // Apply default room material if no material exists
     if (!finalMesh.material) {
       const material = new StandardMaterial(`${finalMesh.name}-material`, scene);
       material.diffuseColor = options.color ? Color3.FromHexString(options.color) : new Color3(0.9, 0.8, 0.7);
       finalMesh.material = material;
     }
     
     return finalMesh;
   }
  
  return roomMesh;
};

/**
 * Creates a hallway structure
 */
export const createHallway = (scene: Scene, options: MeshCreationOptions = {}): Mesh => {
  // Normalized hallway dimensions
  const width = 1;
  const depth = 3;
  const height = 1.5;
  const wallThickness = 0.1;
  
  // Create hallway walls
  const leftWall = MeshBuilder.CreateBox('left-wall', { width: wallThickness, height, depth }, scene);
  leftWall.position = new Vector3(-width / 2, height / 2, 0);
  
  const rightWall = MeshBuilder.CreateBox('right-wall', { width: wallThickness, height, depth }, scene);
  rightWall.position = new Vector3(width / 2, height / 2, 0);
  
  // Create floor
  const floor = MeshBuilder.CreateBox('floor', { width, height: 0.05, depth }, scene);
  floor.position = new Vector3(0, 0.025, 0);
  
  // Create ceiling
  const ceiling = MeshBuilder.CreateBox('ceiling', { width, height: 0.05, depth }, scene);
  ceiling.position = new Vector3(0, height + 0.025, 0);
  
  // Merge meshes
  const merged = Mesh.MergeMeshes([leftWall, rightWall, floor, ceiling], true, true);
  
     if (merged) {
     merged.name = options.name || 'hallway';
     merged.position = Vector3.Zero();
     
     // Apply default hallway material if no material exists
     if (!merged.material) {
       const material = new StandardMaterial(`${merged.name}-material`, scene);
       material.diffuseColor = options.color ? Color3.FromHexString(options.color) : new Color3(0.8, 0.8, 0.8);
       merged.material = material;
     }
     
     return merged;
   }
  
  return leftWall;
};

/**
 * Creates a flat roof structure
 */
export const createFlatRoof = (scene: Scene, options: MeshCreationOptions = {}): Mesh => {
  // Normalized roof dimensions
  const width = 2;
  const depth = 1.5;
  const thickness = 0.1;
  
     const roof = MeshBuilder.CreateBox(options.name || 'flat-roof', { width, height: thickness, depth }, scene);
   roof.position = new Vector3(0, thickness / 2, 0);
   
   // Apply default roof material
   const material = new StandardMaterial(`${roof.name}-material`, scene);
   material.diffuseColor = options.color ? Color3.FromHexString(options.color) : new Color3(0.6, 0.4, 0.2);
   roof.material = material;
   
   return roof;
};

/**
 * Creates a pitched roof structure
 */
export const createPitchedRoof = (scene: Scene, options: MeshCreationOptions = {}): Mesh => {
  // Normalized roof dimensions
  const width = 2;
  const depth = 1.5;
  const height = 0.8;
  
  // Create a triangular prism using a cylinder with 3 tessellation
  const roof = MeshBuilder.CreateCylinder(options.name || 'pitched-roof', {
    diameterTop: 0,
    diameterBottom: Math.sqrt(width * width + depth * depth),
    height: height,
    tessellation: 4
  }, scene);
  
     roof.position = new Vector3(0, height / 2, 0);
   roof.rotation.y = Math.PI / 4;
   
   // Apply default roof material
   const material = new StandardMaterial(`${roof.name}-material`, scene);
   material.diffuseColor = options.color ? Color3.FromHexString(options.color) : new Color3(0.6, 0.4, 0.2);
   roof.material = material;
   
   return roof;
};

/**
 * Creates a foundation/basement for a building
 */
export const createFoundation = (
  scene: Scene, 
  walls: Wall[], 
  height: number = 0.5, 
  thickness: number = 0.3,
  color: string = '#654321'
): Mesh => {
  // Calculate foundation bounds from walls
  const points: Vector3[] = [];
  walls.forEach(wall => {
    points.push(wall.startPoint);
    points.push(wall.endPoint);
  });

  if (points.length === 0) {
    // Fallback: create a simple rectangular foundation
    const foundation = MeshBuilder.CreateBox('foundation', {
      width: 4,
      height: height,
      depth: 4
    }, scene);
    foundation.position.y = -height / 2;
    return foundation;
  }

  // Find bounding box
  const minX = Math.min(...points.map(p => p.x));
  const maxX = Math.max(...points.map(p => p.x));
  const minZ = Math.min(...points.map(p => p.z));
  const maxZ = Math.max(...points.map(p => p.z));

  // Add some padding around the foundation
  const padding = thickness;
  const width = maxX - minX + padding * 2;
  const depth = maxZ - minZ + padding * 2;

  const foundation = MeshBuilder.CreateBox('foundation', {
    width: width,
    height: height,
    depth: depth
  }, scene);

  foundation.position = new Vector3(
    (minX + maxX) / 2,
    -height / 2,
    (minZ + maxZ) / 2
  );

  // Apply material
  const material = new StandardMaterial('foundation-material', scene);
  material.diffuseColor = Color3.FromHexString(color);
  foundation.material = material;

  return foundation;
};

/**
 * Creates a stairs component for multi-level buildings
 */
export const createStairs = (
  scene: Scene,
  options: {
    stepCount?: number;
    stepWidth?: number;
    stepHeight?: number;
    stepDepth?: number;
    totalHeight?: number;
    color?: string;
    handrail?: boolean;
  } = {}
): Mesh => {
  const stepCount = options.stepCount || 10;
  const stepWidth = options.stepWidth || 1.0;
  const stepHeight = options.stepHeight || 0.18;
  const stepDepth = options.stepDepth || 0.25;
  const totalHeight = options.totalHeight || stepCount * stepHeight;
  const color = options.color || '#8B4513';
  const hasHandrail = options.handrail !== false;

  const meshes: Mesh[] = [];

  // Create individual steps
  for (let i = 0; i < stepCount; i++) {
    const step = MeshBuilder.CreateBox(`step-${i}`, {
      width: stepWidth,
      height: stepHeight,
      depth: stepDepth
    }, scene);

    step.position = new Vector3(
      0,
      i * stepHeight + stepHeight / 2,
      i * stepDepth
    );

    meshes.push(step);
  }

  // Create handrail if requested
  if (hasHandrail) {
    const handrailHeight = 0.9;
    const handrailThickness = 0.05;
    
    // Left handrail
    const leftHandrail = MeshBuilder.CreateBox('left-handrail', {
      width: handrailThickness,
      height: handrailHeight,
      depth: stepCount * stepDepth
    }, scene);
    leftHandrail.position = new Vector3(
      -stepWidth / 2 + handrailThickness / 2,
      totalHeight / 2 + handrailHeight / 2,
      (stepCount - 1) * stepDepth / 2
    );
    meshes.push(leftHandrail);

    // Right handrail
    const rightHandrail = MeshBuilder.CreateBox('right-handrail', {
      width: handrailThickness,
      height: handrailHeight,
      depth: stepCount * stepDepth
    }, scene);
    rightHandrail.position = new Vector3(
      stepWidth / 2 - handrailThickness / 2,
      totalHeight / 2 + handrailHeight / 2,
      (stepCount - 1) * stepDepth / 2
    );
    meshes.push(rightHandrail);
  }

  // Merge all meshes
  const stairsMesh = Mesh.MergeMeshes(meshes, true, true);
  
  if (stairsMesh) {
    stairsMesh.name = 'stairs';
    
    // Apply material
    const material = new StandardMaterial('stairs-material', scene);
    material.diffuseColor = Color3.FromHexString(color);
    stairsMesh.material = material;
  }

  return stairsMesh || meshes[0];
};

/**
 * Creates a real-time preview mesh for wall thickness changes
 */
export const createWallThicknessPreview = (
  scene: Scene,
  originalWall: Wall,
  newThickness: number,
  color: string = '#3498db'
): Mesh => {
  const previewWall = { ...originalWall, thickness: newThickness };
  const previewMesh = createWall(scene, previewWall);
  
  // Apply preview material
  const material = new StandardMaterial('wall-preview-material', scene);
  material.diffuseColor = Color3.FromHexString(color);
  material.alpha = 0.5;
  material.wireframe = true;
  previewMesh.material = material;
  
  return previewMesh;
};

/**
 * Creates a real-time preview mesh for door/window positioning
 */
export const createDoorWindowPreview = (
  scene: Scene,
  wall: Wall,
  door: Door | null,
  window: Window | null,
  newPosition: Vector3,
  color: string = '#e74c3c'
): Mesh => {
  let previewMesh: Mesh;
  
  if (door) {
    const previewDoor = { ...door, position: newPosition };
    previewMesh = createDoor(scene, previewDoor);
  } else if (window) {
    const previewWindow = { ...window, position: newPosition };
    previewMesh = createWindow(scene, previewWindow);
  } else {
    throw new Error('Either door or window must be provided');
  }
  
  // Apply preview material
  const material = new StandardMaterial('door-window-preview-material', scene);
  material.diffuseColor = Color3.FromHexString(color);
  material.alpha = 0.7;
  material.wireframe = true;
  previewMesh.material = material;
  
  return previewMesh;
};

/**
 * Creates a multi-story building with floor-to-floor connections
 */
export const createMultiStoryBuilding = (
  scene: Scene,
  floors: ModularHousingObject[],
  stairwells: { fromFloor: number; toFloor: number; position: Vector3 }[] = []
): Mesh => {
  const meshes: Mesh[] = [];
  
  floors.forEach((floor, index) => {
    const floorMesh = createModularHousingMesh(floor, scene);
    
    // Position floor at appropriate height
    const floorHeight = index * (floor.ceilingHeight + floor.floorThickness);
    floorMesh.position.y = floorHeight;
    
    meshes.push(floorMesh);
  });
  
  // Create stairwells
  stairwells.forEach((stairwell, index) => {
    const fromFloor = floors[stairwell.fromFloor];
    const toFloor = floors[stairwell.toFloor];
    
    if (fromFloor && toFloor) {
      const stairHeight = toFloor.ceilingHeight + toFloor.floorThickness;
      const stairs = createStairs(scene, {
        totalHeight: stairHeight,
        color: '#8B4513'
      });
      
      stairs.position = stairwell.position.clone();
      stairs.position.y = stairwell.fromFloor * stairHeight;
      
      meshes.push(stairs);
    }
  });
  
  // Merge all meshes
  const buildingMesh = Mesh.MergeMeshes(meshes, true, true);
  
  if (buildingMesh) {
    buildingMesh.name = 'multi-story-building';
  }
  
  return buildingMesh || meshes[0];
};

/**
 * Enhanced CSG operations with better error handling and optimization
 */
export const performEnhancedCSG = (
  baseMesh: Mesh,
  subtractMeshes: Mesh[],
  unionMeshes: Mesh[] = [],
  intersectMeshes: Mesh[] = []
): Mesh => {
  try {
    let resultCSG = CSG.FromMesh(baseMesh);
    
    // Subtract meshes
    subtractMeshes.forEach(mesh => {
      try {
        const subtractCSG = CSG.FromMesh(mesh);
        resultCSG = resultCSG.subtract(subtractCSG);
      } catch (error) {
        console.warn('Failed to subtract mesh:', mesh.name, error);
      }
    });
    
    // Union meshes
    unionMeshes.forEach(mesh => {
      try {
        const unionCSG = CSG.FromMesh(mesh);
        resultCSG = resultCSG.union(unionCSG);
      } catch (error) {
        console.warn('Failed to union mesh:', mesh.name, error);
      }
    });
    
    // Intersect meshes
    intersectMeshes.forEach(mesh => {
      try {
        const intersectCSG = CSG.FromMesh(mesh);
        resultCSG = resultCSG.intersect(intersectCSG);
      } catch (error) {
        console.warn('Failed to intersect mesh:', mesh.name, error);
      }
    });
    
    const resultMesh = resultCSG.toMesh(
      `${baseMesh.name}-enhanced-csg`,
      baseMesh.material,
      baseMesh.getScene()
    );
    
    return resultMesh;
    
  } catch (error) {
    console.error('Enhanced CSG operation failed:', error);
    return baseMesh;
  }
};

/**
 * Creates drag-and-drop positioning helpers
 */
export const createPositionGuides = (
  scene: Scene,
  wall: Wall,
  componentWidth: number,
  color: string = '#f39c12'
): { guides: Mesh[], positions: Vector3[] } => {
  const guides: Mesh[] = [];
  const positions: Vector3[] = [];
  
  const wallLength = wall.startPoint.subtract(wall.endPoint).length();
  const wallDirection = wall.endPoint.subtract(wall.startPoint).normalize();
  const wallMidpoint = wall.startPoint.add(wall.endPoint).scale(0.5);
  
  // Create position guides along the wall
  const guideCount = Math.floor(wallLength / componentWidth) + 1;
  
  for (let i = 0; i < guideCount; i++) {
    const t = i / (guideCount - 1);
    const position = wall.startPoint.add(wallDirection.scale(t * wallLength));
    positions.push(position);
    
    // Create visual guide
    const guide = MeshBuilder.CreateSphere(`position-guide-${i}`, {
      diameter: 0.1
    }, scene);
    
    guide.position = position;
    guide.position.y = 1.0; // Position at door/window height
    
    const material = new StandardMaterial(`guide-material-${i}`, scene);
    material.diffuseColor = Color3.FromHexString(color);
    material.emissiveColor = Color3.FromHexString(color);
    guide.material = material;
    
    guides.push(guide);
  }
  
  return { guides, positions };
};

/**
 * Auto-adjusts connected structures when wall properties change
 */
export const autoAdjustConnectedStructures = (
  scene: Scene,
  modifiedWall: Wall,
  connectedWalls: Wall[],
  housingComponents: ModularHousingObject[]
): void => {
  // Update heights of connected walls
  connectedWalls.forEach(wall => {
    if (wall.id !== modifiedWall.id) {
      wall.height = modifiedWall.height;
    }
  });
  
  // Update connected housing components
  housingComponents.forEach(component => {
    component.walls.forEach(wall => {
      if (modifiedWall.connectedWalls.includes(wall.id)) {
        wall.height = modifiedWall.height;
      }
    });
    
    // Adjust ceiling height if needed
    if (component.hasCeiling) {
      component.ceilingHeight = modifiedWall.height;
    }
  });
};

/**
 * Creates a simple rectangular room for backward compatibility
 */
export const createSimpleRoom = (
  scene: Scene, 
  options: MeshCreationOptions & { 
    width?: number, 
    height?: number, 
    depth?: number, 
    wallThickness?: number,
    hasCeiling?: boolean,
    hasFloor?: boolean,
    roomType?: string
  } = {}
): ModularHousingObject => {
  const width = options.width || 4;
  const height = options.height || 3;
  const depth = options.depth || 4;
  const wallThickness = options.wallThickness || 0.2;
  const hasCeiling = options.hasCeiling !== false;
  const hasFloor = options.hasFloor !== false;
  
  // Create walls for a rectangular room
  const walls: Wall[] = [
    {
      id: 'wall-north',
      type: 'exterior',
      startPoint: new Vector3(-width/2, 0, depth/2),
      endPoint: new Vector3(width/2, 0, depth/2),
      height: height,
      thickness: wallThickness,
      color: options.color || '#DEB887',
      doors: [],
      windows: [],
      isLoadBearing: true,
      connectedWalls: ['wall-east', 'wall-west']
    },
    {
      id: 'wall-south',
      type: 'exterior',
      startPoint: new Vector3(width/2, 0, -depth/2),
      endPoint: new Vector3(-width/2, 0, -depth/2),
      height: height,
      thickness: wallThickness,
      color: options.color || '#DEB887',
      doors: [],
      windows: [],
      isLoadBearing: true,
      connectedWalls: ['wall-east', 'wall-west']
    },
    {
      id: 'wall-east',
      type: 'exterior',
      startPoint: new Vector3(width/2, 0, depth/2),
      endPoint: new Vector3(width/2, 0, -depth/2),
      height: height,
      thickness: wallThickness,
      color: options.color || '#DEB887',
      doors: [],
      windows: [],
      isLoadBearing: true,
      connectedWalls: ['wall-north', 'wall-south']
    },
    {
      id: 'wall-west',
      type: 'exterior',
      startPoint: new Vector3(-width/2, 0, -depth/2),
      endPoint: new Vector3(-width/2, 0, depth/2),
      height: height,
      thickness: wallThickness,
      color: options.color || '#DEB887',
      doors: [],
      windows: [],
      isLoadBearing: true,
      connectedWalls: ['wall-north', 'wall-south']
    }
  ];

  // Add a default door to the south wall
  const defaultDoor: Door = {
    id: 'door-main',
    type: 'single',
    width: 0.8,
    height: 2.0,
    thickness: 0.05,
    position: new Vector3(0, 0, 0), // Center of the wall
    wallId: 'wall-south',
    isOpen: false,
    openDirection: 'inward',
    hingeDirection: 'right',
    color: '#8B4513'
  };

  walls[1].doors.push(defaultDoor); // Add to south wall

  const housingObject: ModularHousingObject = {
    id: options.name || `modular-room-${Date.now()}`,
    type: 'modular-room',
    position: new Vector3(0, 0, 0),
    scale: new Vector3(1, 1, 1),
    rotation: new Vector3(0, 0, 0),
    color: options.color || '#DEB887',
    isNurbs: false,
    housingType: 'modular-room',
    wallThickness: wallThickness,
    hasCeiling: hasCeiling,
    hasFloor: hasFloor,
    hasFoundation: false,
    walls: walls,
    doors: [defaultDoor],
    windows: [],
    ceilingHeight: height,
    floorThickness: 0.1,
    foundationHeight: 0.5,
    buildingConnections: [],
    roomType: options.roomType as any || 'living-room'
  };

  return housingObject;
};

/**
 * Creates a modular housing mesh using the ModularHousingBuilder
 */
export const createModularHousingMesh = (
  housingObject: ModularHousingObject,
  scene: Scene
): Mesh => {
  const builder = new ModularHousingBuilder(scene, housingObject);
  return builder.build();
};

/**
 * Creates a standalone wall component
 */
export const createStandaloneWall = (scene: Scene, options: MeshCreationOptions = {}): Mesh => {
  const wall: Wall = {
    id: options.name || 'standalone-wall',
    type: 'exterior',
    startPoint: new Vector3(-2, 0, 0),
    endPoint: new Vector3(2, 0, 0),
    height: 2.5,
    thickness: 0.2,
    color: options.color || '#8B4513',
    doors: [],
    windows: [],
    isLoadBearing: false,
    connectedWalls: []
  };
  
  return createWall(scene, wall, options);
};

/**
 * Creates a standalone ceiling component
 */
export const createStandaloneCeiling = (scene: Scene, options: MeshCreationOptions = {}): Mesh => {
  const walls: Wall[] = [
    {
      id: 'temp-wall-1',
      type: 'exterior',
      startPoint: new Vector3(-2, 0, -2),
      endPoint: new Vector3(2, 0, -2),
      height: 2.5,
      thickness: 0.2,
      color: '#8B4513',
      doors: [],
      windows: [],
      isLoadBearing: false,
      connectedWalls: []
    },
    {
      id: 'temp-wall-2',
      type: 'exterior',
      startPoint: new Vector3(2, 0, -2),
      endPoint: new Vector3(2, 0, 2),
      height: 2.5,
      thickness: 0.2,
      color: '#8B4513',
      doors: [],
      windows: [],
      isLoadBearing: false,
      connectedWalls: []
    },
    {
      id: 'temp-wall-3',
      type: 'exterior',
      startPoint: new Vector3(2, 0, 2),
      endPoint: new Vector3(-2, 0, 2),
      height: 2.5,
      thickness: 0.2,
      color: '#8B4513',
      doors: [],
      windows: [],
      isLoadBearing: false,
      connectedWalls: []
    },
    {
      id: 'temp-wall-4',
      type: 'exterior',
      startPoint: new Vector3(-2, 0, 2),
      endPoint: new Vector3(-2, 0, -2),
      height: 2.5,
      thickness: 0.2,
      color: '#8B4513',
      doors: [],
      windows: [],
      isLoadBearing: false,
      connectedWalls: []
    }
  ];
  
  return createCeiling(scene, walls, 2.5, 0.1, options.color || '#F5F5DC');
};

/**
 * Creates a standalone floor component
 */
export const createStandaloneFloor = (scene: Scene, options: MeshCreationOptions = {}): Mesh => {
  const walls: Wall[] = [
    {
      id: 'temp-wall-1',
      type: 'exterior',
      startPoint: new Vector3(-2, 0, -2),
      endPoint: new Vector3(2, 0, -2),
      height: 2.5,
      thickness: 0.2,
      color: '#8B4513',
      doors: [],
      windows: [],
      isLoadBearing: false,
      connectedWalls: []
    },
    {
      id: 'temp-wall-2',
      type: 'exterior',
      startPoint: new Vector3(2, 0, -2),
      endPoint: new Vector3(2, 0, 2),
      height: 2.5,
      thickness: 0.2,
      color: '#8B4513',
      doors: [],
      windows: [],
      isLoadBearing: false,
      connectedWalls: []
    },
    {
      id: 'temp-wall-3',
      type: 'exterior',
      startPoint: new Vector3(2, 0, 2),
      endPoint: new Vector3(-2, 0, 2),
      height: 2.5,
      thickness: 0.2,
      color: '#8B4513',
      doors: [],
      windows: [],
      isLoadBearing: false,
      connectedWalls: []
    },
    {
      id: 'temp-wall-4',
      type: 'exterior',
      startPoint: new Vector3(-2, 0, 2),
      endPoint: new Vector3(-2, 0, -2),
      height: 2.5,
      thickness: 0.2,
      color: '#8B4513',
      doors: [],
      windows: [],
      isLoadBearing: false,
      connectedWalls: []
    }
  ];
  
  return createFloor(scene, walls, 0.1, options.color || '#8B4513');
};

/**
 * Creates a standalone door component
 */
export const createStandaloneDoor = (scene: Scene, doorType: DoorType, options: MeshCreationOptions = {}): Mesh => {
  const doorWidths: { [key in DoorType]: number } = {
    'single': 0.9,
    'double': 1.8,
    'sliding': 1.2,
    'french': 1.2,
    'garage': 2.4
  };
  
  const door: Door = {
    id: options.name || `standalone-door-${doorType}`,
    type: doorType,
    width: doorWidths[doorType],
    height: 2.0,
    thickness: 0.05,
    position: new Vector3(0, 0, 0),
    wallId: 'standalone',
    isOpen: false,
    openDirection: 'inward',
    hingeDirection: 'right',
    color: options.color || '#654321'
  };
  
  return createDoor(scene, door, options);
};

/**
 * Creates a standalone window component
 */
export const createStandaloneWindow = (scene: Scene, windowType: WindowType, options: MeshCreationOptions = {}): Mesh => {
  const windowDimensions: { [key in WindowType]: { width: number; height: number; depth: number } } = {
    'single': { width: 0.6, height: 0.8, depth: 0.05 },
    'double': { width: 1.2, height: 0.8, depth: 0.05 },
    'bay': { width: 1.5, height: 0.8, depth: 0.3 },
    'casement': { width: 0.8, height: 1.0, depth: 0.05 },
    'sliding': { width: 1.2, height: 0.8, depth: 0.05 },
    'skylight': { width: 0.8, height: 0.8, depth: 0.05 }
  };
  
  const dims = windowDimensions[windowType];
  const window: Window = {
    id: options.name || `standalone-window-${windowType}`,
    type: windowType,
    width: dims.width,
    height: dims.height,
    position: new Vector3(0, 0, 0),
    wallId: 'standalone',
    sillHeight: 0.8,
    hasFrame: true,
    frameThickness: 0.05,
    color: options.color || '#87CEEB'
  };
  
  return createWindow(scene, window, options);
};

/**
 * Creates a standalone stairs component
 */
export const createStandaloneStairs = (scene: Scene, options: MeshCreationOptions = {}): Mesh => {
  return createStairs(scene, {
    stepCount: 10,
    stepWidth: 1.0,
    stepHeight: 0.18,
    stepDepth: 0.25,
    color: options.color || '#8B4513',
    handrail: true
  });
};

/**
 * Creates a standalone foundation component
 */
export const createStandaloneFoundation = (scene: Scene, options: MeshCreationOptions = {}): Mesh => {
  const walls: Wall[] = [
    {
      id: 'foundation-wall-1',
      type: 'exterior',
      startPoint: new Vector3(-2, 0, -2),
      endPoint: new Vector3(2, 0, -2),
      height: 0.5,
      thickness: 0.3,
      color: '#654321',
      doors: [],
      windows: [],
      isLoadBearing: true,
      connectedWalls: []
    },
    {
      id: 'foundation-wall-2',
      type: 'exterior',
      startPoint: new Vector3(2, 0, -2),
      endPoint: new Vector3(2, 0, 2),
      height: 0.5,
      thickness: 0.3,
      color: '#654321',
      doors: [],
      windows: [],
      isLoadBearing: true,
      connectedWalls: []
    },
    {
      id: 'foundation-wall-3',
      type: 'exterior',
      startPoint: new Vector3(2, 0, 2),
      endPoint: new Vector3(-2, 0, 2),
      height: 0.5,
      thickness: 0.3,
      color: '#654321',
      doors: [],
      windows: [],
      isLoadBearing: true,
      connectedWalls: []
    },
    {
      id: 'foundation-wall-4',
      type: 'exterior',
      startPoint: new Vector3(-2, 0, 2),
      endPoint: new Vector3(-2, 0, -2),
      height: 0.5,
      thickness: 0.3,
      color: '#654321',
      doors: [],
      windows: [],
      isLoadBearing: true,
      connectedWalls: []
    }
  ];
  
  return createFoundation(scene, walls, 0.5, 0.3, options.color || '#654321');
};

/**
 * Enhanced factory function with new Sprint 2 components
 */
export const createHousingMesh = (
  type: string, 
  scene: Scene, 
  options: MeshCreationOptions = {}
): Mesh => {
  switch (type) {
    case 'house-basic':
      return createBasicHouse(scene, options);
    case 'house-room':
      return createRoom(scene, options);
    case 'house-hallway':
      return createHallway(scene, options);
    case 'house-roof-flat':
      return createFlatRoof(scene, options);
    case 'house-roof-pitched':
      return createPitchedRoof(scene, options);
    case 'house-room-modular':
    case 'modular-room':
      // Create a simple modular room for backward compatibility
      const simpleRoom = createSimpleRoom(scene, options);
      return createModularHousingMesh(simpleRoom, scene);
    
    // Individual wall component
    case 'house-wall':
      return createStandaloneWall(scene, options);
    
    // Individual ceiling component
    case 'house-ceiling':
      return createStandaloneCeiling(scene, options);
    
    // Individual floor component
    case 'house-floor':
      return createStandaloneFloor(scene, options);
    
    // Door types
    case 'house-door-single':
      return createStandaloneDoor(scene, 'single', options);
    case 'house-door-double':
      return createStandaloneDoor(scene, 'double', options);
    case 'house-door-sliding':
      return createStandaloneDoor(scene, 'sliding', options);
    case 'house-door-french':
      return createStandaloneDoor(scene, 'french', options);
    case 'house-door-garage':
      return createStandaloneDoor(scene, 'garage', options);
    
    // Window types
    case 'house-window-single':
      return createStandaloneWindow(scene, 'single', options);
    case 'house-window-double':
      return createStandaloneWindow(scene, 'double', options);
    case 'house-window-bay':
      return createStandaloneWindow(scene, 'bay', options);
    case 'house-window-casement':
      return createStandaloneWindow(scene, 'casement', options);
    case 'house-window-sliding':
      return createStandaloneWindow(scene, 'sliding', options);
    case 'house-window-skylight':
      return createStandaloneWindow(scene, 'skylight', options);
    
    // Sprint 2 new components
    case 'house-stairs':
      return createStandaloneStairs(scene, options);
    case 'house-foundation':
      return createStandaloneFoundation(scene, options);
    
    default:
      throw new Error(`Unknown housing type: ${type}`);
  }
};
</file>

<file path="src/main.tsx">
import 'babylonjs-loaders' // Import loaders for GLB/GLTF support - must be first!
import earcut from 'earcut'
// BabylonJS PolygonMeshBuilder expects a global earcut; assign it here
;(window as any).earcut = earcut
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path="src/babylon/gizmoManager.ts">
import React from 'react'
import { 
  GizmoManager, 
  Scene, 
  Mesh, 
  Vector3, 
  Matrix,
  Quaternion
} from 'babylonjs'
import { useSceneStore } from '../state/sceneStore'
import { SceneManager } from './sceneManager'
import type { TransformMode, MultiSelectInitialState } from '../types/types'

export class GizmoController {
  private gizmoManager: GizmoManager | null = null
  private scene: Scene | null = null
  private sceneManager: SceneManager | null = null
  private gizmoObservers: { observable: any, observer: any }[] = []
  private currentTargetMesh: Mesh | null = null
  private onDragEndCallback?: (position: Vector3, rotation: Vector3, scale: Vector3) => void
  private originalTransform: { position: Vector3, rotation: Vector3, scale: Vector3 } | null = null

  constructor(scene: Scene, sceneManager: SceneManager) {
    this.scene = scene
    this.sceneManager = sceneManager
    this.initializeGizmoManager()
  }

  private initializeGizmoManager(): void {
    if (!this.scene) return
    
    this.gizmoManager = new GizmoManager(this.scene)
    this.gizmoManager.positionGizmoEnabled = false
    this.gizmoManager.rotationGizmoEnabled = false
    this.gizmoManager.scaleGizmoEnabled = false
    this.gizmoManager.boundingBoxGizmoEnabled = false
    this.gizmoManager.usePointerToAttachGizmos = false
    
    console.log('üéØ GizmoController initialized')
  }

  public updateGizmos(
    transformMode: TransformMode,
    targetMesh: Mesh | null,
    onDragEnd: (position: Vector3, rotation: Vector3, scale: Vector3) => void
  ): void {
    if (!this.gizmoManager) return

    console.log('üîß Updating gizmos:', { transformMode, targetMesh: targetMesh?.name })
    
    // Clean up existing observers
    this.cleanupGizmoObservers()
    
    // Update callback
    this.onDragEndCallback = onDragEnd
    
    // Disable all gizmos first
    this.gizmoManager.positionGizmoEnabled = false
    this.gizmoManager.rotationGizmoEnabled = false
    this.gizmoManager.scaleGizmoEnabled = false
    this.gizmoManager.boundingBoxGizmoEnabled = false
    
    // Attach to target mesh or detach
    if (targetMesh) {
      this.gizmoManager.attachToMesh(targetMesh)
      this.currentTargetMesh = targetMesh
      
      // Enable appropriate gizmo based on transform mode
      switch (transformMode) {
        case 'move':
          this.gizmoManager.positionGizmoEnabled = true
          break
        case 'rotate':
          this.gizmoManager.rotationGizmoEnabled = true
          break
        case 'scale':
          this.gizmoManager.scaleGizmoEnabled = true
          break
        case 'select':
          this.gizmoManager.boundingBoxGizmoEnabled = true
          break
      }
      
      // Set up observers for the active gizmo, including bounding-box gizmo when in "select" mode
      this.setupGizmoObservers()
    } else {
      this.gizmoManager.attachToMesh(null)
      this.currentTargetMesh = null
    }
  }

  private setupGizmoObservers(): void {
    if (!this.gizmoManager || !this.onDragEndCallback) return

    const onDragEnd = this.onDragEndCallback
    const { positionGizmo, rotationGizmo, scaleGizmo } = this.gizmoManager.gizmos
    const boundingBoxGizmo = (this.gizmoManager as any).boundingBoxGizmo

    // Position gizmo observer with collision detection
    if (positionGizmo) {
      // Store initial position when drag starts
      const dragStartObservable = positionGizmo.onDragStartObservable
      const dragStartObserver = dragStartObservable.add(() => {
        const attachedMesh = this.gizmoManager?.attachedMesh
        if (attachedMesh) {
          this.originalTransform = {
            position: attachedMesh.position.clone(),
            rotation: attachedMesh.rotation.clone(),
            scale: attachedMesh.scaling.clone()
          }
        }
      })
      this.gizmoObservers.push({ observable: dragStartObservable, observer: dragStartObserver })

      // Check collision during drag
      const dragObservable = positionGizmo.onDragObservable
      const dragObserver = dragObservable.add(() => {
        const attachedMesh = this.gizmoManager?.attachedMesh
        if (attachedMesh && this.sceneManager && this.originalTransform) {
          const meshId = attachedMesh.name || attachedMesh.id
          if (this.sceneManager.checkCollisionAtPosition(meshId, attachedMesh.position)) {
            // Revert to original position if collision detected
            attachedMesh.position.copyFrom(this.originalTransform.position)
            console.log(`üö´ Movement blocked due to collision for ${meshId}`)
          }
        }
      })
      this.gizmoObservers.push({ observable: dragObservable, observer: dragObserver })

      const observable = positionGizmo.onDragEndObservable
      const observer = observable.add(() => {
        const attachedMesh = this.gizmoManager?.attachedMesh
        if (attachedMesh) {
          onDragEnd(attachedMesh.position, attachedMesh.rotation, attachedMesh.scaling)
        }
      })
      this.gizmoObservers.push({ observable, observer })
    }

    // Rotation gizmo observer (less collision checking needed for rotation)
    if (rotationGizmo) {
      const observable = rotationGizmo.onDragEndObservable
      const observer = observable.add(() => {
        const attachedMesh = this.gizmoManager?.attachedMesh
        if (attachedMesh) {
          onDragEnd(attachedMesh.position, attachedMesh.rotation, attachedMesh.scaling)
        }
      })
      this.gizmoObservers.push({ observable, observer })
    }

    // Scale gizmo observer with collision detection
    if (scaleGizmo) {
      // Store initial scale when drag starts
      const dragStartObservable = scaleGizmo.onDragStartObservable
      const dragStartObserver = dragStartObservable.add(() => {
        const attachedMesh = this.gizmoManager?.attachedMesh
        if (attachedMesh) {
          this.originalTransform = {
            position: attachedMesh.position.clone(),
            rotation: attachedMesh.rotation.clone(),
            scale: attachedMesh.scaling.clone()
          }
        }
      })
      this.gizmoObservers.push({ observable: dragStartObservable, observer: dragStartObserver })

      // Check collision during scale
      const dragObservable = scaleGizmo.onDragObservable
      const dragObserver = dragObservable.add(() => {
        const attachedMesh = this.gizmoManager?.attachedMesh
        if (attachedMesh && this.sceneManager && this.originalTransform) {
          const meshId = attachedMesh.name || attachedMesh.id
          if (this.sceneManager.checkCollisionAtTransform(meshId, attachedMesh.position, attachedMesh.rotation, attachedMesh.scaling)) {
            // Revert to original scale if collision detected
            attachedMesh.scaling.copyFrom(this.originalTransform.scale)
            console.log(`üö´ Scaling blocked due to collision for ${meshId}`)
          }
        }
      })
      this.gizmoObservers.push({ observable: dragObservable, observer: dragObserver })

      const observable = scaleGizmo.onDragEndObservable
      const observer = observable.add(() => {
        const attachedMesh = this.gizmoManager?.attachedMesh
        if (attachedMesh) {
          onDragEnd(attachedMesh.position, attachedMesh.rotation, attachedMesh.scaling)
        }
      })
      this.gizmoObservers.push({ observable, observer })
    }

    // Bounding box gizmo has multiple interactions that can end a drag
    if (boundingBoxGizmo) {
      const handleBoundingBoxDragEnd = () => {
        const attachedMesh = this.gizmoManager?.attachedMesh
        if (attachedMesh) {
          // BoundingBoxGizmo manipulates the matrix directly. To get the final
          // transform, we must decompose the world matrix.
          const newScale = new Vector3()
          const newRotation = new Quaternion()
          const newPosition = new Vector3()
          
          attachedMesh.computeWorldMatrix(true)
          if (attachedMesh.getWorldMatrix().decompose(newScale, newRotation, newPosition)) {
            onDragEnd(newPosition, newRotation.toEulerAngles(), newScale)
          }
        }
      }

      const dragObs = boundingBoxGizmo.onDragEndObservable.add(handleBoundingBoxDragEnd)
      this.gizmoObservers.push({ observable: boundingBoxGizmo.onDragEndObservable, observer: dragObs })

      const rotObs = boundingBoxGizmo.onRotationSphereDragEndObservable.add(handleBoundingBoxDragEnd)
      this.gizmoObservers.push({ observable: boundingBoxGizmo.onRotationSphereDragEndObservable, observer: rotObs })
      
      const scaleObs = boundingBoxGizmo.onScaleBoxDragEndObservable.add(handleBoundingBoxDragEnd)
      this.gizmoObservers.push({ observable: boundingBoxGizmo.onScaleBoxDragEndObservable, observer: scaleObs })
    }
  }

  private cleanupGizmoObservers(): void {
    this.gizmoObservers.forEach(({ observable, observer }) => {
      try {
        observable.remove(observer)
      } catch (error) {
        console.warn('Error removing gizmo observer:', error)
      }
    })
    this.gizmoObservers = []
  }

  public dispose(): void {
    this.cleanupGizmoObservers()
    if (this.gizmoManager) {
      this.gizmoManager.dispose()
      this.gizmoManager = null
    }
    this.currentTargetMesh = null
    this.onDragEndCallback = undefined
  }
}

/**
 * Hook to manage gizmos for object transformation
 * Observes the store for changes in selection and transform mode
 */
export const useGizmoManager = (
  scene: Scene | null,
  getMeshById: (id: string) => Mesh | null,
  multiSelectPivot: Mesh | null,
  snapToGrid: boolean,
  snapToObjects: boolean,
  gridSize: number,
  sceneManager: SceneManager | null
) => {
  const store = useSceneStore()
  const {
    selectedObjectId,
    selectedObjectIds,
    transformMode,
    multiSelectInitialStates,
    updateObject
  } = store

  const gizmoControllerRef = React.useRef<GizmoController | null>(null)

  // Initialize gizmo controller when scene is ready
  React.useEffect(() => {
    if (!scene || !sceneManager) return

    console.log('üéØ Initializing GizmoController')
    gizmoControllerRef.current = new GizmoController(scene, sceneManager)

    return () => {
      if (gizmoControllerRef.current) {
        gizmoControllerRef.current.dispose()
        gizmoControllerRef.current = null
      }
    }
  }, [scene, sceneManager])

  // Update gizmos when selection or transform mode changes
  React.useEffect(() => {
    console.log('üéØ [GizmoManager] useEffect triggered with:', {
      selectedObjectId,
      selectedObjectIds,
      transformMode,
      hasController: !!gizmoControllerRef.current,
      hasScene: !!scene
    })
    
    if (!gizmoControllerRef.current || !scene) return

    const isMultiSelect = selectedObjectIds.length > 0
    let targetMesh: Mesh | null = null

    // Choose which mesh to attach gizmo to
    if (isMultiSelect && multiSelectPivot) {
      targetMesh = multiSelectPivot
      console.log('üéØ [GizmoManager] Using multiSelectPivot as target')
    } else if (selectedObjectId) {
      console.log('üéØ [GizmoManager] Calling getMeshById with:', selectedObjectId)
      targetMesh = getMeshById(selectedObjectId)
      console.log('üéØ [GizmoManager] getMeshById returned:', targetMesh?.name || 'null')
    } else {
      console.log('üéØ [GizmoManager] No selection, targetMesh will be null')
    }

    // Handle gizmo drag end
    const handleGizmoDragEnd = (position: Vector3, rotation: Vector3, scale: Vector3) => {
      if (isMultiSelect && multiSelectPivot) {
        // Apply transform to all selected objects with collision checking
        selectedObjectIds.forEach(id => {
          const initialState = multiSelectInitialStates[id]
          if (!initialState) return

          let newPosition = initialState.relativePosition.clone().multiply(scale)
          const rotationMatrix = new Matrix()
          Matrix.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, rotationMatrix)
          newPosition = Vector3.TransformCoordinates(newPosition, rotationMatrix).add(position)
          
          if (snapToGrid) {
            newPosition = new Vector3(
              Math.round(newPosition.x / gridSize) * gridSize,
              Math.round(newPosition.y / gridSize) * gridSize,
              Math.round(newPosition.z / gridSize) * gridSize
            )
          }

          const newRotation = initialState.rotation.add(rotation)
          const newScale = initialState.scale.multiply(scale)

          // Check for collision before applying transform (for multi-select)
          const storeState = useSceneStore.getState()
          const sceneManager = storeState.collisionDetectionEnabled && gizmoControllerRef.current ? 
            (gizmoControllerRef.current as any).sceneManager : null
          
          if (sceneManager && sceneManager.checkCollisionAtTransform) {
            if (!sceneManager.checkCollisionAtTransform(id, newPosition, newRotation, newScale)) {
              updateObject(id, { position: newPosition, rotation: newRotation, scale: newScale })
            } else {
              console.log(`üö´ Multi-select transform blocked for ${id} due to collision`)
            }
          } else {
            updateObject(id, { position: newPosition, rotation: newRotation, scale: newScale })
          }
        })
      } else if (selectedObjectId) {
        // Single object transform with collision checking (including snap-to-object)
        let newPosition = position.clone()
        if (snapToGrid) {
          newPosition = new Vector3(
            Math.round(newPosition.x / gridSize) * gridSize,
            Math.round(newPosition.y / gridSize) * gridSize,
            Math.round(newPosition.z / gridSize) * gridSize
          )
        }

        // Snap to nearby objects using connection points
        if (snapToObjects && sceneManager && (sceneManager as any).computeSnapTransform) {
          const res = (sceneManager as any).computeSnapTransform(
            selectedObjectId,
            newPosition,
            rotation.clone()
          )
          newPosition = res.position
          rotation = res.rotation
        }

        // Check for collision before applying transform (for single object)
        const storeState = useSceneStore.getState()
        const smForCollision = storeState.collisionDetectionEnabled && gizmoControllerRef.current ? 
          (gizmoControllerRef.current as any).sceneManager : null

        if (smForCollision && smForCollision.checkCollisionAtTransform) {
          if (!smForCollision.checkCollisionAtTransform(selectedObjectId, newPosition, rotation.clone(), scale.clone())) {
            updateObject(selectedObjectId, { 
              position: newPosition, 
              rotation: rotation.clone(), 
              scale: scale.clone() 
            })
          } else {
            console.log(`üö´ Transform blocked for ${selectedObjectId} due to collision`)
          }
        } else {
          updateObject(selectedObjectId, { 
            position: newPosition, 
            rotation: rotation.clone(), 
            scale: scale.clone() 
          })
        }
      }
    }

    gizmoControllerRef.current.updateGizmos(transformMode, targetMesh, handleGizmoDragEnd)
  }, [
    selectedObjectId, 
    selectedObjectIds, 
    transformMode, 
    multiSelectPivot, 
    multiSelectInitialStates, 
    snapToGrid,
    snapToObjects,
    gridSize,
    scene
  ])

  return gizmoControllerRef.current
}
</file>

<file path="src/babylon/objectFactory.ts">
import { Scene, MeshBuilder, StandardMaterial, Color3, Mesh, Vector3 } from 'babylonjs';
import type { PrimitiveType, ConnectionPoint } from '../types/types';
import { createHousingMesh } from './housingFactory';
import { generateDefaultConnectionPoints } from './boundaryUtils';

export interface MeshCreationOptions {
  position?: Vector3;
  scale?: Vector3;
  rotation?: Vector3;
  color?: string;
  name?: string;
}

/**
 * Creates a cube mesh with the specified options
 */
export const createCube = (scene: Scene, options: MeshCreationOptions = {}): Mesh => {
  const mesh = MeshBuilder.CreateBox(options.name || 'cube', { size: 1 }, scene);
  applyMeshOptions(mesh, options);
  attachConnectionPoints(mesh, 'cube');
  return mesh;
};

/**
 * Creates a sphere mesh with the specified options
 */
export const createSphere = (scene: Scene, options: MeshCreationOptions = {}): Mesh => {
  const mesh = MeshBuilder.CreateSphere(options.name || 'sphere', { diameter: 1 }, scene);
  applyMeshOptions(mesh, options);
  attachConnectionPoints(mesh, 'sphere');
  return mesh;
};

/**
 * Creates a cylinder mesh with the specified options
 */
export const createCylinder = (scene: Scene, options: MeshCreationOptions = {}): Mesh => {
  const mesh = MeshBuilder.CreateCylinder(options.name || 'cylinder', { height: 1, diameter: 1 }, scene);
  applyMeshOptions(mesh, options);
  attachConnectionPoints(mesh, 'cylinder');
  return mesh;
};

/**
 * Creates a plane mesh with the specified options
 */
export const createPlane = (scene: Scene, options: MeshCreationOptions = {}): Mesh => {
  const mesh = MeshBuilder.CreatePlane(options.name || 'plane', { size: 1 }, scene);
  applyMeshOptions(mesh, options);
  attachConnectionPoints(mesh, 'plane');
  return mesh;
};

/**
 * Creates a torus mesh with the specified options
 */
export const createTorus = (scene: Scene, options: MeshCreationOptions = {}): Mesh => {
  const mesh = MeshBuilder.CreateTorus(options.name || 'torus', { diameter: 1, thickness: 0.3 }, scene);
  applyMeshOptions(mesh, options);
  attachConnectionPoints(mesh, 'torus');
  return mesh;
};

/**
 * Creates a cone mesh with the specified options
 */
export const createCone = (scene: Scene, options: MeshCreationOptions = {}): Mesh => {
  const mesh = MeshBuilder.CreateCylinder(options.name || 'cone', { 
    height: 1, 
    diameterTop: 0, 
    diameterBottom: 1 
  }, scene);
  applyMeshOptions(mesh, options);
  attachConnectionPoints(mesh, 'cone');
  return mesh;
};

/**
 * Creates a ground plane mesh with the specified options
 */
export const createGround = (scene: Scene, options: MeshCreationOptions = {}): Mesh => {
  const mesh = MeshBuilder.CreateGround(options.name || 'ground', { width: 20, height: 20 }, scene);
  applyMeshOptions(mesh, options);
  return mesh;
};

/**
 * Integrates an imported GLB mesh into the scene with standard options
 */
export const integrateImportedMesh = (mesh: Mesh, options: MeshCreationOptions = {}): Mesh => {
  // Apply standard options to the imported mesh
  applyMeshOptions(mesh, options);
  
  // Ensure the mesh is pickable and enabled
  mesh.isPickable = true;
  mesh.setEnabled(true);
  
  return mesh;
};

/**
 * Factory function that creates a mesh based on the primitive type
 */
export const createPrimitiveMesh = (
  type: PrimitiveType, 
  scene: Scene, 
  options: MeshCreationOptions = {}
): Mesh => {
  // Check if it's a housing type
  if (type.startsWith('house-')) {
    return createHousingMesh(type, scene, options);
  }
  
  switch (type) {
    case 'cube':
      return createCube(scene, options);
    case 'sphere':
      return createSphere(scene, options);
    case 'cylinder':
      return createCylinder(scene, options);
    case 'plane':
      return createPlane(scene, options);
    case 'torus':
      return createTorus(scene, options);
    case 'cone':
      return createCone(scene, options);
    case 'nurbs':
      // NURBS is handled separately, not through this factory
      throw new Error('NURBS meshes are not supported in this factory');
    case 'imported-glb':
    case 'imported-stl':
    case 'imported-obj':
      // Imported models are handled separately through integrateImportedMesh
      throw new Error('Imported models should use integrateImportedMesh function');
    default:
      throw new Error(`Unknown primitive type: ${type}`);
  }
};

/**
 * Helper function to apply common mesh options
 */
const applyMeshOptions = (mesh: Mesh, options: MeshCreationOptions): void => {
  // Set position
  if (options.position) {
    mesh.position = options.position;
  }

  // Set scale
  if (options.scale) {
    mesh.scaling = options.scale;
  }

  // Set rotation
  if (options.rotation) {
    mesh.rotation = options.rotation;
  }

  // Create and apply material with color
  const material = new StandardMaterial(`${mesh.name}-material`, mesh.getScene());
  material.diffuseColor = options.color ? Color3.FromHexString(options.color) : Color3.White();
  mesh.material = material;
};

/**
 * Updates an existing mesh with new options
 */
export const updateMesh = (mesh: Mesh, options: Partial<MeshCreationOptions>): void => {
  if (options.position) {
    mesh.position = options.position;
  }

  if (options.scale) {
    mesh.scaling = options.scale;
  }

  if (options.rotation) {
    mesh.rotation = options.rotation;
  }

  if (options.color && mesh.material) {
    const material = mesh.material as StandardMaterial;
    material.diffuseColor = Color3.FromHexString(options.color);
  }
};

/**
 * Attaches connection points metadata to a mesh for snapping/alignment purposes
 */
const attachConnectionPoints = (mesh: Mesh, type: PrimitiveType): void => {
  // Begin with generic AABB-based points for universal compatibility
  let connectionPoints: ConnectionPoint[] = generateDefaultConnectionPoints(mesh);

  switch (type) {
    case 'cube': {
      const halfX = 0.5 * mesh.scaling.x;
      const halfY = 0.5 * mesh.scaling.y;
      const halfZ = 0.5 * mesh.scaling.z;

      connectionPoints = [
        { id: 'px', position: new Vector3(halfX, 0, 0), normal: new Vector3(1, 0, 0) },
        { id: 'nx', position: new Vector3(-halfX, 0, 0), normal: new Vector3(-1, 0, 0) },
        { id: 'py', position: new Vector3(0, halfY, 0), normal: new Vector3(0, 1, 0) },
        { id: 'ny', position: new Vector3(0, -halfY, 0), normal: new Vector3(0, -1, 0) },
        { id: 'pz', position: new Vector3(0, 0, halfZ), normal: new Vector3(0, 0, 1) },
        { id: 'nz', position: new Vector3(0, 0, -halfZ), normal: new Vector3(0, 0, -1) },
      ];
      break;
    }
    case 'plane': {
      const half = 0.5 * mesh.scaling.x; // assuming square plane
      connectionPoints = [
        { id: 'pz', position: new Vector3(0, 0, 0.01), normal: new Vector3(0, 0, 1) },
        { id: 'nz', position: new Vector3(0, 0, -0.01), normal: new Vector3(0, 0, -1) },
      ];
      break;
    }
    // TODO: Add more primitives as needed
    default:
      break;
  }

  // Merge unique IDs from shape-specific list (if any) with generic defaults
  if (connectionPoints.length > 0) {
    if (!mesh.metadata) mesh.metadata = {};
    (mesh.metadata as any).connectionPoints = connectionPoints;
  }
};
</file>

<file path="src/components/modals/CustomRoomModal.tsx">
import React, { useState, useRef, useEffect } from 'react'

interface Point {
  x: number
  y: number
}

interface RoomData {
  points: Point[]
  openings?: { start: Point; end: Point }[]  // Line segments that are openings
  name?: string  // Optional room name/tag
  allSegments?: { start: Point; end: Point; isOpening?: boolean }[]  // All line segments for interior walls
}

interface GridPoint {
  x: number
  y: number
}

interface LineSegment {
  start: GridPoint
  end: GridPoint
  id: string
  isOpening?: boolean  // true for openings/doorways, false/undefined for walls
}

interface CustomRoomModalProps {
  isOpen: boolean
  onCancel: () => void
  onCreate: (roomData: RoomData) => void
  onCreateMultiple?: (roomsData: RoomData[]) => void  // For creating multiple named rooms at once
}

/**
 * A grid-based room drawing tool that lets users draw lines along a grid
 * to create room shapes. Users can only draw horizontal and vertical lines
 * along the grid intersections.
 */
export const CustomRoomModal: React.FC<CustomRoomModalProps> = ({ isOpen, onCancel, onCreate, onCreateMultiple }) => {
  const [lineSegments, setLineSegments] = useState<LineSegment[]>([])
  const [isDrawing, setIsDrawing] = useState(false)
  const [currentLine, setCurrentLine] = useState<LineSegment | null>(null)
  const [hoveredGridPoint, setHoveredGridPoint] = useState<GridPoint | null>(null)
  const [gridSize, setGridSize] = useState(20)
  const [drawingMode, setDrawingMode] = useState<'wall' | 'opening'>('wall')
  const [roomNames, setRoomNames] = useState<{ [key: number]: string }>({})
  const [showNamingStep, setShowNamingStep] = useState(false)
  const svgRef = useRef<SVGSVGElement | null>(null)

  // Grid settings
  const GRID_SIZE = gridSize
  const SVG_WIDTH = 400
  const SVG_HEIGHT = 400
  const GRID_COLS = Math.floor(SVG_WIDTH / GRID_SIZE)
  const GRID_ROWS = Math.floor(SVG_HEIGHT / GRID_SIZE)

  // Reset state whenever the modal (re)opens
  useEffect(() => {
    if (isOpen) {
      setLineSegments([])
      setIsDrawing(false)
      setCurrentLine(null)
      setHoveredGridPoint(null)
      setRoomNames({})
      setShowNamingStep(false)
    }
  }, [isOpen])

  if (!isOpen) return null

  const snapToGrid = (x: number, y: number): GridPoint => {
    const gridX = Math.round(x / GRID_SIZE)
    const gridY = Math.round(y / GRID_SIZE)
    return {
      x: Math.max(0, Math.min(GRID_COLS, gridX)),
      y: Math.max(0, Math.min(GRID_ROWS, gridY))
    }
  }

  const gridToPixel = (gridPoint: GridPoint): Point => {
    return {
      x: gridPoint.x * GRID_SIZE,
      y: gridPoint.y * GRID_SIZE
    }
  }

  const getMouseGridPoint = (e: React.MouseEvent<SVGSVGElement>): GridPoint | null => {
    if (!svgRef.current) return null
    const rect = svgRef.current.getBoundingClientRect()
    const x = e.clientX - rect.left
    const y = e.clientY - rect.top
    return snapToGrid(x, y)
  }

  const handleMouseDown = (e: React.MouseEvent<SVGSVGElement>) => {
    const gridPoint = getMouseGridPoint(e)
    if (!gridPoint) return

    setIsDrawing(true)
    setCurrentLine({
      start: gridPoint,
      end: gridPoint,
      id: `line-${Date.now()}`,
      isOpening: drawingMode === 'opening'
    })
  }

  const handleMouseMove = (e: React.MouseEvent<SVGSVGElement>) => {
    const gridPoint = getMouseGridPoint(e)
    if (!gridPoint) return

    setHoveredGridPoint(gridPoint)

    if (isDrawing && currentLine) {
      // Constrain to horizontal or vertical lines only
      const dx = Math.abs(gridPoint.x - currentLine.start.x)
      const dy = Math.abs(gridPoint.y - currentLine.start.y)
      
      let endPoint: GridPoint
      if (dx > dy) {
        // Horizontal line
        endPoint = { x: gridPoint.x, y: currentLine.start.y }
      } else {
        // Vertical line
        endPoint = { x: currentLine.start.x, y: gridPoint.y }
      }

      setCurrentLine({
        ...currentLine,
        end: endPoint
      })
    }
  }

  const handleMouseUp = () => {
    if (isDrawing && currentLine) {
      // Only add line if it has length > 0
      if (currentLine.start.x !== currentLine.end.x || currentLine.start.y !== currentLine.end.y) {
        setLineSegments(prev => [...prev, currentLine])
      }
      setIsDrawing(false)
      setCurrentLine(null)
    }
  }

  const handleClear = () => {
    setLineSegments([])
    setIsDrawing(false)
    setCurrentLine(null)
  }

  const handleUndo = () => {
    setLineSegments(prev => prev.slice(0, -1))
  }

  // Find enclosed areas (rooms) from the line segments using grid-based region detection
  const findRooms = (): Point[][] => {
    if (lineSegments.length < 3) return []

    // Create a 2D grid to track walls and regions
    const gridWidth = GRID_COLS + 1
    const gridHeight = GRID_ROWS + 1
    
    // Create wall maps for horizontal and vertical walls
    const horizontalWalls = Array(gridHeight).fill(null).map(() => Array(gridWidth).fill(false))
    const verticalWalls = Array(gridHeight).fill(null).map(() => Array(gridWidth).fill(false))
    
    // Create separate maps for walls and all boundaries (including openings)
    const horizontalBoundaries = Array(gridHeight).fill(null).map(() => Array(gridWidth).fill(false))
    const verticalBoundaries = Array(gridHeight).fill(null).map(() => Array(gridWidth).fill(false))
    
    // Mark all boundaries (walls and openings) for region detection
    lineSegments.forEach(line => {
      if (line.start.y === line.end.y) {
        // Horizontal boundary
        const y = line.start.y
        const minX = Math.min(line.start.x, line.end.x)
        const maxX = Math.max(line.start.x, line.end.x)
        for (let x = minX; x < maxX; x++) {
          if (y > 0) {
            horizontalBoundaries[y][x] = true
            // Only mark as wall if not an opening
            if (!line.isOpening) {
              horizontalWalls[y][x] = true
            }
          }
        }
      } else if (line.start.x === line.end.x) {
        // Vertical boundary
        const x = line.start.x
        const minY = Math.min(line.start.y, line.end.y)
        const maxY = Math.max(line.start.y, line.end.y)
        for (let y = minY; y < maxY; y++) {
          if (x > 0) {
            verticalBoundaries[y][x] = true
            // Only mark as wall if not an opening
            if (!line.isOpening) {
              verticalWalls[y][x] = true
            }
          }
        }
      }
    })
    
    // Find enclosed regions using flood fill from edges
    const cellGrid = Array(gridHeight - 1).fill(null).map(() => Array(gridWidth - 1).fill(-1))
    let regionId = 0
    
    // Flood fill to find connected regions
    const floodFill = (startX: number, startY: number, id: number) => {
      const stack: [number, number][] = [[startX, startY]]
      const region: [number, number][] = []
      
      while (stack.length > 0) {
        const [x, y] = stack.pop()!
        
        if (x < 0 || x >= gridWidth - 1 || y < 0 || y >= gridHeight - 1) continue
        if (cellGrid[y][x] !== -1) continue
        
        cellGrid[y][x] = id
        region.push([x, y])
        
        // Check all four neighbors (use boundaries for region detection)
        if (x > 0 && !verticalBoundaries[y][x]) stack.push([x - 1, y])
        if (x < gridWidth - 2 && !verticalBoundaries[y][x + 1]) stack.push([x + 1, y])
        if (y > 0 && !horizontalBoundaries[y][x]) stack.push([x, y - 1])
        if (y < gridHeight - 2 && !horizontalBoundaries[y + 1][x]) stack.push([x, y + 1])
      }
      
      return region
    }
    
    // Start flood fill from edges to mark exterior region
    for (let x = 0; x < gridWidth - 1; x++) {
      if (cellGrid[0][x] === -1 && !horizontalBoundaries[0][x]) {
        floodFill(x, 0, 0) // Mark as exterior (id = 0)
      }
      if (cellGrid[gridHeight - 2][x] === -1 && !horizontalBoundaries[gridHeight - 1][x]) {
        floodFill(x, gridHeight - 2, 0)
      }
    }
    
    for (let y = 0; y < gridHeight - 1; y++) {
      if (cellGrid[y][0] === -1 && !verticalBoundaries[y][0]) {
        floodFill(0, y, 0)
      }
      if (cellGrid[y][gridWidth - 2] === -1 && !verticalBoundaries[y][gridWidth - 1]) {
        floodFill(gridWidth - 2, y, 0)
      }
    }
    
    // Find all interior regions (rooms)
    const rooms: Point[][] = []
    const processedRegions = new Set<number>()
    
    for (let y = 0; y < gridHeight - 1; y++) {
      for (let x = 0; x < gridWidth - 1; x++) {
        if (cellGrid[y][x] === -1) {
          // Found an unprocessed interior cell
          regionId++
          const region = floodFill(x, y, regionId)
          
          if (region.length > 0) {
            // Extract boundary points of this region
            const boundaryPoints = extractRegionBoundary(region, horizontalBoundaries, verticalBoundaries, horizontalWalls, verticalWalls)
            if (boundaryPoints.length >= 4) {
              rooms.push(boundaryPoints)
            }
          }
        }
      }
    }
    
    return rooms
  }
  
  // Extract the boundary points of a region by tracing the perimeter
  const extractRegionBoundary = (
    region: [number, number][],
    horizontalBoundaries: boolean[][],
    verticalBoundaries: boolean[][],
    horizontalWalls: boolean[][],
    verticalWalls: boolean[][]
  ): Point[] => {
    if (region.length === 0) return []
    
    const cellSet = new Set(region.map(([x, y]) => `${x},${y}`))
    
    // Find all boundary edges of the region
    const boundaryEdges: { from: GridPoint; to: GridPoint }[] = []
    
    for (const [cellX, cellY] of region) {
      // Check all four edges of this cell (use boundaries for edge detection)
      // Top edge
      if (cellY === 0 || !cellSet.has(`${cellX},${cellY - 1}`) || horizontalBoundaries[cellY][cellX]) {
        boundaryEdges.push({
          from: { x: cellX, y: cellY },
          to: { x: cellX + 1, y: cellY }
        })
      }
      // Bottom edge
      if (cellY === GRID_ROWS - 2 || !cellSet.has(`${cellX},${cellY + 1}`) || horizontalBoundaries[cellY + 1][cellX]) {
        boundaryEdges.push({
          from: { x: cellX + 1, y: cellY + 1 },
          to: { x: cellX, y: cellY + 1 }
        })
      }
      // Left edge
      if (cellX === 0 || !cellSet.has(`${cellX - 1},${cellY}`) || verticalBoundaries[cellY][cellX]) {
        boundaryEdges.push({
          from: { x: cellX, y: cellY + 1 },
          to: { x: cellX, y: cellY }
        })
      }
      // Right edge
      if (cellX === GRID_COLS - 2 || !cellSet.has(`${cellX + 1},${cellY}`) || verticalBoundaries[cellY][cellX + 1]) {
        boundaryEdges.push({
          from: { x: cellX + 1, y: cellY },
          to: { x: cellX + 1, y: cellY + 1 }
        })
      }
    }
    
    if (boundaryEdges.length === 0) return []
    
    // Connect edges to form a continuous polygon
    const polygon: GridPoint[] = []
    const edgeMap = new Map<string, { from: GridPoint; to: GridPoint }>()
    
    // Build edge lookup map
    boundaryEdges.forEach(edge => {
      const key = `${edge.from.x},${edge.from.y}`
      edgeMap.set(key, edge)
    })
    
    // Start with the first edge
    let currentEdge = boundaryEdges[0]
    const startPoint = currentEdge.from
    polygon.push(startPoint)
    
    const visitedEdges = new Set<string>()
    let iterations = 0
    const maxIterations = boundaryEdges.length * 2
    
    // Trace the boundary
    while (iterations < maxIterations) {
      iterations++
      
      const edgeKey = `${currentEdge.from.x},${currentEdge.from.y}-${currentEdge.to.x},${currentEdge.to.y}`
      if (visitedEdges.has(edgeKey)) break
      visitedEdges.add(edgeKey)
      
      const nextPoint = currentEdge.to
      
      // Check if we've completed the loop
      if (nextPoint.x === startPoint.x && nextPoint.y === startPoint.y) {
        break
      }
      
      polygon.push(nextPoint)
      
      // Find the next edge that starts where this one ends
      const nextEdgeKey = `${nextPoint.x},${nextPoint.y}`
      const nextEdge = edgeMap.get(nextEdgeKey)
      
      if (!nextEdge) {
        // Try to find any edge that connects
        let found = false
        for (const edge of boundaryEdges) {
          if (edge.from.x === nextPoint.x && edge.from.y === nextPoint.y) {
            currentEdge = edge
            found = true
            break
          }
        }
        if (!found) break
      } else {
        currentEdge = nextEdge
      }
    }
    
    // Convert to pixel coordinates and simplify
    const pixelPoints = polygon.map(p => ({ x: p.x * GRID_SIZE, y: p.y * GRID_SIZE }))
    
    // Remove collinear points to simplify the polygon
    const simplified: Point[] = []
    for (let i = 0; i < pixelPoints.length; i++) {
      const prev = pixelPoints[(i - 1 + pixelPoints.length) % pixelPoints.length]
      const curr = pixelPoints[i]
      const next = pixelPoints[(i + 1) % pixelPoints.length]
      
      // Check if current point is collinear with prev and next
      const dx1 = curr.x - prev.x
      const dy1 = curr.y - prev.y
      const dx2 = next.x - curr.x
      const dy2 = next.y - curr.y
      
      // Cross product to check collinearity
      const cross = dx1 * dy2 - dy1 * dx2
      
      if (Math.abs(cross) > 0.01) {
        simplified.push(curr)
      }
    }
    
    return simplified.length >= 3 ? simplified : pixelPoints
  }
  
  // Order corners counter-clockwise
  const orderCornersCCW = (corners: GridPoint[]): GridPoint[] => {
    if (corners.length === 0) return []
    
    // Find centroid
    const centroid = corners.reduce(
      (acc, c) => ({ x: acc.x + c.x, y: acc.y + c.y }),
      { x: 0, y: 0 }
    )
    centroid.x /= corners.length
    centroid.y /= corners.length
    
    // Sort by angle from centroid
    return corners.slice().sort((a, b) => {
      const angleA = Math.atan2(a.y - centroid.y, a.x - centroid.x)
      const angleB = Math.atan2(b.y - centroid.y, b.x - centroid.x)
      return angleA - angleB
    })
  }

  const handleProceedToNaming = () => {
    const rooms = findRooms()
    if (rooms.length === 0) return
    
    // Initialize room names with defaults
    const defaultNames: { [key: number]: string } = {}
    rooms.forEach((_, index) => {
      defaultNames[index] = `Room ${index + 1}`
    })
    setRoomNames(defaultNames)
    setShowNamingStep(true)
  }

  const handleCreateRooms = () => {
    const rooms = findRooms()
    if (rooms.length === 0) return

    // Find openings (line segments marked as openings)
    const openingSegments = lineSegments.filter(line => line.isOpening)
    const openings = openingSegments.map(line => ({
      start: { x: line.start.x * GRID_SIZE, y: line.start.y * GRID_SIZE },
      end: { x: line.end.x * GRID_SIZE, y: line.end.y * GRID_SIZE }
    }))

    // Convert all line segments to pixel coordinates
    const allSegments = lineSegments.map(line => ({
      start: { x: line.start.x * GRID_SIZE, y: line.start.y * GRID_SIZE },
      end: { x: line.end.x * GRID_SIZE, y: line.end.y * GRID_SIZE },
      isOpening: line.isOpening
    }))

    if (onCreateMultiple) {
      // Create all rooms at once with their names
      const roomsData: RoomData[] = rooms.map((room, index) => ({
        points: room,
        openings: openings.length > 0 ? openings : undefined,
        name: roomNames[index] || `Room ${index + 1}`,
        allSegments: allSegments.length > 0 ? allSegments : undefined
      }))
      onCreateMultiple(roomsData)
    } else {
      // Fallback to creating rooms one by one
      rooms.forEach((room, index) => {
        setTimeout(() => {
          const roomData: RoomData = {
            points: room,
            openings: openings.length > 0 ? openings : undefined,
            name: roomNames[index] || `Room ${index + 1}`,
            allSegments: allSegments.length > 0 ? allSegments : undefined
          }
          onCreate(roomData)
        }, index * 100)
      })
    }
  }

  // Generate grid points for visualization
  const generateGridPoints = () => {
    const points: GridPoint[] = []
    for (let x = 0; x <= GRID_COLS; x++) {
      for (let y = 0; y <= GRID_ROWS; y++) {
        points.push({ x, y })
      }
    }
    return points
  }

  const gridPoints = generateGridPoints()
  const detectedRooms = findRooms()

  // Render naming step if we're in that phase
  if (showNamingStep) {
    const rooms = findRooms()
    
    return (
      <div className="modal-overlay" style={overlayStyle}>
        <div className="modal-container" style={namingContainerStyle}>
          <h2 style={{ marginTop: 0 }}>Name Your Rooms</h2>
          <p style={{ fontSize: '14px', color: '#666', marginBottom: '16px' }}>
            Assign names to the {rooms.length} detected room{rooms.length !== 1 ? 's' : ''}:
          </p>
          
          <div style={{ maxHeight: '400px', overflowY: 'auto', marginBottom: '16px' }}>
            {rooms.map((room, index) => (
              <div key={index} style={{ marginBottom: '12px', display: 'flex', alignItems: 'center', gap: '12px' }}>
                <div style={{ 
                  width: '60px', 
                  height: '60px', 
                  border: '1px solid #ddd',
                  position: 'relative',
                  flexShrink: 0
                }}>
                  <svg width="60" height="60" style={{ position: 'absolute', top: 0, left: 0 }}>
                    <polygon
                      points={room.map(p => {
                        // Scale room to fit in preview
                        const minX = Math.min(...room.map(pt => pt.x))
                        const maxX = Math.max(...room.map(pt => pt.x))
                        const minY = Math.min(...room.map(pt => pt.y))
                        const maxY = Math.max(...room.map(pt => pt.y))
                        const scale = 50 / Math.max(maxX - minX, maxY - minY)
                        return `${5 + (p.x - minX) * scale},${5 + (p.y - minY) * scale}`
                      }).join(' ')}
                      fill="rgba(46, 204, 113, 0.2)"
                      stroke="#2ecc71"
                      strokeWidth={1}
                    />
                  </svg>
                </div>
                <input
                  type="text"
                  value={roomNames[index] || ''}
                  onChange={(e) => setRoomNames(prev => ({ ...prev, [index]: e.target.value }))}
                  placeholder={`Room ${index + 1}`}
                  style={{
                    flex: 1,
                    padding: '8px 12px',
                    border: '1px solid #ddd',
                    borderRadius: '4px',
                    fontSize: '14px'
                  }}
                />
              </div>
            ))}
          </div>
          
          <div style={{ display: 'flex', gap: 8, justifyContent: 'flex-end' }}>
            <button onClick={() => setShowNamingStep(false)}>
              Back to Drawing
            </button>
            <button onClick={onCancel}>
              Cancel
            </button>
            <button
              onClick={handleCreateRooms}
              style={{ background: '#3498db', color: '#fff' }}
            >
              Create Named Rooms
            </button>
          </div>
        </div>
      </div>
    )
  }

  // Regular drawing interface
  return (
    <div className="modal-overlay" style={overlayStyle}>
      <div className="modal-container" style={containerStyle}>
        <h2 style={{ marginTop: 0 }}>Draw Room Layout</h2>
        <p style={{ fontSize: '14px', color: '#666', marginBottom: '8px' }}>
          Draw lines along the grid to create room shapes. Lines can only be horizontal or vertical.
        </p>
        
        <div style={{ marginBottom: '12px', display: 'flex', alignItems: 'center', gap: '12px' }}>
          <label style={{ fontSize: '14px', color: '#666' }}>Grid Size:</label>
          <input
            type="range"
            min="10"
            max="40"
            value={gridSize}
            onChange={(e) => {
              const newSize = parseInt(e.target.value)
              setGridSize(newSize)
              // Clear drawing when changing grid size to avoid confusion
              setLineSegments([])
              setCurrentLine(null)
              setIsDrawing(false)
            }}
            style={{ flex: 1 }}
          />
          <span style={{ fontSize: '14px', color: '#666', minWidth: '30px' }}>{gridSize}px</span>
        </div>
        
        <div style={{ marginBottom: '16px', display: 'flex', alignItems: 'center', gap: '8px' }}>
          <label style={{ fontSize: '14px', color: '#666', marginRight: '8px' }}>Drawing Mode:</label>
          <button
            style={{
              padding: '6px 12px',
              backgroundColor: drawingMode === 'wall' ? '#2c3e50' : '#ecf0f1',
              color: drawingMode === 'wall' ? '#fff' : '#2c3e50',
              border: '1px solid #2c3e50',
              borderRadius: '4px 0 0 4px',
              cursor: 'pointer',
              fontSize: '14px'
            }}
            onClick={() => setDrawingMode('wall')}
          >
            üß± Wall
          </button>
          <button
            style={{
              padding: '6px 12px',
              backgroundColor: drawingMode === 'opening' ? '#e74c3c' : '#ecf0f1',
              color: drawingMode === 'opening' ? '#fff' : '#e74c3c',
              border: '1px solid #e74c3c',
              borderRadius: '0 4px 4px 0',
              borderLeft: 'none',
              cursor: 'pointer',
              fontSize: '14px'
            }}
            onClick={() => setDrawingMode('opening')}
          >
            üö™ Opening
          </button>
          <small style={{ marginLeft: '12px', color: '#666', fontSize: '12px' }}>
            {drawingMode === 'wall' ? 'Drawing walls (solid lines)' : 'Drawing openings (dashed lines)'}
          </small>
        </div>
        
        <svg
          ref={svgRef}
          width={SVG_WIDTH}
          height={SVG_HEIGHT}
          style={{ border: '1px solid #ccc', background: '#fff', cursor: 'crosshair' }}
          onMouseDown={handleMouseDown}
          onMouseMove={handleMouseMove}
          onMouseUp={handleMouseUp}
          onMouseLeave={() => {
            setHoveredGridPoint(null)
            if (isDrawing) {
              setIsDrawing(false)
              setCurrentLine(null)
            }
          }}
        >
          {/* Grid lines */}
          <defs>
            <pattern id="grid" width={GRID_SIZE} height={GRID_SIZE} patternUnits="userSpaceOnUse">
              <path d={`M ${GRID_SIZE} 0 L 0 0 0 ${GRID_SIZE}`} fill="none" stroke="#e0e0e0" strokeWidth="1"/>
            </pattern>
          </defs>
          <rect width="100%" height="100%" fill="url(#grid)" />
          
          {/* Grid points */}
          {gridPoints.map((point, idx) => {
            const pixelPoint = gridToPixel(point)
            const isHovered = hoveredGridPoint && 
              hoveredGridPoint.x === point.x && hoveredGridPoint.y === point.y
            return (
              <circle
                key={idx}
                cx={pixelPoint.x}
                cy={pixelPoint.y}
                r={isHovered ? 3 : 1.5}
                fill={isHovered ? "#3498db" : "#bbb"}
                pointerEvents="none"
              />
            )
          })}
          
          {/* Drawn line segments */}
          {lineSegments.map((line) => {
            const startPixel = gridToPixel(line.start)
            const endPixel = gridToPixel(line.end)
            return (
              <line
                key={line.id}
                x1={startPixel.x}
                y1={startPixel.y}
                x2={endPixel.x}
                y2={endPixel.y}
                stroke={line.isOpening ? "#e74c3c" : "#2c3e50"}
                strokeWidth={3}
                strokeDasharray={line.isOpening ? "8,4" : undefined}
                pointerEvents="none"
              />
            )
          })}
          
          {/* Current line being drawn */}
          {currentLine && (
            <line
              x1={gridToPixel(currentLine.start).x}
              y1={gridToPixel(currentLine.start).y}
              x2={gridToPixel(currentLine.end).x}
              y2={gridToPixel(currentLine.end).y}
              stroke={currentLine.isOpening ? "#e74c3c" : "#3498db"}
              strokeWidth={2}
              strokeDasharray={currentLine.isOpening ? "8,4" : "5,5"}
              pointerEvents="none"
            />
          )}
          
          {/* Detected rooms preview */}
          {detectedRooms.map((room, idx) => (
            <polygon
              key={`room-${idx}`}
              points={room.map(p => `${p.x},${p.y}`).join(' ')}
              fill="rgba(46, 204, 113, 0.2)"
              stroke="#2ecc71"
              strokeWidth={2}
              pointerEvents="none"
            />
          ))}
        </svg>
        
        <div style={{ marginTop: 12, display: 'flex', gap: 8, justifyContent: 'space-between' }}>
          <div>
            <small style={{ color: '#666' }}>
              Detected rooms: {detectedRooms.length}
            </small>
          </div>
          <div style={{ display: 'flex', gap: 8 }}>
            <button onClick={handleUndo} disabled={lineSegments.length === 0}>
              Undo
            </button>
            <button onClick={handleClear} disabled={lineSegments.length === 0}>
              Clear
            </button>
            <button onClick={onCancel}>Cancel</button>
            <button
              onClick={handleProceedToNaming}
              disabled={detectedRooms.length === 0}
              style={{ background: '#3498db', color: '#fff' }}
            >
              Next: Name Rooms
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}

// Inline styles to avoid new CSS file for initial implementation
const overlayStyle: React.CSSProperties = {
  position: 'fixed',
  top: 0,
  left: 0,
  width: '100vw',
  height: '100vh',
  background: 'rgba(0,0,0,0.4)',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  zIndex: 1000,
}

const containerStyle: React.CSSProperties = {
  background: '#fefefe',
  padding: 20,
  borderRadius: 8,
  boxShadow: '0 2px 10px rgba(0,0,0,0.2)',
  maxWidth: '500px',
}

const namingContainerStyle: React.CSSProperties = {
  ...containerStyle,
  maxWidth: '600px',
}
</file>

<file path="src/components/sidebar/PropertiesPanel.tsx">
import React from 'react';
import { Vector3 } from 'babylonjs';
import { useSceneStore } from '../../state/sceneStore';
import type { SceneObject, ModularHousingObject, Door, Window, Wall } from '../../types/types';
import { TextureUpload } from './TextureUpload';
import { TextureLibrary } from './TextureLibrary';

export const PropertiesPanel: React.FC = () => {
  const {
    sceneObjects,
    selectedObjectId,
    selectedObjectIds,
    tessellationQuality,
    controlPointVisualizations,
    selectedControlPointIndex,
    selectedWallId,
    selectedDoorId,
    selectedWindowId,
    housingEditMode,
    updateObject,
    setTessellationQuality,
    setSelectedControlPointIndex,
    getSelectedObject,
    getSelectedObjects,
    hasSelection,
    // Texture-related state
    textureAssets,
    setTextureScale,
    setTextureOffset,
    removeTextureFromObject,
    // Housing-specific actions
    getHousingComponent,
    getSelectedWall,
    getSelectedDoor,
    getSelectedWindow,
    addDoor,
    removeDoor,
    addWindow,
    removeWindow,
    changeWallThickness,
    toggleCeiling,
    toggleFloor,
    setSelectedWallId,
    setSelectedDoorId,
    setSelectedWindowId,
    setHousingEditMode,
    addHousingComponent,
    updateHousingComponent,
  } = useSceneStore();

  const selectedObject = getSelectedObject();
  const selectedObjects = getSelectedObjects();
  const hasSelectionFlag = hasSelection();

  const updateSelectedObjectProperty = (property: keyof SceneObject, value: any) => {
    if (selectedObject) {
      updateObject(selectedObject.id, { [property]: value });
    }
  };

  const updateSelectedObjectsProperty = (property: keyof SceneObject, value: any) => {
    const objectsToUpdate = selectedObjectId ? [selectedObjectId] : selectedObjectIds;
    objectsToUpdate.forEach(id => {
      updateObject(id, { [property]: value });
    });
  };

  const updateControlPoint = (objectId: string, uvIndex: [number, number], newPosition: Vector3) => {
    const obj = sceneObjects.find(o => o.id === objectId);
    if (obj && obj.isNurbs && obj.verbData) {
      const [u, v] = uvIndex;
      const newVerbData = { ...obj.verbData };
      newVerbData.controlPoints[u][v] = [newPosition.x, newPosition.y, newPosition.z];
      updateObject(objectId, { verbData: newVerbData });
    }
  };

  const renderBasicProperties = (obj: SceneObject) => (
    <div className="properties-section">
      <h4>Transform Properties</h4>
      
      {/* Room Name for custom rooms */}
      {obj.roomName && (
        <div className="property-group">
          <label>Room Name:</label>
          <input
            type="text"
            value={obj.roomName}
            onChange={(e) => updateSelectedObjectProperty('roomName', e.target.value)}
            className="room-name-input"
            placeholder="Enter room name"
          />
        </div>
      )}
      
      {/* Position */}
      <div className="property-group">
        <label>Position:</label>
        <div className="vector-input">
          <input
            type="number"
            value={obj.position.x.toFixed(2)}
            onChange={(e) => updateSelectedObjectProperty('position', 
              new Vector3(parseFloat(e.target.value), obj.position.y, obj.position.z))}
            step="0.1"
            className="vector-component"
          />
          <input
            type="number"
            value={obj.position.y.toFixed(2)}
            onChange={(e) => updateSelectedObjectProperty('position', 
              new Vector3(obj.position.x, parseFloat(e.target.value), obj.position.z))}
            step="0.1"
            className="vector-component"
          />
          <input
            type="number"
            value={obj.position.z.toFixed(2)}
            onChange={(e) => updateSelectedObjectProperty('position', 
              new Vector3(obj.position.x, obj.position.y, parseFloat(e.target.value)))}
            step="0.1"
            className="vector-component"
          />
        </div>
      </div>

      {/* Rotation */}
      <div className="property-group">
        <label>Rotation (radians):</label>
        <div className="vector-input">
          <input
            type="number"
            value={obj.rotation.x.toFixed(2)}
            onChange={(e) => updateSelectedObjectProperty('rotation', 
              new Vector3(parseFloat(e.target.value), obj.rotation.y, obj.rotation.z))}
            step="0.1"
            className="vector-component"
          />
          <input
            type="number"
            value={obj.rotation.y.toFixed(2)}
            onChange={(e) => updateSelectedObjectProperty('rotation', 
              new Vector3(obj.rotation.x, parseFloat(e.target.value), obj.rotation.z))}
            step="0.1"
            className="vector-component"
          />
          <input
            type="number"
            value={obj.rotation.z.toFixed(2)}
            onChange={(e) => updateSelectedObjectProperty('rotation', 
              new Vector3(obj.rotation.x, obj.rotation.y, parseFloat(e.target.value)))}
            step="0.1"
            className="vector-component"
          />
        </div>
      </div>

      {/* Scale */}
      <div className="property-group">
        <label>Scale:</label>
        <div className="vector-input">
          <input
            type="number"
            value={obj.scale.x.toFixed(2)}
            onChange={(e) => updateSelectedObjectProperty('scale', 
              new Vector3(parseFloat(e.target.value), obj.scale.y, obj.scale.z))}
            step="0.1"
            min="0.1"
            className="vector-component"
          />
          <input
            type="number"
            value={obj.scale.y.toFixed(2)}
            onChange={(e) => updateSelectedObjectProperty('scale', 
              new Vector3(obj.scale.x, parseFloat(e.target.value), obj.scale.z))}
            step="0.1"
            min="0.1"
            className="vector-component"
          />
          <input
            type="number"
            value={obj.scale.z.toFixed(2)}
            onChange={(e) => updateSelectedObjectProperty('scale', 
              new Vector3(obj.scale.x, obj.scale.y, parseFloat(e.target.value)))}
            step="0.1"
            min="0.1"
            className="vector-component"
          />
        </div>
      </div>

      {/* Color */}
      <div className="property-group">
        <label>Color:</label>
        <div className="color-input-group">
          <input
            type="color"
            value={obj.color}
            onChange={(e) => updateSelectedObjectProperty('color', e.target.value)}
            className="color-picker"
          />
          <input
            type="text"
            value={obj.color}
            onChange={(e) => {
              if (/^#[0-9A-F]{6}$/i.test(e.target.value)) {
                updateSelectedObjectProperty('color', e.target.value);
              }
            }}
            className="color-hex-input"
            placeholder="#FFFFFF"
          />
        </div>
      </div>
    </div>
  );

  const renderTextureProperties = (obj: SceneObject) => {
    // Don't show texture properties for ground or certain types
    if (obj.type === 'ground' || obj.type.startsWith('line-')) {
      return null;
    }

    return (
      <div className="properties-section">
        <h4>Texture Properties</h4>
        
        {/* Current Textures */}
        {obj.textureIds && Object.keys(obj.textureIds).length > 0 && (
          <div className="property-group">
            <label>Applied Textures:</label>
            <div className="applied-textures-list">
              {Object.entries(obj.textureIds).map(([type, textureId]) => {
                const texture = textureAssets.get(textureId);
                return (
                  <div key={type} className="applied-texture-item">
                    <span className="texture-type-label">{type}:</span>
                    <span className="texture-name">{texture?.name || 'Unknown'}</span>
                    <button
                      className="remove-texture-btn"
                      onClick={() => removeTextureFromObject(obj.id, type as any)}
                      title="Remove texture"
                    >
                      ‚ùå
                    </button>
                  </div>
                );
              })}
            </div>
          </div>
        )}
        
        {/* Texture Scale */}
        {obj.textureIds && Object.keys(obj.textureIds).length > 0 && (
          <div className="property-group">
            <label>Texture Scale:</label>
            <div className="texture-scale-controls">
              <div className="scale-input">
                <label>U:</label>
                <input
                  type="number"
                  value={obj.textureScale?.u || 1}
                  onChange={(e) => setTextureScale(obj.id, { 
                    u: parseFloat(e.target.value), 
                    v: obj.textureScale?.v || 1 
                  })}
                  step="0.1"
                  min="0.1"
                  className="scale-component"
                />
              </div>
              <div className="scale-input">
                <label>V:</label>
                <input
                  type="number"
                  value={obj.textureScale?.v || 1}
                  onChange={(e) => setTextureScale(obj.id, { 
                    u: obj.textureScale?.u || 1, 
                    v: parseFloat(e.target.value) 
                  })}
                  step="0.1"
                  min="0.1"
                  className="scale-component"
                />
              </div>
            </div>
          </div>
        )}
        
        {/* Texture Offset */}
        {obj.textureIds && Object.keys(obj.textureIds).length > 0 && (
          <div className="property-group">
            <label>Texture Offset:</label>
            <div className="texture-offset-controls">
              <div className="offset-input">
                <label>U:</label>
                <input
                  type="number"
                  value={obj.textureOffset?.u || 0}
                  onChange={(e) => setTextureOffset(obj.id, { 
                    u: parseFloat(e.target.value), 
                    v: obj.textureOffset?.v || 0 
                  })}
                  step="0.1"
                  className="offset-component"
                />
              </div>
              <div className="offset-input">
                <label>V:</label>
                <input
                  type="number"
                  value={obj.textureOffset?.v || 0}
                  onChange={(e) => setTextureOffset(obj.id, { 
                    u: obj.textureOffset?.u || 0, 
                    v: parseFloat(e.target.value) 
                  })}
                  step="0.1"
                  className="offset-component"
                />
              </div>
            </div>
          </div>
        )}
        
        {/* Texture Upload */}
        <div className="property-group">
          <label>Upload New Texture:</label>
          <TextureUpload 
            className="properties-texture-upload"
            onUpload={(textureAsset) => {
              console.log('Texture uploaded:', textureAsset);
            }}
          />
        </div>
        
        {/* Texture Library */}
        <div className="property-group">
          <label>Texture Library:</label>
          <TextureLibrary 
            className="properties-texture-library"
            onApply={(textureId, textureType) => {
              console.log('Applied texture:', textureId, 'as', textureType);
            }}
          />
        </div>
      </div>
    );
  };

  const renderNurbsProperties = (obj: SceneObject) => {
    if (!obj.isNurbs || !obj.verbData) return null;

    const visualization = controlPointVisualizations.find(viz => viz.objectId === obj.id);
    const currentTessellation = tessellationQuality[obj.id] || 16;

    return (
      <div className="properties-section">
        <h4>NURBS Properties</h4>
        
        {/* Tessellation Quality */}
        <div className="property-group">
          <label>Tessellation Quality:</label>
          <div className="tessellation-input">
            <input
              type="range"
              min="4"
              max="64"
              value={currentTessellation}
              onChange={(e) => setTessellationQuality(obj.id, parseInt(e.target.value))}
              className="tessellation-slider"
            />
            <span className="tessellation-value">{currentTessellation}</span>
          </div>
        </div>

        {/* NURBS Surface Information */}
        <div className="property-group">
          <label>Surface Info:</label>
          <div className="nurbs-info">
            <div>Degree U: {obj.verbData.degreeU}</div>
            <div>Degree V: {obj.verbData.degreeV}</div>
            <div>Control Points: {obj.verbData.controlPoints.length} √ó {obj.verbData.controlPoints[0]?.length || 0}</div>
          </div>
        </div>

        {/* Control Point Editing */}
        {visualization && selectedControlPointIndex !== null && (
          <div className="property-group">
            <label>Selected Control Point:</label>
            <div className="control-point-info">
              <div>Index: {selectedControlPointIndex}</div>
              {(() => {
                const controlPointsFlat = obj.verbData.controlPoints.flat();
                const controlPointData = controlPointsFlat[selectedControlPointIndex];
                if (controlPointData) {
                  const [u, v] = [
                    Math.floor(selectedControlPointIndex / obj.verbData.controlPoints[0].length),
                    selectedControlPointIndex % obj.verbData.controlPoints[0].length
                  ];
                  return (
                    <div className="vector-input">
                      <input
                        type="number"
                        value={controlPointData[0].toFixed(2)}
                        onChange={(e) => updateControlPoint(obj.id, [u, v], 
                          new Vector3(parseFloat(e.target.value), controlPointData[1], controlPointData[2]))}
                        step="0.1"
                        className="vector-component"
                      />
                      <input
                        type="number"
                        value={controlPointData[1].toFixed(2)}
                        onChange={(e) => updateControlPoint(obj.id, [u, v], 
                          new Vector3(controlPointData[0], parseFloat(e.target.value), controlPointData[2]))}
                        step="0.1"
                        className="vector-component"
                      />
                      <input
                        type="number"
                        value={controlPointData[2].toFixed(2)}
                        onChange={(e) => updateControlPoint(obj.id, [u, v], 
                          new Vector3(controlPointData[0], controlPointData[1], parseFloat(e.target.value)))}
                        step="0.1"
                        className="vector-component"
                      />
                    </div>
                  );
                }
                return null;
              })()}
            </div>
          </div>
        )}

        {/* Control Point Instructions */}
        <div className="property-group">
          <div className="control-point-instructions">
            <small>
              üí° Click on control points in the 3D view to select and edit them here.
            </small>
          </div>
        </div>
      </div>
    );
  };

  const renderHousingProperties = (obj: SceneObject) => {
    if (!obj.type.startsWith('house-') && obj.type !== 'modular-room') {
      return null;
    }

    const housingComponent = getHousingComponent(obj.id);
    if (!housingComponent) {
      return null;
    }

    return (
      <div className="properties-section">
        <h4>Housing Properties</h4>
        
        {/* Wall Thickness Control */}
        <div className="property-group">
          <label>Wall Thickness:</label>
          <div className="wall-thickness-control">
            <input
              type="range"
              min="0.1"
              max="1.0"
              step="0.05"
              value={housingComponent.wallThickness}
              onChange={(e) => changeWallThickness(obj.id, parseFloat(e.target.value))}
              className="thickness-slider"
            />
            <span className="thickness-value">{housingComponent.wallThickness.toFixed(2)}m</span>
          </div>
        </div>

        {/* Ceiling Toggle */}
        <div className="property-group">
          <label>
            <input
              type="checkbox"
              checked={housingComponent.hasCeiling}
              onChange={(e) => toggleCeiling(obj.id, e.target.checked)}
            />
            Has Ceiling
          </label>
        </div>

        {/* Ceiling Height */}
        {housingComponent.hasCeiling && (
          <div className="property-group">
            <label>Ceiling Height:</label>
            <input
              type="number"
              value={housingComponent.ceilingHeight}
              onChange={(e) => updateHousingComponent(obj.id, { ceilingHeight: parseFloat(e.target.value) })}
              step="0.1"
              min="2.0"
              max="5.0"
              className="height-input"
            />
          </div>
        )}

        {/* Enhanced Ceiling Management */}
        {housingComponent.hasCeiling && (
          <>
            <div className="property-group">
              <label>Ceiling Type:</label>
              <select
                value={housingComponent.ceilingType || 'flat'}
                onChange={(e) => updateHousingComponent(obj.id, { ceilingType: e.target.value as any })}
                className="ceiling-type-select"
              >
                <option value="flat">Flat Ceiling</option>
                <option value="vaulted">Vaulted Ceiling</option>
                <option value="coffered">Coffered Ceiling</option>
                <option value="tray">Tray Ceiling</option>
                <option value="cathedral">Cathedral Ceiling</option>
                <option value="beam">Exposed Beam</option>
              </select>
            </div>

            <div className="property-group">
              <label>Ceiling Material:</label>
              <select
                value={housingComponent.ceilingMaterial || 'drywall'}
                onChange={(e) => updateHousingComponent(obj.id, { ceilingMaterial: e.target.value })}
                className="ceiling-material-select"
              >
                <option value="drywall">Drywall</option>
                <option value="plaster">Plaster</option>
                <option value="wood">Wood Planks</option>
                <option value="acoustic">Acoustic Tiles</option>
                <option value="metal">Metal</option>
                <option value="concrete">Concrete</option>
                <option value="tin">Tin Tiles</option>
              </select>
            </div>

            <div className="property-group">
              <label>Ceiling Thickness:</label>
              <div className="thickness-control">
                <input
                  type="range"
                  min="0.05"
                  max="0.3"
                  step="0.01"
                  value={housingComponent.ceilingThickness || 0.1}
                  onChange={(e) => updateHousingComponent(obj.id, { ceilingThickness: parseFloat(e.target.value) })}
                  className="thickness-slider"
                />
                <span className="thickness-value">{(housingComponent.ceilingThickness || 0.1).toFixed(2)}m</span>
              </div>
            </div>

            <div className="property-group">
              <label>Ceiling Features:</label>
              <div className="ceiling-features">
                <div className="feature-option">
                  <input
                    type="checkbox"
                    checked={housingComponent.ceilingFeatures?.hasLights || false}
                    onChange={(e) => updateHousingComponent(obj.id, { 
                      ceilingFeatures: { 
                        ...housingComponent.ceilingFeatures, 
                        hasLights: e.target.checked 
                      } 
                    })}
                  />
                  <label>Recessed Lighting</label>
                </div>
                <div className="feature-option">
                  <input
                    type="checkbox"
                    checked={housingComponent.ceilingFeatures?.hasFan || false}
                    onChange={(e) => updateHousingComponent(obj.id, { 
                      ceilingFeatures: { 
                        ...housingComponent.ceilingFeatures, 
                        hasFan: e.target.checked 
                      } 
                    })}
                  />
                  <label>Ceiling Fan</label>
                </div>
                <div className="feature-option">
                  <input
                    type="checkbox"
                    checked={housingComponent.ceilingFeatures?.hasSkylight || false}
                    onChange={(e) => updateHousingComponent(obj.id, { 
                      ceilingFeatures: { 
                        ...housingComponent.ceilingFeatures, 
                        hasSkylight: e.target.checked 
                      } 
                    })}
                  />
                  <label>Skylight</label>
                </div>
                <div className="feature-option">
                  <input
                    type="checkbox"
                    checked={housingComponent.ceilingFeatures?.hasBeams || false}
                    onChange={(e) => updateHousingComponent(obj.id, { 
                      ceilingFeatures: { 
                        ...housingComponent.ceilingFeatures, 
                        hasBeams: e.target.checked 
                      } 
                    })}
                  />
                  <label>Decorative Beams</label>
                </div>
              </div>
            </div>

            <div className="property-group">
              <label>Ceiling Actions:</label>
              <div className="ceiling-actions">
                <button
                  className="ceiling-action-btn"
                  onClick={() => {
                    // Auto-adjust ceiling height based on room type
                    const roomType = housingComponent.roomType || 'living-room';
                    const heightMap = {
                      'living-room': 2.7,
                      'bedroom': 2.4,
                      'kitchen': 2.4,
                      'bathroom': 2.4,
                      'dining-room': 2.7,
                      'office': 2.4,
                      'hallway': 2.4,
                      'garage': 3.0
                    };
                    const suggestedHeight = heightMap[roomType as keyof typeof heightMap] || 2.4;
                    updateHousingComponent(obj.id, { ceilingHeight: suggestedHeight });
                  }}
                >
                  üìè Auto-Height
                </button>
                <button
                  className="ceiling-action-btn"
                  onClick={() => {
                    // Match ceiling to connected rooms
                    console.log('Match ceiling to connected rooms');
                  }}
                >
                  üîó Match Connected
                </button>
                <button
                  className="ceiling-action-btn"
                  onClick={() => {
                    // Preview ceiling changes
                    console.log('Preview ceiling changes');
                  }}
                >
                  üëÅÔ∏è Preview
                </button>
              </div>
            </div>
          </>
        )}

        {/* Floor Toggle */}
        <div className="property-group">
          <label>
            <input
              type="checkbox"
              checked={housingComponent.hasFloor}
              onChange={(e) => toggleFloor(obj.id, e.target.checked)}
            />
            Has Floor
          </label>
        </div>

        {/* Enhanced Floor Management */}
        {housingComponent.hasFloor && (
          <>
            <div className="property-group">
              <label>Floor Material:</label>
              <select
                value={housingComponent.floorMaterial || 'hardwood'}
                onChange={(e) => updateHousingComponent(obj.id, { floorMaterial: e.target.value })}
                className="floor-material-select"
              >
                <option value="hardwood">Hardwood</option>
                <option value="laminate">Laminate</option>
                <option value="tile">Tile</option>
                <option value="carpet">Carpet</option>
                <option value="concrete">Concrete</option>
                <option value="vinyl">Vinyl</option>
                <option value="marble">Marble</option>
                <option value="bamboo">Bamboo</option>
              </select>
            </div>

            <div className="property-group">
              <label>Floor Thickness:</label>
              <div className="thickness-control">
                <input
                  type="range"
                  min="0.02"
                  max="0.15"
                  step="0.005"
                  value={housingComponent.floorThickness || 0.05}
                  onChange={(e) => updateHousingComponent(obj.id, { floorThickness: parseFloat(e.target.value) })}
                  className="thickness-slider"
                />
                <span className="thickness-value">{(housingComponent.floorThickness || 0.05).toFixed(3)}m</span>
              </div>
            </div>

            <div className="property-group">
              <label>Floor Features:</label>
              <div className="floor-features">
                <div className="feature-option">
                  <input
                    type="checkbox"
                    checked={housingComponent.floorFeatures?.hasBaseboards || false}
                    onChange={(e) => updateHousingComponent(obj.id, { 
                      floorFeatures: { 
                        ...housingComponent.floorFeatures, 
                        hasBaseboards: e.target.checked 
                      } 
                    })}
                  />
                  <label>Baseboards</label>
                </div>
                <div className="feature-option">
                  <input
                    type="checkbox"
                    checked={housingComponent.floorFeatures?.hasHeating || false}
                    onChange={(e) => updateHousingComponent(obj.id, { 
                      floorFeatures: { 
                        ...housingComponent.floorFeatures, 
                        hasHeating: e.target.checked 
                      } 
                    })}
                  />
                  <label>Radiant Heating</label>
                </div>
                <div className="feature-option">
                  <input
                    type="checkbox"
                    checked={housingComponent.floorFeatures?.hasTransition || false}
                    onChange={(e) => updateHousingComponent(obj.id, { 
                      floorFeatures: { 
                        ...housingComponent.floorFeatures, 
                        hasTransition: e.target.checked 
                      } 
                    })}
                  />
                  <label>Transition Strips</label>
                </div>
              </div>
            </div>
          </>
        )}

        {/* Room Type */}
        <div className="property-group">
          <label>Room Type:</label>
          <select
            value={housingComponent.roomType || 'living-room'}
            onChange={(e) => updateHousingComponent(obj.id, { roomType: e.target.value as any })}
            className="room-type-select"
          >
            <option value="living-room">Living Room</option>
            <option value="bedroom">Bedroom</option>
            <option value="kitchen">Kitchen</option>
            <option value="bathroom">Bathroom</option>
            <option value="dining-room">Dining Room</option>
            <option value="office">Office</option>
            <option value="hallway">Hallway</option>
            <option value="garage">Garage</option>
          </select>
        </div>

        {/* Walls List */}
        <div className="property-group">
          <label>Walls ({housingComponent.walls.length}):</label>
          <div className="walls-list">
            {housingComponent.walls.map((wall, index) => (
              <div 
                key={wall.id} 
                className={`wall-item ${selectedWallId === wall.id ? 'selected' : ''}`}
                onClick={() => setSelectedWallId(wall.id)}
              >
                <span className="wall-name">{wall.type} Wall {index + 1}</span>
                <span className="wall-info">
                  {wall.doors.length} doors, {wall.windows.length} windows
                </span>
              </div>
            ))}
          </div>
        </div>

        {/* Selected Wall Properties */}
        {selectedWallId && renderSelectedWallProperties(obj.id, selectedWallId)}

        {/* Doors List */}
        <div className="property-group">
          <label>Doors ({housingComponent.doors.length}):</label>
          <div className="doors-list">
            {housingComponent.doors.map((door, index) => (
              <div 
                key={door.id} 
                className={`door-item ${selectedDoorId === door.id ? 'selected' : ''}`}
                onClick={() => setSelectedDoorId(door.id)}
              >
                <span className="door-name">{door.type} Door {index + 1}</span>
                <span className="door-info">
                  {door.width.toFixed(2)}√ó{door.height.toFixed(2)}m
                </span>
              </div>
            ))}
          </div>
          <button 
            className="add-component-btn"
            onClick={() => setHousingEditMode('door')}
          >
            + Add Door
          </button>
        </div>

        {/* Selected Door Properties */}
        {selectedDoorId && renderSelectedDoorProperties(obj.id, selectedDoorId)}

        {/* Windows List */}
        <div className="property-group">
          <label>Windows ({housingComponent.windows.length}):</label>
          <div className="windows-list">
            {housingComponent.windows.map((window, index) => (
              <div 
                key={window.id} 
                className={`window-item ${selectedWindowId === window.id ? 'selected' : ''}`}
                onClick={() => setSelectedWindowId(window.id)}
              >
                <span className="window-name">{window.type} Window {index + 1}</span>
                <span className="window-info">
                  {window.width.toFixed(2)}√ó{window.height.toFixed(2)}m
                </span>
              </div>
            ))}
          </div>
          <button 
            className="add-component-btn"
            onClick={() => setHousingEditMode('window')}
          >
            + Add Window
          </button>
        </div>

        {/* Selected Window Properties */}
        {selectedWindowId && renderSelectedWindowProperties(obj.id, selectedWindowId)}

        {/* Building Info */}
        <div className="property-group">
          <label>Building Information:</label>
          <div className="building-info">
            <div>Type: {housingComponent.housingType}</div>
            <div>Walls: {housingComponent.walls.length}</div>
            <div>Total Doors: {housingComponent.doors.length}</div>
            <div>Total Windows: {housingComponent.windows.length}</div>
          </div>
        </div>
      </div>
    );
  };

  const renderSelectedWallProperties = (objectId: string, wallId: string) => {
    const wall = getSelectedWall(objectId);
    if (!wall) return null;

    return (
      <div className="property-group selected-wall-properties">
        <h5>Selected Wall Properties</h5>
        
        <div className="wall-property">
          <label>Wall Type:</label>
          <select
            value={wall.type}
            onChange={(e) => {
              // Update wall type with real-time preview
              const newType = e.target.value as any;
              // TODO: Implement wall type update with visual feedback
              console.log('Update wall type:', newType);
            }}
          >
            <option value="exterior">Exterior</option>
            <option value="interior">Interior</option>
            <option value="load-bearing">Load Bearing</option>
            <option value="partition">Partition</option>
          </select>
        </div>

        <div className="wall-property">
          <label>Wall Thickness:</label>
          <div className="wall-thickness-control">
            <input
              type="range"
              min="0.05"
              max="1.0"
              step="0.025"
              value={wall.thickness}
              onChange={(e) => {
                const newThickness = parseFloat(e.target.value);
                changeWallThickness(objectId, newThickness, wallId);
                // Real-time preview implementation
                const housingComponent = getHousingComponent(objectId);
                if (housingComponent) {
                  // Update the mesh in real-time
                  const sceneObject = sceneObjects.find(obj => obj.id === objectId);
                  if (sceneObject && sceneObject.mesh) {
                    // Force mesh regeneration with new thickness
                    sceneObject.mesh.dispose();
                    // The mesh will be regenerated by the scene manager
                  }
                }
              }}
              className="thickness-slider"
            />
            <span className="thickness-value">{wall.thickness.toFixed(3)}m</span>
          </div>
          <small className="thickness-hint">
            üí° Real-time preview active
          </small>
        </div>

        <div className="wall-property">
          <label>Wall Height:</label>
          <div className="height-control">
            <input
              type="number"
              value={wall.height}
              onChange={(e) => {
                // Update wall height with auto-adjust connected structures
                const newHeight = parseFloat(e.target.value);
                const housingComponent = getHousingComponent(objectId);
                if (housingComponent) {
                  // Update the specific wall height
                  const targetWall = housingComponent.walls.find(w => w.id === wallId);
                  if (targetWall) {
                    targetWall.height = newHeight;
                    updateHousingComponent(objectId, housingComponent);
                    
                    // Auto-adjust connected structures
                    targetWall.connectedWalls.forEach(connectedWallId => {
                      const connectedWall = housingComponent.walls.find(w => w.id === connectedWallId);
                      if (connectedWall) {
                        connectedWall.height = newHeight;
                      }
                    });
                    
                    // Update ceiling height if needed
                    if (housingComponent.hasCeiling) {
                      housingComponent.ceilingHeight = newHeight;
                    }
                    
                    // Force mesh regeneration
                    const sceneObject = sceneObjects.find(obj => obj.id === objectId);
                    if (sceneObject && sceneObject.mesh) {
                      sceneObject.mesh.dispose();
                    }
                  }
                }
              }}
              step="0.1"
              min="2.0"
              max="5.0"
              className="height-input"
            />
            <button
              className="auto-adjust-btn"
              onClick={() => {
                // Auto-adjust connected structures
                const housingComponent = getHousingComponent(objectId);
                if (housingComponent) {
                  const targetWall = housingComponent.walls.find(w => w.id === wallId);
                  if (targetWall) {
                    // Set all connected walls to the same height
                    const targetHeight = targetWall.height;
                    targetWall.connectedWalls.forEach(connectedWallId => {
                      const connectedWall = housingComponent.walls.find(w => w.id === connectedWallId);
                      if (connectedWall) {
                        connectedWall.height = targetHeight;
                      }
                    });
                    
                    // Update ceiling height
                    if (housingComponent.hasCeiling) {
                      housingComponent.ceilingHeight = targetHeight;
                    }
                    
                    updateHousingComponent(objectId, housingComponent);
                    
                    // Force mesh regeneration
                    const sceneObject = sceneObjects.find(obj => obj.id === objectId);
                    if (sceneObject && sceneObject.mesh) {
                      sceneObject.mesh.dispose();
                    }
                  }
                }
              }}
              title="Auto-adjust connected structures"
            >
              üîó
            </button>
          </div>
        </div>

        <div className="wall-property">
          <label>Wall Length:</label>
          <div className="length-display">
            <span className="length-value">
              {wall.startPoint.subtract(wall.endPoint).length().toFixed(2)}m
            </span>
            <button
              className="edit-length-btn"
              onClick={() => {
                // Enter wall length edit mode
                console.log('Enter wall length edit mode');
              }}
              title="Edit wall endpoints"
            >
              ‚úèÔ∏è
            </button>
          </div>
        </div>

        <div className="wall-property">
          <label>Load Bearing:</label>
          <div className="load-bearing-control">
            <input
              type="checkbox"
              checked={wall.isLoadBearing}
              onChange={(e) => {
                // Update load bearing status with structural warnings
                const isLoadBearing = e.target.checked;
                if (!isLoadBearing && wall.connectedWalls.length > 0) {
                  // Show warning about connected walls
                  console.log('Warning: This wall supports connected structures');
                }
                // TODO: Implement load bearing update
                console.log('Update load bearing:', isLoadBearing);
              }}
            />
            {wall.isLoadBearing && wall.connectedWalls.length > 0 && (
              <span className="structural-warning">
                ‚ö†Ô∏è Supports {wall.connectedWalls.length} connected wall{wall.connectedWalls.length > 1 ? 's' : ''}
              </span>
            )}
          </div>
        </div>

        <div className="wall-property">
          <label>Connected Walls:</label>
          <div className="connected-walls-list">
            {wall.connectedWalls.length === 0 ? (
              <span className="no-connections">No connections</span>
            ) : (
              wall.connectedWalls.map((connectedWallId, index) => (
                <div key={connectedWallId} className="connected-wall-item">
                  <span className="connected-wall-id">Wall {index + 1}</span>
                  <button
                    className="disconnect-btn"
                    onClick={() => {
                      // Disconnect wall
                      console.log('Disconnect wall:', connectedWallId);
                    }}
                    title="Disconnect this wall"
                  >
                    üîó‚ö°
                  </button>
                </div>
              ))
            )}
          </div>
        </div>

        <div className="wall-actions">
          <button
            className="wall-action-btn"
            onClick={() => {
              // Enter wall segment edit mode
              console.log('Enter wall segment edit mode');
            }}
          >
            üéØ Edit Segments
          </button>
          <button
            className="wall-action-btn"
            onClick={() => {
              // Split wall at midpoint
              console.log('Split wall at midpoint');
            }}
          >
            ‚úÇÔ∏è Split Wall
          </button>
          <button
            className="wall-action-btn danger"
            onClick={() => {
              // Remove wall with confirmation
              if (window.confirm('Remove this wall? This action cannot be undone.')) {
                console.log('Remove wall');
              }
            }}
          >
            üóëÔ∏è Remove
          </button>
        </div>
      </div>
    );
  };

  const renderSelectedDoorProperties = (objectId: string, doorId: string) => {
    const door = getSelectedDoor(objectId);
    if (!door) return null;

    return (
      <div className="property-group selected-door-properties">
        <h5>Selected Door Properties</h5>
        
        <div className="door-property">
          <label>Door Type:</label>
          <select
            value={door.type}
            onChange={(e) => {
              // Update door type with auto-cutout regeneration
              const newType = e.target.value as any;
              // TODO: Implement door type update with CSG regeneration
              console.log('Update door type:', newType, '- regenerating cutout');
            }}
          >
            <option value="single">Single Door</option>
            <option value="double">Double Door</option>
            <option value="sliding">Sliding Door</option>
            <option value="french">French Door</option>
            <option value="garage">Garage Door</option>
          </select>
        </div>

        <div className="door-property">
          <label>Door Style:</label>
          <select
            value={door.material || 'wood'}
            onChange={(e) => {
              // Update door style/material
              console.log('Update door style:', e.target.value);
            }}
          >
            <option value="wood">Wood Panel</option>
            <option value="glass">Glass Panel</option>
            <option value="steel">Steel</option>
            <option value="composite">Composite</option>
            <option value="arched">Arched</option>
          </select>
        </div>

        <div className="door-property">
          <label>Dimensions:</label>
          <div className="dimension-controls">
            <div className="dimension-input">
              <label>Width:</label>
              <input
                type="number"
                value={door.width}
                onChange={(e) => {
                  const newWidth = parseFloat(e.target.value);
                  // TODO: Update door width with real-time cutout adjustment
                  console.log('Update door width:', newWidth);
                }}
                step="0.05"
                min="0.6"
                max="3.0"
                className="dimension-field"
              />
            </div>
            <div className="dimension-input">
              <label>Height:</label>
              <input
                type="number"
                value={door.height}
                onChange={(e) => {
                  const newHeight = parseFloat(e.target.value);
                  // TODO: Update door height with real-time cutout adjustment
                  console.log('Update door height:', newHeight);
                }}
                step="0.05"
                min="1.8"
                max="3.0"
                className="dimension-field"
              />
            </div>
            <div className="dimension-input">
              <label>Thickness:</label>
              <input
                type="number"
                value={door.thickness}
                onChange={(e) => {
                  const newThickness = parseFloat(e.target.value);
                  console.log('Update door thickness:', newThickness);
                }}
                step="0.005"
                min="0.02"
                max="0.1"
                className="dimension-field"
              />
            </div>
          </div>
        </div>

        <div className="door-property">
          <label>Position on Wall:</label>
          <div className="position-controls">
            <div className="position-slider">
              <input
                type="range"
                min="0"
                max="1"
                step="0.01"
                value={door.position.x} // Normalized position along wall
                onChange={(e) => {
                  const newPosition = parseFloat(e.target.value);
                  // TODO: Update door position with drag-and-drop preview
                  console.log('Update door position:', newPosition);
                }}
                className="position-range"
              />
              <span className="position-value">
                {(door.position.x * 100).toFixed(0)}%
              </span>
            </div>
            <button
              className="drag-position-btn"
              onClick={() => {
                // Enter drag-and-drop positioning mode
                const housingComponent = getHousingComponent(objectId);
                if (housingComponent) {
                  const targetDoor = housingComponent.doors.find(d => d.id === doorId);
                  if (targetDoor) {
                    // Enable drag mode for door positioning
                    setHousingEditMode('door');
                    setSelectedDoorId(doorId);
                    
                    // Create position guides for visual feedback
                    const wall = housingComponent.walls.find(w => w.id === targetDoor.wallId);
                    if (wall) {
                      // Visual feedback: show valid positions along the wall
                      console.log('Created position guides for door:', doorId, 'on wall:', wall.id);
                    }
                  }
                }
              }}
              title="Drag door position in 3D view"
            >
              üéØ Drag Position
            </button>
          </div>
        </div>

        <div className="door-property">
          <label>Door Operation:</label>
          <div className="operation-controls">
            <div className="operation-setting">
              <label>Hinge Direction:</label>
              <select
                value={door.hingeDirection}
                onChange={(e) => {
                  const newDirection = e.target.value as 'left' | 'right';
                  // TODO: Update hinge direction with visual feedback
                  console.log('Update hinge direction:', newDirection);
                }}
              >
                <option value="left">Left Hinge</option>
                <option value="right">Right Hinge</option>
              </select>
            </div>
            <div className="operation-setting">
              <label>Open Direction:</label>
              <select
                value={door.openDirection}
                onChange={(e) => {
                  const newDirection = e.target.value as 'inward' | 'outward';
                  // TODO: Update open direction with visual feedback
                  console.log('Update open direction:', newDirection);
                }}
              >
                <option value="inward">Inward</option>
                <option value="outward">Outward</option>
              </select>
            </div>
            <div className="operation-setting">
              <label>Currently Open:</label>
              <input
                type="checkbox"
                checked={door.isOpen}
                onChange={(e) => {
                  // Toggle door open/closed state
                  console.log('Toggle door open state:', e.target.checked);
                }}
              />
            </div>
          </div>
        </div>

        <div className="door-property">
          <label>Auto-Cutout:</label>
          <div className="cutout-controls">
            <button
              className="cutout-btn"
              onClick={() => {
                // Regenerate door cutout using CSG
                const housingComponent = getHousingComponent(objectId);
                if (housingComponent) {
                  const targetDoor = housingComponent.doors.find(d => d.id === doorId);
                  if (targetDoor) {
                    // Force regeneration of the wall mesh with updated cutout
                    updateHousingComponent(objectId, housingComponent);
                    
                    // Force mesh regeneration
                    const sceneObject = sceneObjects.find(obj => obj.id === objectId);
                    if (sceneObject && sceneObject.mesh) {
                      sceneObject.mesh.dispose();
                      console.log('Regenerated door cutout for door:', doorId);
                    }
                  }
                }
              }}
            >
              üîÑ Regenerate Cutout
            </button>
            <button
              className="cutout-btn"
              onClick={() => {
                // Preview cutout without applying
                const housingComponent = getHousingComponent(objectId);
                if (housingComponent) {
                  const targetDoor = housingComponent.doors.find(d => d.id === doorId);
                  if (targetDoor) {
                    // Create a preview mesh to show the cutout
                    console.log('Preview cutout for door:', doorId);
                    // The preview would be implemented in the scene manager
                  }
                }
              }}
            >
              üëÅÔ∏è Preview Cutout
            </button>
          </div>
        </div>

        <div className="door-actions">
          <button
            className="door-action-btn"
            onClick={() => {
              // Duplicate door to another wall
              console.log('Duplicate door to another wall');
            }}
          >
            üìã Duplicate
          </button>
          <button
            className="door-action-btn"
            onClick={() => {
              // Convert door type (e.g., single to double)
              console.log('Convert door type');
            }}
          >
            üîÑ Convert Type
          </button>
          <button
            className="remove-component-btn"
            onClick={() => {
              if (window.confirm('Remove this door? This will also remove the wall cutout.')) {
                removeDoor(objectId, doorId);
              }
            }}
          >
            üóëÔ∏è Remove Door
          </button>
        </div>
      </div>
    );
  };

  const renderSelectedWindowProperties = (objectId: string, windowId: string) => {
    const window = getSelectedWindow(objectId);
    if (!window) return null;

    return (
      <div className="property-group selected-window-properties">
        <h5>Selected Window Properties</h5>
        
        <div className="window-property">
          <label>Window Type:</label>
          <select
            value={window.type}
            onChange={(e) => {
              // Update window type with auto-cutout regeneration
              const newType = e.target.value as any;
              // TODO: Implement window type update with CSG regeneration
              console.log('Update window type:', newType, '- regenerating cutout');
            }}
          >
            <option value="single">Single Window</option>
            <option value="double">Double Window</option>
            <option value="bay">Bay Window</option>
            <option value="casement">Casement Window</option>
            <option value="sliding">Sliding Window</option>
            <option value="skylight">Skylight</option>
          </select>
        </div>

        <div className="window-property">
          <label>Window Style:</label>
          <select
            value={window.material || 'standard'}
            onChange={(e) => {
              // Update window style/material
              console.log('Update window style:', e.target.value);
            }}
          >
            <option value="standard">Standard</option>
            <option value="arched">Arched</option>
            <option value="circular">Circular</option>
            <option value="stained-glass">Stained Glass</option>
            <option value="frosted">Frosted</option>
          </select>
        </div>

        <div className="window-property">
          <label>Dimensions:</label>
          <div className="dimension-controls">
            <div className="dimension-input">
              <label>Width:</label>
              <input
                type="number"
                value={window.width}
                onChange={(e) => {
                  const newWidth = parseFloat(e.target.value);
                  // TODO: Update window width with real-time cutout adjustment
                  console.log('Update window width:', newWidth);
                }}
                step="0.05"
                min="0.3"
                max="3.0"
                className="dimension-field"
              />
            </div>
            <div className="dimension-input">
              <label>Height:</label>
              <input
                type="number"
                value={window.height}
                onChange={(e) => {
                  const newHeight = parseFloat(e.target.value);
                  // TODO: Update window height with real-time cutout adjustment
                  console.log('Update window height:', newHeight);
                }}
                step="0.05"
                min="0.3"
                max="2.5"
                className="dimension-field"
              />
            </div>
            <div className="dimension-input">
              <label>Sill Height:</label>
              <input
                type="number"
                value={window.sillHeight}
                onChange={(e) => {
                  const newSillHeight = parseFloat(e.target.value);
                  // TODO: Update sill height with real-time preview
                  console.log('Update sill height:', newSillHeight);
                }}
                step="0.05"
                min="0.3"
                max="1.5"
                className="dimension-field"
              />
            </div>
          </div>
        </div>

        <div className="window-property">
          <label>Position on Wall:</label>
          <div className="position-controls">
            <div className="position-slider">
              <input
                type="range"
                min="0"
                max="1"
                step="0.01"
                value={window.position.x} // Normalized position along wall
                onChange={(e) => {
                  const newPosition = parseFloat(e.target.value);
                  // TODO: Update window position with drag-and-drop preview
                  console.log('Update window position:', newPosition);
                }}
                className="position-range"
              />
              <span className="position-value">
                {(window.position.x * 100).toFixed(0)}%
              </span>
            </div>
            <button
              className="drag-position-btn"
              onClick={() => {
                // Enter drag-and-drop positioning mode
                console.log('Enter drag-and-drop positioning mode');
              }}
              title="Drag window position in 3D view"
            >
              üéØ Drag Position
            </button>
          </div>
        </div>

        <div className="window-property">
          <label>Frame Settings:</label>
          <div className="frame-controls">
            <div className="frame-setting">
              <label>Has Frame:</label>
              <input
                type="checkbox"
                checked={window.hasFrame}
                onChange={(e) => {
                  // Toggle frame with real-time preview
                  console.log('Toggle window frame:', e.target.checked);
                }}
              />
            </div>
            {window.hasFrame && (
              <div className="frame-setting">
                <label>Frame Thickness:</label>
                <input
                  type="number"
                  value={window.frameThickness}
                  onChange={(e) => {
                    const newThickness = parseFloat(e.target.value);
                    console.log('Update frame thickness:', newThickness);
                  }}
                  step="0.005"
                  min="0.02"
                  max="0.1"
                  className="dimension-field"
                />
              </div>
            )}
            <div className="frame-setting">
              <label>Openable:</label>
              <input
                type="checkbox"
                checked={window.isOpen || false}
                onChange={(e) => {
                  // Toggle window open/closed state
                  console.log('Toggle window open state:', e.target.checked);
                }}
              />
            </div>
          </div>
        </div>

        <div className="window-property">
          <label>Auto-Cutout:</label>
          <div className="cutout-controls">
            <button
              className="cutout-btn"
              onClick={() => {
                // Regenerate window cutout using CSG
                const housingComponent = getHousingComponent(objectId);
                if (housingComponent) {
                  const targetWindow = housingComponent.windows.find(w => w.id === windowId);
                  if (targetWindow) {
                    // Force regeneration of the wall mesh with updated cutout
                    updateHousingComponent(objectId, housingComponent);
                    
                    // Force mesh regeneration
                    const sceneObject = sceneObjects.find(obj => obj.id === objectId);
                    if (sceneObject && sceneObject.mesh) {
                      sceneObject.mesh.dispose();
                      console.log('Regenerated window cutout for window:', windowId);
                    }
                  }
                }
              }}
            >
              üîÑ Regenerate Cutout
            </button>
            <button
              className="cutout-btn"
              onClick={() => {
                // Preview cutout without applying
                const housingComponent = getHousingComponent(objectId);
                if (housingComponent) {
                  const targetWindow = housingComponent.windows.find(w => w.id === windowId);
                  if (targetWindow) {
                    // Create a preview mesh to show the cutout
                    console.log('Preview cutout for window:', windowId);
                    // The preview would be implemented in the scene manager
                  }
                }
              }}
            >
              üëÅÔ∏è Preview Cutout
            </button>
          </div>
        </div>

        <div className="window-actions">
          <button
            className="window-action-btn"
            onClick={() => {
              // Duplicate window to another wall
              console.log('Duplicate window to another wall');
            }}
          >
            üìã Duplicate
          </button>
          <button
            className="window-action-btn"
            onClick={() => {
              // Convert window type (e.g., single to double)
              console.log('Convert window type');
            }}
          >
            üîÑ Convert Type
          </button>
          <button
            className="remove-component-btn"
            onClick={() => {
              if (confirm('Remove this window? This will also remove the wall cutout.')) {
                removeWindow(objectId, windowId);
              }
            }}
          >
            üóëÔ∏è Remove Window
          </button>
        </div>
      </div>
    );
  };

  const renderMultiSelectProperties = () => (
    <div className="properties-section">
      <h4>Multiple Objects Selected ({selectedObjects.length})</h4>
      
      {/* Bulk Color Change */}
      <div className="property-group">
        <label>Bulk Color Change:</label>
        <div className="color-input-group">
          <input
            type="color"
            onChange={(e) => updateSelectedObjectsProperty('color', e.target.value)}
            className="color-picker"
          />
          <button
            onClick={() => {
              const randomColor = `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`;
              updateSelectedObjectsProperty('color', randomColor);
            }}
            className="random-color-btn"
          >
            Random Color
          </button>
        </div>
      </div>

      {/* Object List */}
      <div className="property-group">
        <label>Selected Objects:</label>
        <div className="selected-objects-list">
          {selectedObjects.map(obj => (
            <div key={obj.id} className="selected-object-item">
              <span className="object-type">{obj.type}</span>
              <span className="object-id">{obj.id}</span>
              <div className="object-color" style={{ backgroundColor: obj.color }}></div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );

  if (!hasSelectionFlag) {
    return (
      <div className="ai-control-group">
        <label>Properties:</label>
        <div className="no-selection-message">
          Select an object to view its properties
        </div>
      </div>
    );
  }

  return (
    <div className="ai-control-group">
      <label>Properties:</label>
      <div className="properties-content">
        {selectedObject ? (
          <>
            {renderBasicProperties(selectedObject)}
            {renderTextureProperties(selectedObject)}
            {renderNurbsProperties(selectedObject)}
            {renderHousingProperties(selectedObject)}
          </>
        ) : (
          renderMultiSelectProperties()
        )}
      </div>
    </div>
  );
};
</file>

<file path="package.json">
{
  "name": "vibecad",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "@types/earcut": "^3.0.0",
    "babylonjs": "^8.15.1",
    "babylonjs-loaders": "^8.15.1",
    "babylonjs-serializers": "^8.15.1",
    "earcut": "^3.0.1",

    "openai": "^5.8.2",
    "react": "^19.1.0",
    "react-dom": "^19.1.0",
    "zustand": "^5.0.6"
  },
  "devDependencies": {
    "@eslint/js": "^9.29.0",
    "@types/react": "^19.1.8",
    "@types/react-dom": "^19.1.6",
    "@vitejs/plugin-react": "^4.5.2",
    "eslint": "^9.29.0",
    "eslint-plugin-react-hooks": "^5.2.0",
    "eslint-plugin-react-refresh": "^0.4.20",
    "globals": "^16.2.0",
    "typescript": "~5.8.3",
    "typescript-eslint": "^8.34.1",
    "vite": "^7.0.0"
  }
}
</file>

<file path="src/state/sceneStore.ts">
import { create } from 'zustand'
import { devtools } from 'zustand/middleware'
import { Vector3, Mesh } from 'babylonjs'
import type { 
    TransformMode, 
    PrimitiveType, 
    SceneObject, 
    ControlPointVisualization, 
    MultiSelectInitialState,
    ModularHousingObject,
    BuildingConnection,
    HousingOperation,
    Door,
    Window,
    Wall,
    ImportError,
    TextureAsset,
    TextureType
} from '../types/types'

// Store State Interface
interface SceneState {
    // Scene objects and selection
    sceneObjects: SceneObject[]
    selectedObjectId: string | null
    selectedObjectIds: string[]
    hoveredObjectId: string | null
    
    // Transform and interaction
    transformMode: TransformMode
    multiSelectMode: boolean
    multiSelectPivot: Mesh | null
    multiSelectInitialStates: {[objectId: string]: MultiSelectInitialState}
    
    // Appearance and display
    currentColor: string
    wireframeMode: boolean
    showGrid: boolean
    snapToGrid: boolean
    snapToObjects: boolean
    showConnectionPoints: boolean
    gridSize: number
    gridMesh: Mesh | null
    collisionDetectionEnabled: boolean
    
    // Object properties
    objectVisibility: {[key: string]: boolean}
    objectLocked: {[key: string]: boolean}
    tessellationQuality: {[objectId: string]: number}
    
    // NURBS specific
    controlPointVisualizations: ControlPointVisualization[]
    selectedControlPointIndex: number | null
    selectedControlPointMesh: Mesh | null
    
    // UI state
    activeDropdown: string | null
    sidebarCollapsed: boolean
    
    // AI and loading
    isLoading: boolean
    apiKey: string
    showApiKeyInput: boolean
    responseLog: string[]
    sceneInitialized: boolean
    
    // Text input for AI
    textInput: string
    
    // GLB Import state
    isImporting: boolean
    importError: ImportError | null
    
    // Texture state
    textureAssets: Map<string, TextureAsset>
    selectedTextureId: string | null
    isUploadingTexture: boolean
    textureUploadError: string | null
    defaultTexturesLoaded: boolean
    
    // Housing-specific state
    housingComponents: {[objectId: string]: ModularHousingObject}
    buildingConnections: BuildingConnection[]
    selectedWallId: string | null
    selectedDoorId: string | null
    selectedWindowId: string | null
    housingEditMode: 'none' | 'wall' | 'door' | 'window' | 'ceiling'
}

// Store Actions Interface
interface SceneActions {
    // Scene object actions
    addObject: (object: SceneObject) => void
    removeObject: (objectId: string) => void
    updateObject: (objectId: string, updates: Partial<SceneObject>) => void
    setSceneObjects: (objects: SceneObject[]) => void
    clearAllObjects: () => void
    
    // Selection actions
    setSelectedObjectId: (objectId: string | null) => void
    setSelectedObjectIds: (objectIds: string[]) => void
    addToSelection: (objectId: string) => void
    removeFromSelection: (objectId: string) => void
    clearSelection: () => void
    setHoveredObjectId: (objectId: string | null) => void
    
    // Transform actions
    setTransformMode: (mode: TransformMode) => void
    setMultiSelectMode: (enabled: boolean) => void
    setMultiSelectPivot: (pivot: Mesh | null) => void
    setMultiSelectInitialStates: (states: {[objectId: string]: MultiSelectInitialState}) => void
    
    // Appearance actions
    setCurrentColor: (color: string) => void
    setWireframeMode: (enabled: boolean) => void
    setShowGrid: (enabled: boolean) => void
    setSnapToGrid: (enabled: boolean) => void
    setSnapToObjects: (enabled: boolean) => void
    setShowConnectionPoints: (enabled: boolean) => void
    setGridSize: (size: number) => void
    setGridMesh: (mesh: Mesh | null) => void
    setCollisionDetectionEnabled: (enabled: boolean) => void
    
    // Object property actions
    setObjectVisibility: (objectId: string, visible: boolean) => void
    setObjectLocked: (objectId: string, locked: boolean) => void
    setTessellationQuality: (objectId: string, quality: number) => void
    updateTessellationQuality: (updates: {[objectId: string]: number}) => void
    
    // NURBS actions
    setControlPointVisualizations: (visualizations: ControlPointVisualization[]) => void
    addControlPointVisualization: (visualization: ControlPointVisualization) => void
    removeControlPointVisualization: (objectId: string) => void
    updateControlPointVisualization: (objectId: string, updates: Partial<ControlPointVisualization>) => void
    setSelectedControlPointIndex: (index: number | null) => void
    setSelectedControlPointMesh: (mesh: Mesh | null) => void
    
    // UI actions
    setActiveDropdown: (dropdown: string | null) => void
    setSidebarCollapsed: (collapsed: boolean) => void
    
    // AI and loading actions
    setIsLoading: (loading: boolean) => void
    setApiKey: (key: string) => void
    setShowApiKeyInput: (show: boolean) => void
    addToResponseLog: (message: string) => void
    setResponseLog: (log: string[]) => void
    setSceneInitialized: (initialized: boolean) => void
    setTextInput: (text: string) => void
    
    // GLB Import actions
    startImport: () => void
    importSuccess: () => void
    setImportError: (error: ImportError) => void
    clearImportError: () => void
    
    // Texture actions
    setTextureAssets: (assets: Map<string, TextureAsset>) => void
    addTextureAsset: (asset: TextureAsset) => void
    removeTextureAsset: (assetId: string) => void
    renameTextureAsset: (assetId: string, newName: string) => void
    setSelectedTextureId: (textureId: string | null) => void
    setIsUploadingTexture: (uploading: boolean) => void
    setTextureUploadError: (error: string | null) => void
    uploadTexture: (file: File) => Promise<string>
    applyTextureToObject: (objectId: string, textureId: string, textureType: TextureType) => void
    removeTextureFromObject: (objectId: string, textureType: TextureType) => void
    setTextureScale: (objectId: string, scale: { u: number; v: number }) => void
    setTextureOffset: (objectId: string, offset: { u: number; v: number }) => void
    loadDefaultTextures: () => void
    
    // Housing-specific actions
    addHousingComponent: (objectId: string, housingObject: ModularHousingObject) => void
    removeHousingComponent: (objectId: string) => void
    updateHousingComponent: (objectId: string, updates: Partial<ModularHousingObject>) => void
    addDoor: (objectId: string, wallId: string, door: Omit<Door, 'id' | 'wallId'>) => string
    removeDoor: (objectId: string, doorId: string) => void
    updateDoor: (objectId: string, doorId: string, updates: Partial<Door>) => void
    addWindow: (objectId: string, wallId: string, window: Omit<Window, 'id' | 'wallId'>) => string
    removeWindow: (objectId: string, windowId: string) => void
    updateWindow: (objectId: string, windowId: string, updates: Partial<Window>) => void
    changeWallThickness: (objectId: string, thickness: number, wallId?: string) => void
    toggleCeiling: (objectId: string, hasCeiling: boolean) => void
    toggleFloor: (objectId: string, hasFloor: boolean) => void
    addBuildingConnection: (connection: Omit<BuildingConnection, 'id'>) => string
    removeBuildingConnection: (connectionId: string) => void
    updateBuildingConnection: (connectionId: string, updates: Partial<BuildingConnection>) => void
    executeHousingOperation: (objectId: string, operation: HousingOperation) => void
    setSelectedWallId: (wallId: string | null) => void
    setSelectedDoorId: (doorId: string | null) => void
    setSelectedWindowId: (windowId: string | null) => void
    setHousingEditMode: (mode: 'none' | 'wall' | 'door' | 'window' | 'ceiling') => void
    
    // Housing-specific getters
    getHousingComponent: (objectId: string) => ModularHousingObject | undefined
    getSelectedWall: (objectId: string) => Wall | undefined
    getSelectedDoor: (objectId: string) => Door | undefined
    getSelectedWindow: (objectId: string) => Window | undefined
    getBuildingConnections: (objectId: string) => BuildingConnection[]
    
    // Computed getters
    getSelectedObject: () => SceneObject | undefined
    getSelectedObjects: () => SceneObject[]
    hasSelection: () => boolean
    getSelectableObjects: () => SceneObject[]
    isObjectSelected: (objectId: string) => boolean
    isObjectVisible: (objectId: string) => boolean
    isObjectLocked: (objectId: string) => boolean
}

// Create the store
export const useSceneStore = create<SceneState & SceneActions>()(
    devtools(
        (set, get) => ({
            // Initial state
            sceneObjects: [],
            selectedObjectId: null,
            selectedObjectIds: [],
            hoveredObjectId: null,
            
            transformMode: 'select',
            multiSelectMode: false,
            multiSelectPivot: null,
            multiSelectInitialStates: {},
            
            currentColor: '#3498db',
            wireframeMode: false,
            showGrid: true,
            snapToGrid: false,
            snapToObjects: true,
            showConnectionPoints: false,
            gridSize: 1,
            gridMesh: null,
            collisionDetectionEnabled: false,
            
            objectVisibility: {},
            objectLocked: {},
            tessellationQuality: {},
            
            controlPointVisualizations: [],
            selectedControlPointIndex: null,
            selectedControlPointMesh: null,
            
            activeDropdown: null,
            sidebarCollapsed: false,
            
            isLoading: false,
            apiKey: '',
            showApiKeyInput: true,
            responseLog: [],
            sceneInitialized: false,
            
            textInput: '',
            
            // GLB Import state
            isImporting: false,
            importError: null,
            
            // Texture state
            textureAssets: new Map(),
            selectedTextureId: null,
            isUploadingTexture: false,
            textureUploadError: null,
            defaultTexturesLoaded: false,
            
            // Housing-specific initial state
            housingComponents: {},
            buildingConnections: [],
            selectedWallId: null,
            selectedDoorId: null,
            selectedWindowId: null,
            housingEditMode: 'none',
            
            // Actions
            addObject: (object) => set((state) => ({
                sceneObjects: [...state.sceneObjects, object]
            })),
            
            removeObject: (objectId) => set((state) => ({
                sceneObjects: state.sceneObjects.filter(obj => obj.id !== objectId),
                selectedObjectId: state.selectedObjectId === objectId ? null : state.selectedObjectId,
                selectedObjectIds: state.selectedObjectIds.filter(id => id !== objectId)
            })),
            
            updateObject: (objectId, updates) => set((state) => ({
                sceneObjects: state.sceneObjects.map(obj => 
                    obj.id === objectId ? (() => { 
                        const updated = { ...obj, ...updates };
                        if (updates.rotation) {
                          console.log(`üìù sceneStore: Updated rotation for ${objectId} to (${updates.rotation.x.toFixed(3)}, ${updates.rotation.y.toFixed(3)}, ${updates.rotation.z.toFixed(3)})`);
                        }
                        return updated;
                    })() : obj
                )
            })),
            
            setSceneObjects: (objects) => set({ sceneObjects: objects }),
            
            clearAllObjects: () => set((state) => ({
                sceneObjects: state.sceneObjects.filter(obj => obj.type === 'ground'),
                selectedObjectId: null,
                selectedObjectIds: [],
                hoveredObjectId: null
            })),
            
            setSelectedObjectId: (objectId) => set({ 
                selectedObjectId: objectId,
                selectedObjectIds: []
            }),
            
            setSelectedObjectIds: (objectIds) => set({ 
                selectedObjectIds: objectIds,
                selectedObjectId: null
            }),
            
            addToSelection: (objectId) => set((state) => ({
                selectedObjectIds: state.selectedObjectIds.includes(objectId) 
                    ? state.selectedObjectIds 
                    : [...state.selectedObjectIds, objectId]
            })),
            
            removeFromSelection: (objectId) => set((state) => ({
                selectedObjectIds: state.selectedObjectIds.filter(id => id !== objectId)
            })),
            
            clearSelection: () => set({
                selectedObjectId: null,
                selectedObjectIds: [],
                selectedControlPointIndex: null,
                selectedControlPointMesh: null
            }),
            
            setHoveredObjectId: (objectId) => set({ hoveredObjectId: objectId }),
            
            setTransformMode: (mode) => set({ transformMode: mode }),
            
            setMultiSelectMode: (enabled) => set({ multiSelectMode: enabled }),
            
            setMultiSelectPivot: (pivot) => set({ multiSelectPivot: pivot }),
            
            setMultiSelectInitialStates: (states) => set({ multiSelectInitialStates: states }),
            
            setCurrentColor: (color) => set({ currentColor: color }),
            
            setWireframeMode: (enabled) => set({ wireframeMode: enabled }),
            
            setShowGrid: (enabled) => set({ showGrid: enabled }),
            
            setSnapToGrid: (enabled) => set({ snapToGrid: enabled }),
            
            setSnapToObjects: (enabled: boolean) => set({ snapToObjects: enabled }),
            
            setShowConnectionPoints: (enabled: boolean) => set({ showConnectionPoints: enabled }),
            
            setGridSize: (size) => set({ gridSize: size }),
            
            setGridMesh: (mesh) => set({ gridMesh: mesh }),
            
            setCollisionDetectionEnabled: (enabled) => set({ collisionDetectionEnabled: enabled }),
            
            setObjectVisibility: (objectId, visible) => set((state) => ({
                objectVisibility: { ...state.objectVisibility, [objectId]: visible }
            })),
            
            setObjectLocked: (objectId, locked) => set((state) => ({
                objectLocked: { ...state.objectLocked, [objectId]: locked }
            })),
            
            setTessellationQuality: (objectId, quality) => set((state) => ({
                tessellationQuality: { ...state.tessellationQuality, [objectId]: quality }
            })),
            
            updateTessellationQuality: (updates) => set((state) => ({
                tessellationQuality: { ...state.tessellationQuality, ...updates }
            })),
            
            setControlPointVisualizations: (visualizations) => set({ controlPointVisualizations: visualizations }),
            
            addControlPointVisualization: (visualization) => set((state) => ({
                controlPointVisualizations: [
                    ...state.controlPointVisualizations.filter(viz => viz.objectId !== visualization.objectId),
                    visualization
                ]
            })),
            
            removeControlPointVisualization: (objectId) => set((state) => ({
                controlPointVisualizations: state.controlPointVisualizations.filter(viz => viz.objectId !== objectId)
            })),
            
            updateControlPointVisualization: (objectId, updates) => set((state) => ({
                controlPointVisualizations: state.controlPointVisualizations.map(viz =>
                    viz.objectId === objectId ? { ...viz, ...updates } : viz
                )
            })),
            
            setSelectedControlPointIndex: (index) => set({ selectedControlPointIndex: index }),
            
            setSelectedControlPointMesh: (mesh) => set({ selectedControlPointMesh: mesh }),
            
            setActiveDropdown: (dropdown) => set({ activeDropdown: dropdown }),
            
            setSidebarCollapsed: (collapsed) => set({ sidebarCollapsed: collapsed }),
            
            setIsLoading: (loading) => set({ isLoading: loading }),
            
            setApiKey: (key) => set({ apiKey: key }),
            
            setShowApiKeyInput: (show) => set({ showApiKeyInput: show }),
            
            addToResponseLog: (message) => set((state) => ({
                responseLog: [...state.responseLog, message]
            })),
            
            setResponseLog: (log) => set({ responseLog: log }),
            
            setSceneInitialized: (initialized) => set({ sceneInitialized: initialized }),
            
            setTextInput: (text) => set({ textInput: text }),
            
            // GLB Import actions
            startImport: () => set({ isImporting: true, importError: null }),
            importSuccess: () => set({ isImporting: false }),
            setImportError: (error) => set({ isImporting: false, importError: error }),
            clearImportError: () => set({ importError: null }),
            
            // Texture actions
            setTextureAssets: (assets) => set({ textureAssets: assets }),
            addTextureAsset: (asset) => set((state) => ({
                textureAssets: new Map([...state.textureAssets, [asset.id, asset]])
            })),
            removeTextureAsset: (assetId) => set((state) => {
                const newAssets = new Map(state.textureAssets);
                newAssets.delete(assetId);
                return { textureAssets: newAssets };
            }),
            renameTextureAsset: (assetId, newName) => set((state) => {
                const newAssets = new Map(state.textureAssets);
                const asset = newAssets.get(assetId);
                if (asset) {
                    asset.name = newName;
                }
                return { textureAssets: newAssets };
            }),
            setSelectedTextureId: (textureId) => set({ selectedTextureId: textureId }),
            setIsUploadingTexture: (uploading) => set({ isUploadingTexture: uploading }),
            setTextureUploadError: (error) => set({ textureUploadError: error }),
            
            uploadTexture: async (file) => {
                const state = get();
                
                // Generate texture ID
                const textureId = `texture-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                
                // Create texture asset (actual file processing will be handled by TextureManager)
                const textureAsset: TextureAsset = {
                    id: textureId,
                    name: file.name,
                    url: '', // Will be set by TextureManager
                    type: 'diffuse', // Default type
                    fileSize: file.size,
                    dimensions: { width: 0, height: 0 }, // Will be updated after loading
                    uploadedAt: Date.now()
                };
                
                // Add to store
                set((state) => ({
                    textureAssets: new Map([...state.textureAssets, [textureId, textureAsset]])
                }));
                
                return textureId;
            },
            
            applyTextureToObject: (objectId, textureId, textureType) => {
                set((state) => ({
                    sceneObjects: state.sceneObjects.map(obj => {
                        if (obj.id === objectId) {
                            return {
                                ...obj,
                                textureIds: {
                                    ...obj.textureIds,
                                    [textureType]: textureId
                                }
                            };
                        }
                        return obj;
                    })
                }));
            },
            
            removeTextureFromObject: (objectId, textureType) => {
                set((state) => ({
                    sceneObjects: state.sceneObjects.map(obj => {
                        if (obj.id === objectId && obj.textureIds) {
                            const newTextureIds = { ...obj.textureIds };
                            delete newTextureIds[textureType];
                            return {
                                ...obj,
                                textureIds: Object.keys(newTextureIds).length > 0 ? newTextureIds : undefined,
                                // Ensure color is included in the update for proper restoration
                                color: obj.color
                            };
                        }
                        return obj;
                    })
                }));
            },
            
            setTextureScale: (objectId, scale) => {
                set((state) => ({
                    sceneObjects: state.sceneObjects.map(obj => {
                        if (obj.id === objectId) {
                            return {
                                ...obj,
                                textureScale: scale
                            };
                        }
                        return obj;
                    })
                }));
            },
            
            setTextureOffset: (objectId, offset) => {
                set((state) => ({
                    sceneObjects: state.sceneObjects.map(obj => {
                        if (obj.id === objectId) {
                            return {
                                ...obj,
                                textureOffset: offset
                            };
                        }
                        return obj;
                    })
                }));
            },
            
            loadDefaultTextures: async () => {
                const state = get();
                if (state.defaultTexturesLoaded) {
                    return; // Already loaded
                }
                
                // Lazy import to avoid circular dependencies
                const { getAllDefaultTextures } = await import('../config/defaultTextures');
                const defaultTextures = getAllDefaultTextures();
                
                // Add default textures to the store
                const newTextureAssets = new Map(state.textureAssets);
                defaultTextures.forEach(texture => {
                    newTextureAssets.set(texture.id, texture);
                });
                
                set({ 
                    textureAssets: newTextureAssets,
                    defaultTexturesLoaded: true
                });
                
                console.log(`‚úÖ Loaded ${defaultTextures.length} default textures`);
            },
            
            // Housing-specific actions
            addHousingComponent: (objectId, housingObject) => set((state) => ({
                housingComponents: { ...state.housingComponents, [objectId]: housingObject }
            })),
            
            removeHousingComponent: (objectId) => set((state) => {
                const newComponents = { ...state.housingComponents };
                delete newComponents[objectId];
                return { housingComponents: newComponents };
            }),
            
            updateHousingComponent: (objectId, updates) => set((state) => ({
                housingComponents: {
                    ...state.housingComponents,
                    [objectId]: { ...state.housingComponents[objectId], ...updates }
                }
            })),
            
            addDoor: (objectId, wallId, door) => {
                const state = get();
                const housing = state.housingComponents[objectId];
                if (!housing) return '';
                
                const wall = housing.walls.find(w => w.id === wallId);
                if (!wall) return '';
                
                const doorId = `door-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                const newDoor: Door = { ...door, id: doorId, wallId };
                
                wall.doors.push(newDoor);
                housing.doors.push(newDoor);
                
                set((state) => ({
                    housingComponents: {
                        ...state.housingComponents,
                        [objectId]: housing
                    }
                }));
                
                return doorId;
            },
            
            removeDoor: (objectId, doorId) => set((state) => {
                const housing = state.housingComponents[objectId];
                if (!housing) return state;
                
                const door = housing.doors.find(d => d.id === doorId);
                if (!door) return state;
                
                const wall = housing.walls.find(w => w.id === door.wallId);
                if (wall) {
                    wall.doors = wall.doors.filter(d => d.id !== doorId);
                }
                
                housing.doors = housing.doors.filter(d => d.id !== doorId);
                
                return {
                    housingComponents: {
                        ...state.housingComponents,
                        [objectId]: housing
                    }
                };
            }),
            
            updateDoor: (objectId, doorId, updates) => set((state) => {
                const housing = state.housingComponents[objectId];
                if (!housing) return state;
                
                const door = housing.doors.find(d => d.id === doorId);
                if (!door) return state;
                
                const wall = housing.walls.find(w => w.id === door.wallId);
                if (wall) {
                    const wallDoor = wall.doors.find(d => d.id === doorId);
                    if (wallDoor) {
                        Object.assign(wallDoor, updates);
                    }
                }
                
                Object.assign(door, updates);
                
                return {
                    housingComponents: {
                        ...state.housingComponents,
                        [objectId]: housing
                    }
                };
            }),
            
            addWindow: (objectId, wallId, window) => {
                const state = get();
                const housing = state.housingComponents[objectId];
                if (!housing) return '';
                
                const wall = housing.walls.find(w => w.id === wallId);
                if (!wall) return '';
                
                const windowId = `window-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                const newWindow: Window = { ...window, id: windowId, wallId };
                
                wall.windows.push(newWindow);
                housing.windows.push(newWindow);
                
                set((state) => ({
                    housingComponents: {
                        ...state.housingComponents,
                        [objectId]: housing
                    }
                }));
                
                return windowId;
            },
            
            removeWindow: (objectId, windowId) => set((state) => {
                const housing = state.housingComponents[objectId];
                if (!housing) return state;
                
                const window = housing.windows.find(w => w.id === windowId);
                if (!window) return state;
                
                const wall = housing.walls.find(w => w.id === window.wallId);
                if (wall) {
                    wall.windows = wall.windows.filter(w => w.id !== windowId);
                }
                
                housing.windows = housing.windows.filter(w => w.id !== windowId);
                
                return {
                    housingComponents: {
                        ...state.housingComponents,
                        [objectId]: housing
                    }
                };
            }),
            
            updateWindow: (objectId, windowId, updates) => set((state) => {
                const housing = state.housingComponents[objectId];
                if (!housing) return state;
                
                const window = housing.windows.find(w => w.id === windowId);
                if (!window) return state;
                
                const wall = housing.walls.find(w => w.id === window.wallId);
                if (wall) {
                    const wallWindow = wall.windows.find(w => w.id === windowId);
                    if (wallWindow) {
                        Object.assign(wallWindow, updates);
                    }
                }
                
                Object.assign(window, updates);
                
                return {
                    housingComponents: {
                        ...state.housingComponents,
                        [objectId]: housing
                    }
                };
            }),
            
            changeWallThickness: (objectId, thickness, wallId) => set((state) => {
                const housing = state.housingComponents[objectId];
                if (!housing) return state;
                
                if (wallId) {
                    const wall = housing.walls.find(w => w.id === wallId);
                    if (wall) {
                        wall.thickness = thickness;
                    }
                } else {
                    housing.walls.forEach(wall => {
                        wall.thickness = thickness;
                    });
                    housing.wallThickness = thickness;
                }
                
                return {
                    housingComponents: {
                        ...state.housingComponents,
                        [objectId]: housing
                    }
                };
            }),
            
            toggleCeiling: (objectId, hasCeiling) => set((state) => {
                const housing = state.housingComponents[objectId];
                if (!housing) return state;
                
                housing.hasCeiling = hasCeiling;
                
                return {
                    housingComponents: {
                        ...state.housingComponents,
                        [objectId]: housing
                    }
                };
            }),
            
            toggleFloor: (objectId, hasFloor) => set((state) => {
                const housing = state.housingComponents[objectId];
                if (!housing) return state;
                
                housing.hasFloor = hasFloor;
                
                return {
                    housingComponents: {
                        ...state.housingComponents,
                        [objectId]: housing
                    }
                };
            }),
            
            addBuildingConnection: (connection) => {
                const connectionId = `connection-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                const newConnection: BuildingConnection = { ...connection, id: connectionId };
                
                set((state) => ({
                    buildingConnections: [...state.buildingConnections, newConnection]
                }));
                
                return connectionId;
            },
            
            removeBuildingConnection: (connectionId) => set((state) => ({
                buildingConnections: state.buildingConnections.filter(conn => conn.id !== connectionId)
            })),
            
            updateBuildingConnection: (connectionId, updates) => set((state) => ({
                buildingConnections: state.buildingConnections.map(conn =>
                    conn.id === connectionId ? { ...conn, ...updates } : conn
                )
            })),
            
            executeHousingOperation: (objectId, operation) => {
                const actions = get();
                
                switch (operation.type) {
                    case 'add-door':
                        actions.addDoor(objectId, operation.wallId, operation.door);
                        break;
                    case 'remove-door':
                        actions.removeDoor(objectId, operation.doorId);
                        break;
                    case 'add-window':
                        actions.addWindow(objectId, operation.wallId, operation.window);
                        break;
                    case 'remove-window':
                        actions.removeWindow(objectId, operation.windowId);
                        break;
                    case 'change-wall-thickness':
                        actions.changeWallThickness(objectId, operation.thickness, operation.wallId);
                        break;
                    case 'toggle-ceiling':
                        actions.toggleCeiling(objectId, operation.hasCeiling);
                        break;
                    case 'toggle-floor':
                        actions.toggleFloor(objectId, operation.hasFloor);
                        break;
                    case 'connect-buildings':
                        actions.addBuildingConnection(operation.connection);
                        break;
                    case 'disconnect-buildings':
                        actions.removeBuildingConnection(operation.connectionId);
                        break;
                }
            },
            
            setSelectedWallId: (wallId) => set({ selectedWallId: wallId }),
            
            setSelectedDoorId: (doorId) => set({ selectedDoorId: doorId }),
            
            setSelectedWindowId: (windowId) => set({ selectedWindowId: windowId }),
            
            setHousingEditMode: (mode) => set({ housingEditMode: mode }),
            
            // Housing-specific getters
            getHousingComponent: (objectId) => {
                const state = get();
                return state.housingComponents[objectId];
            },
            
            getSelectedWall: (objectId) => {
                const state = get();
                const housing = state.housingComponents[objectId];
                if (!housing || !state.selectedWallId) return undefined;
                return housing.walls.find(w => w.id === state.selectedWallId);
            },
            
            getSelectedDoor: (objectId) => {
                const state = get();
                const housing = state.housingComponents[objectId];
                if (!housing || !state.selectedDoorId) return undefined;
                return housing.doors.find(d => d.id === state.selectedDoorId);
            },
            
            getSelectedWindow: (objectId) => {
                const state = get();
                const housing = state.housingComponents[objectId];
                if (!housing || !state.selectedWindowId) return undefined;
                return housing.windows.find(w => w.id === state.selectedWindowId);
            },
            
            getBuildingConnections: (objectId) => {
                const state = get();
                return state.buildingConnections.filter(conn => 
                    conn.fromObjectId === objectId || conn.toObjectId === objectId
                );
            },
            
            // Computed getters
            getSelectedObject: () => {
                const state = get()
                return state.sceneObjects.find(obj => obj.id === state.selectedObjectId)
            },
            
            getSelectedObjects: () => {
                const state = get()
                return state.sceneObjects.filter(obj => state.selectedObjectIds.includes(obj.id))
            },
            
            hasSelection: () => {
                const state = get()
                return state.selectedObjectId !== null || state.selectedObjectIds.length > 0
            },
            
            getSelectableObjects: () => {
                const state = get()
                return state.sceneObjects.filter(obj => 
                    obj.type !== 'ground' && !state.objectLocked[obj.id]
                )
            },
            
            isObjectSelected: (objectId) => {
                const state = get()
                return state.selectedObjectId === objectId || state.selectedObjectIds.includes(objectId)
            },
            
            isObjectVisible: (objectId) => {
                const state = get()
                return state.objectVisibility[objectId] !== false
            },
            
            isObjectLocked: (objectId) => {
                const state = get()
                return state.objectLocked[objectId] === true
            }
        }),
        {
            name: 'scene-store',
            partialize: (state: SceneState & SceneActions) => ({
                // Persist only non-Babylon.js objects to avoid serialization issues
                currentColor: state.currentColor,
                wireframeMode: state.wireframeMode,
                showGrid: state.showGrid,
                snapToGrid: state.snapToGrid,
                gridSize: state.gridSize,
                sidebarCollapsed: state.sidebarCollapsed,
                apiKey: state.apiKey,
                showApiKeyInput: state.showApiKeyInput,
                transformMode: state.transformMode,
                multiSelectMode: state.multiSelectMode,
                collisionDetectionEnabled: state.collisionDetectionEnabled
            })
        }
    )
)

// Export types for use in components
export type { 
    SceneState, 
    SceneActions, 
    SceneObject, 
    ControlPointVisualization, 
    TransformMode, 
    PrimitiveType,
    ModularHousingObject,
    BuildingConnection,
    HousingOperation,
    Door,
    Window,
    Wall,
    ImportError,
    TextureAsset,
    TextureType
}
</file>

<file path="src/components/sidebar/AISidebar.tsx">
import React from 'react';
import { Vector3 } from 'babylonjs';
import { useSceneStore } from '../../state/sceneStore';
import { createAIService, type SceneCommand } from '../../ai/ai.service';
import type { SceneObject } from '../../types/types';
import { SceneGraph } from './SceneGraph';
import { PropertiesPanel } from './PropertiesPanel';
import { ImportButton } from './ImportButton';
import { ExportButton } from './ExportButton';
import { createGLBImporter } from '../../babylon/glbImporter';
import { createSTLExporter } from '../../babylon/stlExporter';

interface AISidebarProps {
  apiKey: string;
  sceneInitialized: boolean;
  sceneAPI?: {
    getSceneManager: () => any;
  };
}

export const AISidebar: React.FC<AISidebarProps> = ({ 
  apiKey, 
  sceneInitialized,
  sceneAPI 
}) => {
  const {
    sidebarCollapsed,
    isLoading,
    textInput,
    responseLog,
    sceneObjects,
    importError,
    setSidebarCollapsed,
    setTextInput,
    setIsLoading,
    addToResponseLog,
    updateObject,
    addObject,
    removeObject,
    startImport,
    importSuccess,
    setImportError,
    clearImportError,
  } = useSceneStore();

  /**
   * Synchronize object positions from the actual 3D meshes to the store
   * This ensures we have the most current positions before AI analysis
   */
  const syncPositionsFromMeshes = () => {
    if (!sceneAPI || !sceneInitialized) return;

    const sceneManager = sceneAPI.getSceneManager();
    if (!sceneManager) return;

    console.log('üîÑ Syncing positions from 3D meshes to store...');
    
    sceneObjects.forEach(obj => {
      if (obj.type === 'ground') return; // Skip ground
      
      const mesh = sceneManager.getMeshById(obj.id);
      if (mesh) {
        const meshPosition = mesh.position;
        const meshRotation = mesh.rotation;
        const meshScale = mesh.scaling;
        
        // Check if the mesh position differs from store position
        const positionDiff = !obj.position.equals(meshPosition);
        const rotationDiff = !obj.rotation.equals(meshRotation);
        const scaleDiff = !obj.scale.equals(meshScale);
        
        if (positionDiff || rotationDiff || scaleDiff) {
          console.log(`  - Updating ${obj.id}: mesh pos (${meshPosition.x.toFixed(2)}, ${meshPosition.y.toFixed(2)}, ${meshPosition.z.toFixed(2)}) vs store pos (${obj.position.x.toFixed(2)}, ${obj.position.y.toFixed(2)}, ${obj.position.z.toFixed(2)})`);
          
          updateObject(obj.id, {
            position: meshPosition.clone(),
            rotation: meshRotation.clone(),
            scale: meshScale.clone()
          });
        }
      }
    });
  };

  const performAlignment = (command: SceneCommand, sceneManager: any) => {
    if (!command.objectId || !command.relativeToObject || !command.edge) return;

    // Get both meshes
    const movingMesh = sceneManager.getMeshById(command.objectId);
    const referenceMesh = sceneManager.getMeshById(command.relativeToObject);
    
    if (!movingMesh || !referenceMesh) {
      console.error('Could not find meshes for alignment:', command.objectId, command.relativeToObject);
      return;
    }

    // Get bounding info for both objects
    const movingBounds = movingMesh.getBoundingInfo();
    const referenceBounds = referenceMesh.getBoundingInfo();
    
    if (!movingBounds || !referenceBounds) {
      console.error('Could not get bounding info for alignment');
      return;
    }

    console.log(`üîß Starting alignment: ${command.objectId} to ${command.edge} edge of ${command.relativeToObject}`);

    // Ensure world matrices are up to date
    referenceMesh.computeWorldMatrix(true);
    movingMesh.computeWorldMatrix(true);

    // Calculate reference object dimensions and position in world space
    const refMin = referenceBounds.boundingBox.minimumWorld;
    const refMax = referenceBounds.boundingBox.maximumWorld;
    const refCenter = referenceBounds.boundingBox.center;
    
    console.log(`üìê Reference bounds: min(${refMin.x.toFixed(2)}, ${refMin.y.toFixed(2)}, ${refMin.z.toFixed(2)}) max(${refMax.x.toFixed(2)}, ${refMax.y.toFixed(2)}, ${refMax.z.toFixed(2)})`);
    
    // Get the original (unrotated) dimensions of the moving object
    // We need these to calculate proper flush positioning after rotation
    const movingLocalBounds = movingBounds.boundingBox;
    const movingLocalSize = movingLocalBounds.maximum.subtract(movingLocalBounds.minimum);
    const originalWidth = movingLocalSize.x;   // 4.0 for wall
    const originalHeight = movingLocalSize.y;  // 1.5 for wall  
    const originalDepth = movingLocalSize.z;   // 0.2 for wall
    
    console.log(`üìê Moving object original dimensions: ${originalWidth.toFixed(2)} x ${originalHeight.toFixed(2)} x ${originalDepth.toFixed(2)}`);

    const targetPosition = new Vector3();
    const targetRotation = new Vector3(0, 0, 0); // Start with zero rotation
    const offset = command.offset || 0;

    // Calculate position and rotation based on edge
    // For walls, we want them to sit ON the floor, not float above it
    const wallBottomY = refMax.y; // Floor top surface
    const wallCenterY = wallBottomY + (originalHeight / 2); // Wall center Y position
    
    switch (command.edge) {
      case 'north': // +Z direction - wall faces north, extends in X direction
        targetPosition.x = refCenter.x;
        targetPosition.y = wallCenterY;
        targetPosition.z = refMax.z + (originalDepth / 2) + offset; // Wall thickness/2 for flush contact
        targetRotation.x = 0;
        targetRotation.y = 0; // No rotation - wall naturally extends in X direction
        targetRotation.z = 0;
        console.log(`üß≠ North alignment: placing at Z=${refMax.z.toFixed(2)} + ${(originalDepth/2).toFixed(2)} + ${offset} = ${targetPosition.z.toFixed(2)}, Y=${wallCenterY.toFixed(2)}`);
        break;
        
      case 'south': // -Z direction - wall faces south, extends in X direction
        targetPosition.x = refCenter.x;
        targetPosition.y = wallCenterY;
        targetPosition.z = refMin.z - (originalDepth / 2) - offset; // Wall thickness/2 for flush contact
        targetRotation.x = 0;
        targetRotation.y = Math.PI; // 180¬∞ rotation to face south
        targetRotation.z = 0;
        console.log(`üß≠ South alignment: placing at Z=${refMin.z.toFixed(2)} - ${(originalDepth/2).toFixed(2)} - ${offset} = ${targetPosition.z.toFixed(2)}, Y=${wallCenterY.toFixed(2)}`);
        break;
        
      case 'east': // +X direction - wall faces east, extends in Z direction
        targetPosition.x = refMax.x + (originalDepth / 2) + offset; // Wall thickness/2 for flush contact
        targetPosition.y = wallCenterY;
        targetPosition.z = refCenter.z;
        targetRotation.x = 0;
        targetRotation.y = -Math.PI / 2; // -90¬∞ rotation to face east
        targetRotation.z = 0;
        console.log(`üß≠ East alignment: placing at X=${refMax.x.toFixed(2)} + ${(originalDepth/2).toFixed(2)} + ${offset} = ${targetPosition.x.toFixed(2)}, Y=${wallCenterY.toFixed(2)}`);
        break;
        
      case 'west': // -X direction - wall faces west, extends in Z direction
        targetPosition.x = refMin.x - (originalDepth / 2) - offset; // Wall thickness/2 for flush contact
        targetPosition.y = wallCenterY;
        targetPosition.z = refCenter.z;
        targetRotation.x = 0;
        targetRotation.y = Math.PI / 2; // +90¬∞ rotation to face west
        targetRotation.z = 0;
        console.log(`üß≠ West alignment: placing at X=${refMin.x.toFixed(2)} - ${(originalDepth/2).toFixed(2)} - ${offset} = ${targetPosition.x.toFixed(2)}, Y=${wallCenterY.toFixed(2)}`);
        break;
    }

    console.log(`üéØ Target position: (${targetPosition.x.toFixed(2)}, ${targetPosition.y.toFixed(2)}, ${targetPosition.z.toFixed(2)})`);
    console.log(`üéØ Target rotation: (${targetRotation.x.toFixed(2)}, ${targetRotation.y.toFixed(2)}, ${targetRotation.z.toFixed(2)})`);

    // Apply the transformation directly without snap correction
    // (snap correction was interfering with precise alignment)
    updateObject(command.objectId, {
      position: targetPosition,
      rotation: targetRotation
    });

    console.log(`‚úÖ Aligned ${command.objectId} to ${command.edge} edge of ${command.relativeToObject}`);
  };

  const executeSceneCommand = (command: SceneCommand) => {
    if (!sceneInitialized) return;
    
    try {
      switch (command.action) {
        case 'move':
          if (command.objectId) {
            updateObject(command.objectId, { 
              position: new Vector3(command.x || 0, command.y || 0, command.z || 0) 
            });
          }
          break;

        case 'color':
          if (command.objectId) {
            updateObject(command.objectId, { color: command.color || '#3498db' });
          }
          break;

        case 'scale':
          if (command.objectId) {
            // Handle both old format (x, y, z) and new format (scaleX, scaleY, scaleZ)
            const scaleX = command.scaleX || command.x || 1;
            const scaleY = command.scaleY || command.y || 1;
            const scaleZ = command.scaleZ || command.z || 1;
            
            updateObject(command.objectId, { 
              scale: new Vector3(scaleX, scaleY, scaleZ) 
            });
          }
          break;

        case 'rotate':
          if (command.objectId) {
            // Rotation values are in radians
            const rotationX = command.rotationX || 0;
            const rotationY = command.rotationY || 0;
            const rotationZ = command.rotationZ || 0;
            
            updateObject(command.objectId, { 
              rotation: new Vector3(rotationX, rotationY, rotationZ) 
            });
            
            console.log(`üîÑ Rotated object ${command.objectId} to (${rotationX.toFixed(3)}, ${rotationY.toFixed(3)}, ${rotationZ.toFixed(3)}) radians`);
          }
          break;

        case 'create':
          if (command.type) {
            // Generate a robust unique ID (avoids same-millisecond collisions when executing multiple creates at once)
            const newId = `${command.type}-${typeof crypto !== 'undefined' && crypto.randomUUID ? crypto.randomUUID() : Date.now()}`;
            const newObj: SceneObject = {
              id: newId,
              type: command.type,
              position: new Vector3(command.x || 0, command.y || 1, command.z || 0),
              scale: new Vector3(1, 1, 1),
              rotation: new Vector3(0, 0, 0),
              color: command.color || (command.type.startsWith('house-') ? '#8B4513' : '#3498db'),
              isNurbs: false
            };
            
            addObject(newObj);
            
            // If the command includes scaling information, apply it immediately
            if (command.scaleX || command.scaleY || command.scaleZ) {
              const scaleX = command.scaleX || 1;
              const scaleY = command.scaleY || 1;
              const scaleZ = command.scaleZ || 1;
              
              // Update with scale - use a small timeout to ensure object is created first
              setTimeout(() => {
                updateObject(newId, { 
                  scale: new Vector3(scaleX, scaleY, scaleZ) 
                });
              }, 10);
            }
            
            // Log creation with enhanced details
            console.log(`‚úÖ Created object: ${newId} at (${command.x}, ${command.y}, ${command.z})`, {
              matchDimensions: command.matchDimensions,
              contactType: command.contactType,
              relativeToObject: command.relativeToObject,
              spatialRelation: command.spatialRelation
            });
          }
          break;

        case 'delete':
          if (command.objectId) {
            console.log('Deleting object with ID:', command.objectId);
            removeObject(command.objectId);
          }
          break;

        case 'align':
          if (command.objectId && command.relativeToObject && command.edge && sceneAPI) {
            const sceneManager = sceneAPI.getSceneManager();
            if (sceneManager) {
              performAlignment(command, sceneManager);
            }
          }
          break;
      }
    } catch (error) {
      console.error('Error executing scene command:', error);
    }
  };

  const handleImportGLB = async (file: File) => {
    if (!sceneInitialized || !sceneAPI) {
      console.error('Scene not initialized');
      return;
    }

    const sceneManager = sceneAPI.getSceneManager();
    if (!sceneManager || !sceneManager.scene) {
      console.error('Scene manager not available');
      return;
    }

    // Clear any previous import error
    clearImportError();
    
    // Start the import process
    startImport();

    try {
      // Create model importer with scene and sceneManager
      const importer = createGLBImporter(sceneManager.scene, sceneManager);
      
      // Import the file
      const sceneObject = await importer.importModel(file);
      
      // Add the imported object to the scene
      addObject(sceneObject);
      
      // Success!
      importSuccess();
      addToResponseLog(`Success: Imported 3D model "${file.name}"`);
      
    } catch (error: any) {
      console.error('Import failed:', error);
      
      // Set the import error based on the error message
      let errorType: 'FILE_TOO_LARGE' | 'INVALID_FORMAT' | 'LOADING_FAILED' = 'LOADING_FAILED';
      
      if (error instanceof Error) {
        if (error.message === 'FILE_TOO_LARGE') {
          errorType = 'FILE_TOO_LARGE';
        } else if (error.message === 'INVALID_FORMAT') {
          errorType = 'INVALID_FORMAT';
        }
      }
      
      setImportError({
        type: errorType,
        message: 'IMPORT FAILED'
      });
      
      addToResponseLog('Error: IMPORT FAILED');
    }
  };

  const handleExportSTL = async () => {
    if (!sceneInitialized || !sceneAPI) {
      console.error('Scene not initialized');
      return;
    }

    const sceneManager = sceneAPI.getSceneManager();
    if (!sceneManager || !sceneManager.scene) {
      console.error('Scene manager not available');
      return;
    }

    try {
      // Create STL exporter
      const exporter = createSTLExporter(sceneManager.scene);
      
      // Generate filename with timestamp
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
      const filename = `vibecad-export-${timestamp}.stl`;
      
      // Export the scene
      await exporter.exportSceneToSTL(sceneObjects, filename);
      
      // Success!
      addToResponseLog(`Success: Exported scene to "${filename}"`);
      
    } catch (error: any) {
      console.error('Export failed:', error);
      addToResponseLog(`Error: Export failed - ${error.message || 'Unknown error'}`);
    }
  };

  const handleSubmitPrompt = async () => {
    if (!apiKey || !textInput.trim()) return;

    setIsLoading(true);
    
    try {
      // Ensure we have the most current positions from the 3D meshes
      syncPositionsFromMeshes();
      
      // Give a brief moment for the store to update
      await new Promise(resolve => setTimeout(resolve, 50));
      
      // Get the updated scene objects
      const currentSceneObjects = useSceneStore.getState().sceneObjects;
      
      // Debug: Log current scene objects before AI call
      console.log('üîç Current scene objects at AI call time:');
      currentSceneObjects.forEach(obj => {
        console.log(`  - ${obj.id} (${obj.type}): position (${obj.position.x.toFixed(2)}, ${obj.position.y.toFixed(2)}, ${obj.position.z.toFixed(2)})`);
      });

      const aiService = createAIService(apiKey);
      const result = await aiService.getSceneCommands(textInput, currentSceneObjects);
      
      if (result.success && result.commands) {
        // Log the user prompt and AI response
        if (result.userPrompt) {
          addToResponseLog(`User: ${result.userPrompt}`);
        }
        if (result.aiResponse) {
          addToResponseLog(`AI: ${result.aiResponse}`);
        }
        
        // Execute all commands
        console.log('Executing commands:', result.commands);
        result.commands.forEach(command => executeSceneCommand(command));
      } else {
        // Log error
        const errorMessage = result.error || 'Unknown error occurred';
        console.error('AI service error:', errorMessage);
        addToResponseLog(`Error: ${errorMessage}`);
        
        if (result.userPrompt) {
          addToResponseLog(`User: ${result.userPrompt}`);
        }
        if (result.aiResponse) {
          addToResponseLog(`AI: ${result.aiResponse}`);
        }
      }
    } catch (error) {
      console.error('Error in AI service:', error);
      addToResponseLog(`Error: ${error instanceof Error ? error.message : 'Unknown error'}`);
    } finally {
      setIsLoading(false);
      setTextInput('');
    }
  };

  return (
    <div className={`ai-sidebar ${sidebarCollapsed ? 'collapsed' : ''}`}>
      <div className="ai-sidebar-header">
        <h3>AI Assistant</h3>
        <button 
          className="sidebar-toggle"
          onClick={() => setSidebarCollapsed(!sidebarCollapsed)}
          title={sidebarCollapsed ? 'Expand sidebar' : 'Collapse sidebar'}
        >
          {sidebarCollapsed ? '‚óÄ' : '‚ñ∂'}
        </button>
      </div>
      
      {!sidebarCollapsed && (
        <div className="ai-sidebar-content">
          {!sceneInitialized && (
            <div className="loading-indicator">
              <p>Initializing 3D scene...</p>
            </div>
          )}
          
          {/* AI Control Group */}
          <div className="ai-control-group">
            <label htmlFor="ai-prompt">Natural Language Commands:</label>
            <textarea
              id="ai-prompt"
              value={textInput}
              onChange={(e) => setTextInput(e.target.value)}
              placeholder="Try: 'move the cube to the right', 'make the cube blue', 'create a red sphere above the cube'"
              className="ai-text-input"
              disabled={isLoading || !sceneInitialized}
            />
            <button 
              onClick={handleSubmitPrompt}
              disabled={isLoading || !textInput.trim() || !sceneInitialized}
              className="ai-submit-button"
            >
              {isLoading ? 'Processing...' : 'Execute AI Command'}
            </button>
          </div>

          {/* Import GLB Control */}
          <div className="ai-control-group">
            <label>Import 3D Model:</label>
            <ImportButton 
              onImport={handleImportGLB}
              disabled={!sceneInitialized}
            />
            {importError && (
              <div className="import-error-message">
                {importError.message}
              </div>
            )}
          </div>

          {/* Export STL Control */}
          <div className="ai-control-group">
            <label>Export Scene:</label>
            <ExportButton
              onExport={handleExportSTL}
              disabled={!sceneInitialized}
              objectCount={sceneObjects.filter(obj => obj.type !== 'ground').length}
            />
          </div>

          {/* Scene Graph Component */}
          <SceneGraph />

          {/* Properties Panel Component */}
          <PropertiesPanel />

          {/* Keyboard Shortcuts */}
          <div className="ai-control-group">
            <label>Keyboard Shortcuts:</label>
            <div className="keyboard-shortcuts">
              <div className="shortcut-item">
                <span className="shortcut-key">Ctrl+A</span>
                <span className="shortcut-desc">Select All</span>
              </div>
              <div className="shortcut-item">
                <span className="shortcut-key">Ctrl+I</span>
                <span className="shortcut-desc">Invert Selection</span>
              </div>
              <div className="shortcut-item">
                <span className="shortcut-key">Ctrl+D</span>
                <span className="shortcut-desc">Duplicate</span>
              </div>
              <div className="shortcut-item">
                <span className="shortcut-key">Ctrl+T</span>
                <span className="shortcut-desc">Reset Transform</span>
              </div>
              <div className="shortcut-item">
                <span className="shortcut-key">Ctrl+G</span>
                <span className="shortcut-desc">Toggle Snap to Grid</span>
              </div>
              <div className="shortcut-item">
                <span className="shortcut-key">M</span>
                <span className="shortcut-desc">Move Mode</span>
              </div>
              <div className="shortcut-item">
                <span className="shortcut-key">R</span>
                <span className="shortcut-desc">Rotate Mode</span>
              </div>
              <div className="shortcut-item">
                <span className="shortcut-key">S</span>
                <span className="shortcut-desc">Scale Mode</span>
              </div>
              <div className="shortcut-item">
                <span className="shortcut-key">Delete</span>
                <span className="shortcut-desc">Delete Selected</span>
              </div>
              <div className="shortcut-item">
                <span className="shortcut-key">Esc</span>
                <span className="shortcut-desc">Deselect All</span>
              </div>
            </div>
          </div>

          {/* AI Response Log */}
          <div className="ai-control-group">
            <label>AI Response Log:</label>
            <div className="ai-response-log">
              {responseLog.slice(-8).map((log, index) => (
                <div key={index} className={`ai-log-entry ${log.startsWith('User:') ? 'user' : log.startsWith('AI:') ? 'ai' : 'error'}`}>
                  {log}
                </div>
              ))}
              {responseLog.length === 0 && (
                <div className="ai-log-entry ai-log-empty">
                  No AI responses yet. Try entering a command above.
                </div>
              )}
            </div>
          </div>
        </div>
      )}
    </div>
  );
};
</file>

<file path="src/types/types.ts">
import { Vector3, Vector2, Quaternion, Mesh } from 'babylonjs'

export type TransformMode = 'select' | 'move' | 'rotate' | 'scale'
export type PrimitiveType = 'cube' | 'sphere' | 'cylinder' | 'plane' | 'torus' | 'cone' | 'nurbs' | 
    'house-basic' | 'house-room' | 'house-hallway' | 'house-roof-flat' | 'house-roof-pitched' |
    'house-room-modular' | 'house-wall' | 'house-ceiling' | 'house-floor' |
    'house-door-single' | 'house-door-double' | 'house-door-sliding' | 'house-door-french' | 'house-door-garage' |
    'house-window-single' | 'house-window-double' | 'house-window-bay' | 'house-window-casement' | 'house-window-sliding' | 'house-window-skylight' |
    'house-stairs' | 'house-foundation' | 'imported-glb' | 'imported-stl' | 'imported-obj' | 'custom-room'

// Import error types
export type ImportErrorType = 'FILE_TOO_LARGE' | 'INVALID_FORMAT' | 'LOADING_FAILED'

export interface ImportError {
    type: ImportErrorType
    message: string
}

// Texture types
export type TextureType = 'diffuse' | 'normal' | 'specular' | 'emissive'

export interface TextureAsset {
    id: string
    name: string
    url: string
    type: TextureType
    fileSize: number
    dimensions: {
        width: number
        height: number
    }
    uploadedAt: number
}

// Housing component types
export type HousingComponentType = 'wall' | 'door' | 'window' | 'ceiling' | 'floor' | 'foundation'
export type DoorType = 'single' | 'double' | 'sliding' | 'french' | 'garage'
export type WindowType = 'single' | 'double' | 'bay' | 'casement' | 'sliding' | 'skylight'
export type WallType = 'interior' | 'exterior' | 'load-bearing' | 'partition'

// Door component interface
export interface Door {
    id: string
    type: DoorType
    width: number
    height: number
    thickness: number
    position: Vector3  // Position relative to the wall
    wallId: string     // ID of the wall this door belongs to
    isOpen: boolean
    openDirection: 'inward' | 'outward'
    hingeDirection: 'left' | 'right'
    color: string
    material?: string
}

// Window component interface
export interface Window {
    id: string
    type: WindowType
    width: number
    height: number
    position: Vector3  // Position relative to the wall
    wallId: string     // ID of the wall this window belongs to
    sillHeight: number // Height from floor to window sill
    hasFrame: boolean
    frameThickness: number
    color: string
    material?: string
    isOpen?: boolean   // For openable windows
}

// Wall component interface
export interface Wall {
    id: string
    type: WallType
    startPoint: Vector3
    endPoint: Vector3
    height: number
    thickness: number
    color: string
    material?: string
    doors: Door[]
    windows: Window[]
    isLoadBearing: boolean
    connectedWalls: string[]  // IDs of walls this wall connects to
}

// Housing component base interface
export interface HousingComponent {
    id: string
    type: HousingComponentType
    parentId: string  // ID of the parent housing object
    position: Vector3
    rotation: Vector3
    scale: Vector3
    color: string
    material?: string
    isVisible: boolean
    isLocked: boolean
}

// Ceiling features interface
export interface CeilingFeatures {
    hasLights?: boolean
    hasFan?: boolean
    hasSkylight?: boolean
    hasBeams?: boolean
}

// Floor features interface
export interface FloorFeatures {
    hasBaseboards?: boolean
    hasHeating?: boolean
    hasTransition?: boolean
}

// Modular housing object interface
export interface ModularHousingObject extends SceneObject {
    housingType: 'modular-room' | 'modular-house' | 'modular-building'
    wallThickness: number
    hasCeiling: boolean
    hasFloor: boolean
    hasFoundation: boolean
    walls: Wall[]
    doors: Door[]
    windows: Window[]
    ceilingHeight: number
    floorThickness: number
    foundationHeight: number
    buildingConnections: string[]  // IDs of other housing objects this connects to
    roomType?: 'bedroom' | 'kitchen' | 'bathroom' | 'living-room' | 'dining-room' | 'office' | 'hallway' | 'garage'
    
    // Enhanced ceiling properties
    ceilingType?: 'flat' | 'vaulted' | 'coffered' | 'tray' | 'cathedral' | 'beam'
    ceilingMaterial?: string
    ceilingThickness?: number
    ceilingFeatures?: CeilingFeatures
    
    // Enhanced floor properties
    floorMaterial?: string
    floorFeatures?: FloorFeatures
}

// Building connection interface
export interface BuildingConnection {
    id: string
    fromObjectId: string
    toObjectId: string
    fromWallId: string
    toWallId: string
    connectionType: 'door' | 'opening' | 'seamless'
    doorId?: string  // If connectionType is 'door'
    isActive: boolean
}

// Scene Object (preserving info after scene change)
export interface SceneObject {
    id: string
    type: string
    position: Vector3
    scale: Vector3
    rotation: Vector3
    color: string
    mesh?: Mesh
    isNurbs: boolean
    verbData?: {
      controlPoints: number[][][]
      knotsU: number[]
      knotsV: number[]
      degreeU: number
      degreeV: number
      weights?: number[][]
    }
    // Housing-specific properties (for backward compatibility)
    housingData?: ModularHousingObject

    /** Optional list of connection points used for snapping/alignment */
    connectionPoints?: ConnectionPoint[]
    
    // Texture properties
    textureIds?: {
        diffuse?: string
        normal?: string
        specular?: string
        emissive?: string
    }
    textureScale?: {
        u: number
        v: number
    }
    textureOffset?: {
        u: number
        v: number
    }
    
    // Room name for custom rooms
    roomName?: string
}

// NURBS control point visualization data
export interface ControlPointVisualization {
    objectId: string
    controlPointMeshes: Mesh[]
    selectedControlPointIndex: number | null
}

// Multi-select initial state for transform operations
export interface MultiSelectInitialState {
    position: Vector3
    rotation: Vector3
    scale: Vector3
    relativePosition: Vector3
}

// Material preset interface
export interface MaterialPreset {
    name: string
    color: string
}

// Material presets for quick color selection
export const materialPresets: MaterialPreset[] = [
    { name: 'Red', color: '#ff6b6b' },
    { name: 'Blue', color: '#4ecdc4' },
    { name: 'Green', color: '#95e1d3' },
    { name: 'Yellow', color: '#fce38a' },
    { name: 'Purple', color: '#a8e6cf' },
    { name: 'Orange', color: '#ffb347' },
    { name: 'Pink', color: '#ff8fab' },
    { name: 'Cyan', color: '#87ceeb' },
]

// Add after materialPresets definition or maybe before utility types
export interface ConnectionPoint {
    /** A unique id within the object */
    id: string
    /** Local-space position of the point (before world transform) */
    position: Vector3
    /** Local-space outward normal of the face this point belongs to. Used to orient snapping. */
    normal: Vector3
    /** Semantic kind of connector (face, edge, corner, custom) */
    kind?: 'face' | 'edge' | 'corner' | 'custom'
    /** Optional list of object primitive types that are allowed to connect to this point */
    allowedTypes?: string[]
    /** Optional priority (lower = preferred) when multiple snaps are possible */
    snapPriority?: number
}

/**
 * Axis-aligned / oriented bounding information used for snapping & stacking logic.
 */
export interface Boundary {
    /** Axis-aligned bounding box */
    aabb: {
        min: Vector3
        max: Vector3
        size: Vector3
        center: Vector3
    }
    /** Optional oriented bounding box */
    obb?: {
        center: Vector3
        halfSizes: Vector3
        orientation: Quaternion
    }
    /** Optional 2D footprint (projected on XZ plane) for advanced layout */
    footprint2D?: Vector2[]
}

// Utility types for housing operations
export type HousingOperation = 
  | { type: 'add-door', wallId: string, door: Omit<Door, 'id'> }
  | { type: 'remove-door', doorId: string }
  | { type: 'add-window', wallId: string, window: Omit<Window, 'id'> }
  | { type: 'remove-window', windowId: string }
  | { type: 'change-wall-thickness', wallId?: string, thickness: number }
  | { type: 'toggle-ceiling', hasCeiling: boolean }
  | { type: 'toggle-floor', hasFloor: boolean }
  | { type: 'connect-buildings', fromObjectId: string, toObjectId: string, connection: Omit<BuildingConnection, 'id'> }
  | { type: 'disconnect-buildings', connectionId: string }
</file>

<file path="src/babylon/hooks/useBabylonScene.ts">
import { useEffect, useRef, useMemo, useState } from 'react'
import { Vector3, Color3, PickingInfo, Matrix } from 'babylonjs'
import { SceneManager } from '../sceneManager'
import { useSceneStore } from '../../state/sceneStore'
import { useGizmoManager } from '../gizmoManager'
import type { SceneObject } from '../../types/types'

// Custom hook to get the previous value of a prop or state
function usePrevious<T>(value: T): T | undefined {
  const ref = useRef<T | undefined>(undefined)
  useEffect(() => {
    ref.current = value
  }, [value])
  return ref.current
}

export const useBabylonScene = (canvasRef: React.RefObject<HTMLCanvasElement | null>) => {
  const sceneManagerRef = useRef<SceneManager | null>(null)
  const sceneObjectsRef = useRef<SceneObject[]>([])
  const isInitializedRef = useRef(false)
  const [canvasAvailable, setCanvasAvailable] = useState(false)

  // Get all store state and actions
  const store = useSceneStore()
  const {
    sceneObjects,
    selectedObjectId,
    selectedObjectIds,
    transformMode,
    wireframeMode,
    snapToGrid,
    snapToObjects,
    showConnectionPoints,
    gridSize,
    showGrid,
    hoveredObjectId,
    objectVisibility,
    objectLocked,
    multiSelectPivot,
    multiSelectInitialStates,
    sceneInitialized,
    
    // Actions
    setSceneInitialized,
    setSelectedObjectId,
    setSelectedObjectIds,
    setHoveredObjectId,
    updateObject,
    setMultiSelectPivot,
    setMultiSelectInitialStates,
    setGridMesh,
    clearSelection
  } = store

  // Keep sceneObjectsRef synchronized with sceneObjects state for callbacks
  useEffect(() => {
    sceneObjectsRef.current = sceneObjects
  }, [sceneObjects])

  // Get the previous state of sceneObjects for diffing
  const prevSceneObjects = usePrevious(sceneObjects)

  // Watch for canvas ref changes and update canvasAvailable state
  useEffect(() => {
    const checkCanvas = () => {
      const canvas = canvasRef.current
      const hasCanvas = !!(canvas && canvas.offsetWidth > 0 && canvas.offsetHeight > 0 && canvas.isConnected)
      console.log('üîç Canvas availability check:', {
        hasCanvas,
        hasCanvasRef: !!canvas,
        offsetWidth: canvas?.offsetWidth,
        offsetHeight: canvas?.offsetHeight,
        isConnected: canvas?.isConnected,
        parentElement: canvas?.parentElement
      })
      setCanvasAvailable(hasCanvas)
    }

    // Check immediately
    checkCanvas()

    // If canvas is not available, check again after a short delay
    if (!canvasAvailable && canvasRef.current) {
      const timeoutId = setTimeout(() => {
        console.log('üîÑ Retrying canvas availability check...')
        checkCanvas()
      }, 100)
      return () => clearTimeout(timeoutId)
    }
  }, [canvasRef.current, canvasAvailable])

  // Initialize the scene manager when canvas is available
  useEffect(() => {
    // Prevent re-initialization
    if (isInitializedRef.current) {
      return
    }

    const intervalId = setInterval(() => {
      const canvas = canvasRef.current
      
      // Check if canvas is mounted and has dimensions
      if (canvas && canvas.offsetWidth > 0 && canvas.offsetHeight > 0) {
        clearInterval(intervalId)
        
        console.log('üöÄ Canvas is ready, initializing Babylon.js scene...')
        isInitializedRef.current = true
        const sceneManager = new SceneManager()
        
        if (sceneManager.initialize(canvas)) {
          sceneManagerRef.current = sceneManager
          
          // Expose for DevTools debugging
          if (typeof window !== 'undefined') {
            // @ts-ignore
            window.VibeCadSceneManager = sceneManager
            console.log('üêû VibeCadSceneManager is available on window for debugging')
          }
          
          console.log('‚úÖ SceneManager initialized, setting up callbacks...')
          
          // Set up event callbacks
          console.log('üîó Setting up object click callback')
          sceneManager.setObjectClickCallback(handleObjectClick)
          console.log('üîó Setting up object hover callback')
          sceneManager.setObjectHoverCallback(handleObjectHover)
          
          // Set up texture asset callback
          console.log('üîó Setting up texture asset callback')
          sceneManager.setTextureAssetCallback((textureId: string) => {
            const state = useSceneStore.getState()
            return state.textureAssets.get(textureId)
          })

          // Create initial scene objects - only ground, no cube
          const initialGround: SceneObject = {
            id: 'ground',
            type: 'ground',
            position: new Vector3(0, 0, 0),
            scale: new Vector3(10, 1, 10),
            rotation: new Vector3(0, 0, 0),
            color: '#808080',
            isNurbs: false
          }

          console.log('üé≤ Adding initial ground to scene...')
          
          // Add initial ground to the scene and store
          sceneManager.addMesh(initialGround)
          
          // Initialize store with initial ground only
          store.setSceneObjects([initialGround])
          
          setSceneInitialized(true)
          console.log('‚úÖ useBabylonScene initialized successfully')
        } else {
          console.error('‚ùå Failed to initialize SceneManager')
          isInitializedRef.current = false // Allow retry if initialization fails
        }
      } else {
        console.log('‚è≥ Canvas not ready yet, will check again...')
      }
    }, 100) // Poll every 100ms

    return () => {
      console.log('üßπ Cleaning up Babylon.js scene effect...')
      clearInterval(intervalId)
      if (sceneManagerRef.current) {
        sceneManagerRef.current.dispose()
        sceneManagerRef.current = null
      }
      isInitializedRef.current = false
      setSceneInitialized(false)
    }
  }, []) // Run this effect only once on mount

  // Handle object click events
  const handleObjectClick = (pickInfo: PickingInfo, isCtrlHeld: boolean = false) => {
    // Get fresh state from the store at the moment of the click to avoid stale closures
    const {
      sceneObjects,
      multiSelectMode,
      selectedObjectIds,
      isObjectLocked,
      setSelectedObjectId,
      setSelectedObjectIds,
      clearSelection,
    } = useSceneStore.getState();

    // If the click didn't hit anything, or didn't hit a mesh, clear selection
    // unless the user is holding control to multi-select.
    if (!pickInfo.hit || !pickInfo.pickedMesh) {
      if (!isCtrlHeld) {
        clearSelection();
      }
      return;
    }

    let pickedMesh = pickInfo.pickedMesh;
    // The clicked mesh may be a child mesh; walk up until we find a mesh whose
    // name matches one of our scene object IDs (or we reach the root).
    const sceneIds = new Set(sceneObjects.map(o => o.id))
    while (pickedMesh && !sceneIds.has(pickedMesh.name) && pickedMesh.parent) {
      pickedMesh = pickedMesh.parent as any;
    }

    const objectId = pickedMesh?.name;

    if (!objectId) {
      if (!isCtrlHeld) clearSelection();
      return;
    }

    const clickedObject = sceneObjects.find(obj => obj.id === objectId);

    // If we didn't find a corresponding object in our store, or if it's the ground,
    // or if the object is locked, clear the selection.
    if (!clickedObject || clickedObject.type === 'ground' || isObjectLocked(objectId)) {
      if (!isCtrlHeld) {
        clearSelection();
      }
      return;
    }

    // Handle selection logic based on the mode
    if (multiSelectMode || isCtrlHeld) {
      const isAlreadySelected = selectedObjectIds.includes(objectId);
      const newSelection = isAlreadySelected
        ? selectedObjectIds.filter(id => id !== objectId) // Deselect if already selected
        : [...selectedObjectIds, objectId]; // Add to selection
      
      setSelectedObjectIds(newSelection);
      setSelectedObjectId(null); // In multi-select, no single object is the "primary" selection
    } else {
      // Single selection mode ‚Äì first clear multi-selection, then set single selection
      setSelectedObjectIds([]);
      setSelectedObjectId(objectId);
    }
  }

  // Handle object hover events
  const handleObjectHover = (pickInfo: PickingInfo) => {
    // Get latest state directly from the store to prevent stale closures
    const state = useSceneStore.getState()

    if (pickInfo.hit && pickInfo.pickedMesh) {
      const hoveredObject = sceneObjectsRef.current.find(obj => obj.id === pickInfo.pickedMesh?.name)
      if (hoveredObject && hoveredObject.type !== 'ground') {
        setHoveredObjectId(hoveredObject.id)
        // Change cursor to pointer to indicate clickable
        if (canvasRef.current) {
          canvasRef.current.style.cursor = 'pointer'
        }
      } else {
        setHoveredObjectId(null)
        if (canvasRef.current) {
          canvasRef.current.style.cursor = 'default'
        }
      }
    } else {
      setHoveredObjectId(null)
      if (canvasRef.current) {
        canvasRef.current.style.cursor = 'default'
      }
    }
  }

  // Pointer events are now handled by the SceneManager's built-in system

  // Synchronize scene objects with store state by diffing
  useEffect(() => {
    if (!sceneManagerRef.current || !sceneInitialized) return

    const sceneManager = sceneManagerRef.current
    const currentObjectsMap = new Map(sceneObjects.map(obj => [obj.id, obj]))
    const prevObjectsMap = new Map(prevSceneObjects?.map(obj => [obj.id, obj]) || [])

    // Find added and updated objects
    currentObjectsMap.forEach((currentObj, id) => {
      const prevObj = prevObjectsMap.get(id)
      
      if (!prevObj) {
        // New object added
        console.log(`‚ûï Adding new mesh: ${id} (${currentObj.type})`)
        sceneManager.addMesh(currentObj)
      } else if (currentObj !== prevObj) {
        // Existing object updated, calculate a diff
        console.log(`üîÑ Updating existing mesh: ${id}`)
        const diff: Partial<SceneObject> = {}
        
        if (currentObj.position !== prevObj.position && !currentObj.position.equals(prevObj.position)) {
          diff.position = currentObj.position
        }
        if (currentObj.rotation !== prevObj.rotation && !currentObj.rotation.equals(prevObj.rotation)) {
          diff.rotation = currentObj.rotation
        }
        if (currentObj.scale !== prevObj.scale && !currentObj.scale.equals(prevObj.scale)) {
          diff.scale = currentObj.scale
        }
        if (currentObj.color !== prevObj.color) {
          diff.color = currentObj.color
        }
        
        // Check for texture changes
        if (JSON.stringify(currentObj.textureIds) !== JSON.stringify(prevObj.textureIds)) {
          diff.textureIds = currentObj.textureIds
          // When textures are removed, also include the color to restore it
          if (!currentObj.textureIds || Object.keys(currentObj.textureIds).length === 0) {
            diff.color = currentObj.color
          }
        }
        if (JSON.stringify(currentObj.textureScale) !== JSON.stringify(prevObj.textureScale)) {
          diff.textureScale = currentObj.textureScale
        }
        if (JSON.stringify(currentObj.textureOffset) !== JSON.stringify(prevObj.textureOffset)) {
          diff.textureOffset = currentObj.textureOffset
        }
        
        if (Object.keys(diff).length > 0) {
          sceneManager.updateMeshProperties(id, diff)
        }
      }
    })

    // Find removed objects
    prevObjectsMap.forEach((_, id) => {
      if (!currentObjectsMap.has(id)) {
        console.log(`‚ûñ Removing mesh: ${id}`)
        sceneManager.removeMeshById(id)
      }
    })
  }, [sceneObjects, sceneInitialized, prevSceneObjects])

  // Handle wireframe mode changes
  useEffect(() => {
    if (!sceneManagerRef.current || !sceneInitialized) return
    sceneManagerRef.current.setWireframeMode(wireframeMode)
  }, [wireframeMode, sceneInitialized])

  // Handle object visibility changes
  useEffect(() => {
    if (!sceneManagerRef.current || !sceneInitialized) return
    
    Object.entries(objectVisibility).forEach(([objectId, visible]) => {
      sceneManagerRef.current!.setMeshVisibility(objectId, visible)
    })
  }, [objectVisibility, sceneInitialized])

  // Handle visual grid changes
  useEffect(() => {
    if (!sceneManagerRef.current || !sceneInitialized) return
    sceneManagerRef.current.createVisualGrid(snapToGrid && showGrid, gridSize)
  }, [snapToGrid, showGrid, gridSize, sceneInitialized])

  // Handle collision detection changes
  useEffect(() => {
    if (!sceneManagerRef.current || !sceneInitialized) return
    sceneManagerRef.current.setCollisionDetectionEnabled(store.collisionDetectionEnabled)
  }, [store.collisionDetectionEnabled, sceneInitialized])

  // Handle selection visual feedback
  useEffect(() => {
    if (!sceneManagerRef.current || !sceneInitialized) return

    const sceneManager = sceneManagerRef.current
    const state = useSceneStore.getState()

    // Reset all non-ground objects to a default state
    state.sceneObjects.forEach(obj => {
      if (obj.type !== 'ground') {
        // Check if object is locked
        if (state.objectLocked[obj.id]) {
          sceneManager.setMeshEmissive(obj.id, new Color3(0.8, 0.4, 0.4)) // Red tint for locked objects
        } else {
          // Subtle glow to indicate all objects are interactive
          sceneManager.setMeshEmissive(obj.id, new Color3(0.1, 0.1, 0.1))
        }
      }
    })

    // Add hover effect
    if (state.hoveredObjectId && state.hoveredObjectId !== state.selectedObjectId && !state.selectedObjectIds.includes(state.hoveredObjectId)) {
      if (!state.objectLocked[state.hoveredObjectId]) {
        sceneManager.setMeshEmissive(state.hoveredObjectId, new Color3(0.3, 0.6, 0.9)) // Blue hover
      }
    }

    // Add strong highlight to the single selected object
    if (state.selectedObjectId) {
      sceneManager.setMeshEmissive(state.selectedObjectId, new Color3(0.6, 1.0, 1.0)) // Bright cyan selection
    }

    // Add highlight to multi-selected objects
    state.selectedObjectIds.forEach(objectId => {
      sceneManager.setMeshEmissive(objectId, new Color3(1.0, 0.8, 0.2)) // Orange for multi-selection
    })
  }, [selectedObjectId, selectedObjectIds, hoveredObjectId, sceneObjects, objectLocked, sceneInitialized])

  // Handle multi-select pivot creation
  useEffect(() => {
    if (!sceneManagerRef.current || !sceneInitialized) return

    const sceneManager = sceneManagerRef.current
    
    if (selectedObjectIds.length === 0) {
      sceneManager.removeMultiSelectPivot()
      setMultiSelectPivot(null)
      setMultiSelectInitialStates({})
      return
    }

    const selectedObjs = sceneObjects.filter(obj => selectedObjectIds.includes(obj.id))
    if (selectedObjs.length === 0) return

    // Calculate center point of selected objects
    const center = selectedObjs.reduce((acc, obj) => {
      return acc.add(obj.position)
    }, new Vector3(0, 0, 0)).scale(1 / selectedObjs.length)

    // Create pivot
    const pivot = sceneManager.createMultiSelectPivot(center)
    if (pivot) {
      setMultiSelectPivot(pivot)
      
      // Store initial states of all selected objects
      const initialStates: typeof multiSelectInitialStates = {}
      selectedObjs.forEach(obj => {
        const relativePos = obj.position.subtract(center)
        initialStates[obj.id] = {
          position: obj.position.clone(),
          rotation: obj.rotation.clone(),
          scale: obj.scale.clone(),
          relativePosition: relativePos
        }
      })
      setMultiSelectInitialStates(initialStates)
    }
  }, [selectedObjectIds, sceneObjects, sceneInitialized])

  // Handle connection point visualization toggle
  useEffect(() => {
    if (!sceneManagerRef.current || !sceneInitialized) return
    sceneManagerRef.current.visualizeConnectionPoints(showConnectionPoints)
  }, [showConnectionPoints, sceneInitialized])

  // Use gizmo management hook
  useGizmoManager(
    sceneManagerRef.current?.getScene() || null,
    (id: string) => {
      console.log('üéØ getMeshById called with:', id)
      console.log('üéØ sceneManagerRef.current:', !!sceneManagerRef.current)
      const mesh = sceneManagerRef.current?.getMeshById(id) || null
      console.log('üéØ getMeshById result:', mesh?.name || 'null')
      return mesh
    },
    multiSelectPivot,
    snapToGrid,
    snapToObjects,
    gridSize,
    sceneManagerRef.current
  )

  // Expose scene manager methods for external use
  const sceneAPI = useMemo(() => ({
    setCameraView: (view: 'front' | 'back' | 'left' | 'right' | 'top' | 'bottom' | 'home') => {
      sceneManagerRef.current?.setCameraView(view)
    },
    
    focusOnPosition: (position: Vector3) => {
      sceneManagerRef.current?.focusOnPosition(position)
    },
    
    snapToGrid: (position: Vector3) => {
      if (sceneManagerRef.current && snapToGrid) {
        return sceneManagerRef.current.snapToGrid(position, gridSize)
      }
      return position
    },
    
    setCollisionDetectionEnabled: (enabled: boolean) => {
      sceneManagerRef.current?.setCollisionDetectionEnabled(enabled)
    },
    
    getSceneManager: () => sceneManagerRef.current
  }), [snapToGrid, gridSize])

  return {
    sceneAPI,
    sceneInitialized
  }
}
</file>

<file path="src/App.css">
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.app-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
  width: 100vw;
  overflow: hidden;
  position: relative;
}

.main-content {
  display: flex;
  flex: 1;
  overflow: hidden;
  position: relative;
  width: 100%;
  height: 100%;
}

.canvas-container {
  flex: 1;
  position: relative;
  overflow: hidden;
  min-width: 0;
  width: 100%;
  height: 100%;
}

.babylon-canvas {
  outline: none;
  border: none;
  display: block;
  width: 100%;
  height: 100%;
  position: absolute;
  top: 0;
  left: 0;
}

/* Top Toolbar Styles */
.top-toolbar {
  background: #2c3e50;
  color: white;
  padding: 0;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  z-index: 1000;
  position: relative;
}

.toolbar-menu {
  display: flex;
  height: 48px;
  align-items: center;
  padding: 0 15px;
  gap: 0;
}

.toolbar-brand {
  font-size: 1.2em;
  font-weight: 700;
  color: #ecf0f1;
  margin-right: 30px;
  letter-spacing: 0.5px;
}

.toolbar-status {
  display: flex;
  align-items: center;
  gap: 20px;
  margin-right: 30px;
  padding: 0 15px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.status-item {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
}

.status-label {
  color: #bdc3c7;
  font-weight: 500;
}

.status-value {
  color: #ecf0f1;
  font-weight: 600;
  padding: 2px 6px;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.1);
}

.status-value.select {
  background: #95a5a6;
}

.status-value.move {
  background: #3498db;
}

.status-value.rotate {
  background: #e74c3c;
}

.status-value.scale {
  background: #f39c12;
}

.status-value.on {
  background: #27ae60;
}

.status-value.off {
  background: #7f8c8d;
}

.toolbar-item {
  position: relative;
  display: inline-block;
}

.toolbar-button {
  background: none;
  border: none;
  color: #ecf0f1;
  padding: 12px 16px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 500;
  transition: all 0.2s ease;
  border-radius: 4px;
  display: flex;
  align-items: center;
  gap: 6px;
}

.toolbar-button:hover {
  background: #34495e;
  color: #3498db;
}

.toolbar-button.active {
  background: #3498db;
  color: white;
}

.toolbar-button .dropdown-arrow {
  font-size: 10px;
  margin-left: 4px;
}

.dropdown-menu {
  position: absolute;
  top: 100%;
  left: 0;
  background: white;
  border: 1px solid #ddd;
  border-radius: 6px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
  min-width: 220px;
  max-width: 380px;
  max-height: 70vh;
  overflow-y: auto;
  z-index: 1001;
  opacity: 0;
  visibility: hidden;
  transform: translateY(-10px);
  transition: all 0.2s ease;
}

.dropdown-menu.show {
  opacity: 1;
  visibility: visible;
  transform: translateY(0);
}

/* Special handling for housing dropdown with more content */
.dropdown-menu:has(.dropdown-section:nth-child(3)) {
  max-width: 420px;
  min-width: 380px;
}

.dropdown-section {
  padding: 12px 0;
  border-bottom: 1px solid #eee;
}

.dropdown-section:last-child {
  border-bottom: none;
}

.dropdown-section-title {
  font-size: 11px;
  font-weight: 600;
  color: #666;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  padding: 0 16px 8px;
  margin-bottom: 8px;
}

.dropdown-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  padding: 0 16px;
}

/* Wider grid for housing sections with many items */
.dropdown-section:has(.dropdown-section-title:contains("Doors")) .dropdown-grid,
.dropdown-section:has(.dropdown-section-title:contains("Windows")) .dropdown-grid {
  grid-template-columns: repeat(2, 1fr);
}

.dropdown-button {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 12px 8px;
  background: #f8f9fa;
  border: 1px solid #e9ecef;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-size: 10px;
  font-weight: 500;
  color: #495057;
  text-align: center;
  min-height: 60px;
}

.dropdown-button:hover {
  background: #e9ecef;
  border-color: #3498db;
  color: #3498db;
}

.dropdown-button.active {
  background: #e3f2fd;
  border-color: #3498db;
  color: #1976d2;
}

.dropdown-icon {
  font-size: 16px;
  margin-bottom: 4px;
}

.dropdown-controls {
  padding: 12px 16px;
}

.control-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.control-row:last-child {
  margin-bottom: 0;
}

.control-label {
  font-size: 11px;
  color: #666;
  font-weight: 500;
  min-width: 50px;
}

.control-input {
  width: 60px;
  padding: 4px 6px;
  border: 1px solid #ddd;
  border-radius: 3px;
  font-size: 11px;
  text-align: center;
}

.control-input:focus {
  outline: none;
  border-color: #3498db;
}

.control-checkbox {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  color: #495057;
  cursor: pointer;
}

.control-checkbox input[type="checkbox"] {
  margin: 0;
  cursor: pointer;
}

.color-picker {
  width: 32px;
  height: 24px;
  border: 1px solid #ddd;
  border-radius: 3px;
  cursor: pointer;
  padding: 0;
  outline: none;
}

.color-picker::-webkit-color-swatch {
  border: none;
  border-radius: 2px;
}

.color-picker::-webkit-color-swatch-wrapper {
  padding: 0;
}

.color-picker-large {
  width: 60px;
  height: 40px;
  border: 1px solid #ddd;
  border-radius: 4px;
  cursor: pointer;
  padding: 0;
  outline: none;
}

.color-picker-large::-webkit-color-swatch {
  border: none;
  border-radius: 3px;
}

.color-picker-large::-webkit-color-swatch-wrapper {
  padding: 0;
}

.hex-input {
  width: 80px;
  padding: 4px 6px;
  border: 1px solid #ddd;
  border-radius: 3px;
  font-size: 11px;
  font-family: monospace;
  text-transform: uppercase;
}

.hex-input:focus {
  outline: none;
  border-color: #3498db;
}

.rgb-inputs {
  display: flex;
  gap: 4px;
}

.rgb-input {
  width: 40px;
  padding: 4px 6px;
  border: 1px solid #ddd;
  border-radius: 3px;
  font-size: 11px;
  text-align: center;
}

.rgb-input:focus {
  outline: none;
  border-color: #3498db;
}

.material-chips {
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
}

.material-chip {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  border: 1px solid #ddd;
  cursor: pointer;
  transition: transform 0.2s ease;
}

.material-chip:hover {
  transform: scale(1.1);
}

.material-chip.active {
  border-width: 2px;
  border-color: #3498db;
  transform: scale(1.1);
}

.dropdown-actions {
  display: flex;
  gap: 6px;
  padding: 0 16px;
}

.dropdown-action {
  flex: 1;
  padding: 6px 12px;
  background: #f8f9fa;
  border: 1px solid #ddd;
  border-radius: 4px;
  cursor: pointer;
  font-size: 11px;
  font-weight: 500;
  color: #495057;
  text-align: center;
  transition: all 0.2s ease;
}

.dropdown-action:hover {
  background: #e9ecef;
  border-color: #adb5bd;
}

.dropdown-action.danger {
  color: #dc3545;
  border-color: #dc3545;
}

.dropdown-action.danger:hover {
  background: #f8d7da;
}

.dropdown-action:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  pointer-events: none;
}

.camera-grid {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 6px;
  padding: 0 16px;
}

.camera-button {
  padding: 8px 4px;
  background: #f8f9fa;
  border: 1px solid #ddd;
  border-radius: 4px;
  cursor: pointer;
  font-size: 10px;
  font-weight: 500;
  color: #495057;
  text-align: center;
  transition: all 0.2s ease;
}

.camera-button:hover {
  background: #e9ecef;
  border-color: #3498db;
}

.selection-info {
  background: #f8f9fa;
  padding: 12px 16px;
  border-radius: 4px;
  margin: 0 16px;
  font-size: 11px;
}

.selection-info.has-selection {
  background: #e3f2fd;
  border: 1px solid #bbdefb;
}

.selected-object-name {
  font-weight: 600;
  color: #1976d2;
  margin-bottom: 4px;
}

.selected-object-details {
  color: #424242;
  line-height: 1.3;
}

.no-selection-text {
  color: #666;
  font-style: italic;
}

/* Right Sidebar - AI Only */
.ai-sidebar {
  width: 360px;
  min-width: 360px;
  max-width: 360px;
  background: #ffffff;
  border-left: 1px solid #e9ecef;
  box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
  overflow-y: auto;
  z-index: 1001;
  display: flex;
  flex-direction: column;
  transition: all 0.3s ease;
  position: relative;
  flex-shrink: 0;
}

.ai-sidebar.collapsed {
  width: 50px;
  min-width: 50px;
  max-width: 50px;
}

.ai-sidebar-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 20px;
  border-bottom: 1px solid #e9ecef;
  background: #f8f9fa;
  min-height: 60px;
  flex-shrink: 0;
}

.ai-sidebar.collapsed .ai-sidebar-header {
  padding: 16px 11px;
  justify-content: center;
}

.ai-sidebar.collapsed .ai-sidebar-header h3 {
  display: none;
}

.ai-sidebar-header h3 {
  margin: 0;
  color: #2c3e50;
  font-size: 1.2em;
  font-weight: 600;
  flex: 1;
}

.sidebar-toggle {
  background: #3498db;
  border: none;
  color: white;
  width: 28px;
  height: 28px;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  transition: all 0.2s ease;
  flex-shrink: 0;
}

.sidebar-toggle:hover {
  background: #2980b9;
  transform: scale(1.05);
}

.ai-sidebar-content {
  padding: 20px;
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.ai-control-group {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.ai-control-group label {
  font-weight: 600;
  color: #2c3e50;
  font-size: 13px;
  margin: 0;
}

.selection-mode-hint {
  font-size: 11px;
  color: #6c757d;
  font-style: italic;
  padding: 8px 12px;
  background: #f8f9fa;
  border-radius: 4px;
  border-left: 3px solid #3498db;
}

.ai-text-input {
  width: 100%;
  min-height: 100px;
  padding: 12px;
  border: 1px solid #e9ecef;
  border-radius: 6px;
  font-size: 13px;
  font-family: inherit;
  resize: vertical;
  transition: all 0.2s ease;
  background: #ffffff;
  color: #2c3e50;
}

.ai-text-input::placeholder {
  color: #95a5a6;
}

.ai-text-input:focus {
  outline: none;
  border-color: #3498db;
  box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
  color: #2c3e50;
}

.ai-text-input:disabled {
  background-color: #f8f9fa;
  cursor: not-allowed;
  color: #6c757d;
}

.ai-submit-button {
  width: 100%;
  padding: 12px;
  background: #3498db;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
}

.ai-submit-button:hover:not(:disabled) {
  background: #2980b9;
  transform: translateY(-1px);
}

.ai-submit-button:disabled {
  background: #bdc3c7;
  cursor: not-allowed;
  transform: none;
}

.ai-response-log {
  max-height: 280px;
  overflow-y: auto;
  background: #f8f9fa;
  border: 1px solid #e9ecef;
  border-radius: 6px;
  padding: 12px;
}

.ai-log-entry {
  padding: 10px 12px;
  margin: 8px 0;
  border-radius: 6px;
  font-size: 12px;
  line-height: 1.5;
  white-space: pre-wrap;
  word-wrap: break-word;
  border-left: 3px solid transparent;
}

.ai-log-entry:first-child {
  margin-top: 0;
}

.ai-log-entry:last-child {
  margin-bottom: 0;
}

.ai-log-entry.user {
  background: #e8f4fd;
  border-left-color: #3498db;
  color: #2c3e50;
}

.ai-log-entry.ai {
  background: #e8f5e8;
  border-left-color: #27ae60;
  color: #2c3e50;
}

.ai-log-entry.error {
  background: #fdf2f2;
  border-left-color: #e74c3c;
  color: #c0392b;
  font-weight: 500;
}

.ai-log-entry.ai-log-empty {
  background: #f8f9fa;
  border-left-color: #bdc3c7;
  color: #7f8c8d;
  font-style: italic;
  text-align: center;
}

.scene-objects {
  display: flex;
  flex-direction: column;
  gap: 8px;
  max-height: 220px;
  overflow-y: auto;
  background: #f8f9fa;
  border: 1px solid #e9ecef;
  border-radius: 6px;
  padding: 12px;
}

.scene-object {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 10px;
  background: #f8f9fa;
  border: 1px solid #e9ecef;
  border-radius: 4px;
  font-size: 12px;
  transition: all 0.2s ease;
  cursor: pointer;
  position: relative;
}

.scene-object:hover {
  background: #e9ecef;
  border-color: #adb5bd;
}

.scene-object.selected {
  background: #e3f2fd;
  border-color: #3498db;
  border-width: 2px;
}

.scene-object.selected .object-type {
  color: #1976d2;
  font-weight: 700;
}

.scene-object.selected .object-id {
  color: #1976d2;
}

.scene-object.locked {
  background: #ffebee;
  border-color: #ffcdd2;
}

.scene-object.locked .object-type {
  color: #d32f2f;
}

.scene-object.hidden {
  opacity: 0.5;
  background: #f5f5f5;
}

.object-type {
  font-weight: 600;
  color: #2c3e50;
  text-transform: capitalize;
}

.object-id {
  color: #7f8c8d;
  font-family: monospace;
  flex: 1;
}

.object-controls {
  display: flex;
  gap: 4px;
  align-items: center;
}

.object-control-btn {
  background: none;
  border: none;
  cursor: pointer;
  font-size: 12px;
  padding: 2px 4px;
  border-radius: 3px;
  transition: background-color 0.2s ease;
}

.object-control-btn:hover {
  background: rgba(0, 0, 0, 0.1);
}

.object-control-btn.hidden {
  opacity: 0.4;
}

.object-control-btn.locked {
  color: #d32f2f;
}

.object-color {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  border: 1px solid #e9ecef;
}

.no-objects {
  text-align: center;
  color: #7f8c8d;
  font-style: italic;
  padding: 24px;
  font-size: 12px;
  background: #ffffff;
  border-radius: 4px;
  border: 1px dashed #bdc3c7;
}

.object-stats {
  background: #ffffff;
  padding: 8px 12px;
  border-radius: 6px;
  text-align: center;
  border: 1px solid #e9ecef;
  font-size: 11px;
  color: #6c757d;
}

.keyboard-shortcuts {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 6px;
  background: #f8f9fa;
  border: 1px solid #e9ecef;
  border-radius: 6px;
  padding: 12px;
  max-height: 160px;
  overflow-y: auto;
}

.shortcut-item {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 2px 4px;
  font-size: 10px;
}

.shortcut-key {
  background: #f8f9fa;
  border: 1px solid #dee2e6;
  border-radius: 3px;
  padding: 2px 4px;
  font-family: monospace;
  font-size: 9px;
  color: #495057;
  font-weight: 500;
  min-width: 32px;
  text-align: center;
}

.shortcut-desc {
  color: #6c757d;
  font-size: 9px;
  flex: 1;
}

.clear-all-button {
  width: 100%;
  padding: 10px 12px;
  background: #e74c3c;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
}

.clear-all-button:hover:not(:disabled) {
  background: #c0392b;
  transform: translateY(-1px);
}

.clear-all-button:disabled {
  background: #bdc3c7;
  cursor: not-allowed;
  transform: none;
}

/* Import Button Styles */
.import-button {
  width: 100%;
  padding: 12px;
  background: #27ae60;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.import-button:hover:not(:disabled) {
  background: #229954;
  transform: translateY(-1px);
}

.import-button:disabled {
  background: #bdc3c7;
  cursor: not-allowed;
  transform: none;
}

.import-error {
  background: #fdf2f2;
  border: 1px solid #fdeaea;
  border-left: 3px solid #e74c3c;
  border-radius: 6px;
  padding: 10px 12px;
  font-size: 12px;
  color: #c0392b;
  font-weight: 500;
  line-height: 1.5;
}

.import-error-message {
  background: #fdf2f2;
  border: 1px solid #fdeaea;
  border-left: 3px solid #e74c3c;
  border-radius: 6px;
  padding: 10px 12px;
  margin-top: 8px;
  font-size: 12px;
  color: #c0392b;
  font-weight: 500;
  line-height: 1.5;
}

/* Export Button Styles */
.export-button-container {
  width: 100%;
}

.export-button {
  width: 100%;
  padding: 12px;
  background: #2196F3;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
}

.export-button:hover:not(:disabled) {
  background: #1976D2;
  transform: translateY(-1px);
}

.export-button:disabled,
.export-button.disabled {
  background: #bdc3c7;
  cursor: not-allowed;
  transform: none;
}

.export-button .button-icon {
  font-size: 16px;
}

.export-button .button-text {
  flex: 1;
}

.export-error {
  background: #fdf2f2;
  border: 1px solid #fdeaea;
  border-left: 3px solid #e74c3c;
  border-radius: 6px;
  padding: 10px 12px;
  margin-top: 8px;
  font-size: 12px;
  color: #c0392b;
  font-weight: 500;
  line-height: 1.5;
}

.loading-indicator {
  text-align: center;
  padding: 24px;
  color: #7f8c8d;
  font-style: italic;
  background: #f8f9fa;
  border-radius: 6px;
  border: 1px solid #e9ecef;
}

/* Texture Upload Styles */
.texture-upload-container {
  width: 100%;
}

.texture-upload-area {
  width: 100%;
  min-height: 120px;
  border: 2px dashed #dee2e6;
  border-radius: 8px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 20px;
  cursor: pointer;
  transition: all 0.3s ease;
  background: #f8f9fa;
  text-align: center;
  user-select: none;
}

.texture-upload-area:hover {
  border-color: #3498db;
  background: #e3f2fd;
}

.texture-upload-area.dragging {
  border-color: #2ecc71;
  background: #e8f8f5;
  transform: scale(1.02);
}

.texture-upload-area.uploading {
  cursor: not-allowed;
  opacity: 0.7;
}

.upload-prompt {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.upload-icon {
  font-size: 36px;
  opacity: 0.8;
}

.upload-text {
  font-size: 14px;
  font-weight: 500;
  color: #495057;
}

.upload-hint {
  font-size: 11px;
  color: #6c757d;
  font-style: italic;
}

.upload-progress {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
}

.spinner {
  width: 32px;
  height: 32px;
  border: 3px solid #e3f2fd;
  border-top-color: #3498db;
  border-radius: 50%;
  animation: rotate 1s linear infinite;
}

.preview-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.texture-preview {
  max-width: 100px;
  max-height: 100px;
  border-radius: 4px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  object-fit: cover;
}

.upload-success {
  font-size: 12px;
  color: #27ae60;
  font-weight: 500;
}

.texture-upload-error {
  margin-top: 8px;
  padding: 8px 12px;
  background: #fee;
  border: 1px solid #fcc;
  border-radius: 4px;
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 11px;
  color: #c00;
  animation: slideDown 0.3s ease;
}

.texture-upload-error .error-icon {
  font-size: 14px;
}

.texture-upload-error .error-text {
  flex: 1;
}

@keyframes slideDown {
  from {
    transform: translateY(-10px);
    opacity: 0;
  }
  to {
    transform: translateY(0);
    opacity: 1;
  }
}

/* Texture Library Styles */
.texture-library-container {
  width: 100%;
}

.texture-library-header {
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-bottom: 15px;
}

.texture-search-input {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #dee2e6;
  border-radius: 6px;
  font-size: 13px;
  transition: border-color 0.2s ease;
}

.texture-search-input:focus {
  outline: none;
  border-color: #3498db;
  box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.1);
}

.texture-type-selector {
  display: flex;
  align-items: center;
  gap: 10px;
}

.texture-type-selector label {
  font-size: 12px;
  font-weight: 500;
  color: #6c757d;
}

.texture-type-select {
  flex: 1;
  padding: 6px 10px;
  border: 1px solid #dee2e6;
  border-radius: 4px;
  font-size: 12px;
  cursor: pointer;
  transition: border-color 0.2s ease;
}

.texture-type-select:focus {
  outline: none;
  border-color: #3498db;
}

.texture-library-empty {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 40px 20px;
  text-align: center;
  color: #6c757d;
}

.empty-icon {
  font-size: 48px;
  opacity: 0.5;
  margin-bottom: 12px;
}

.empty-text {
  font-size: 14px;
  font-weight: 500;
  margin-bottom: 6px;
}

.empty-hint {
  font-size: 12px;
  font-style: italic;
  opacity: 0.8;
}

.texture-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  gap: 12px;
  max-height: 400px;
  overflow-y: auto;
  padding: 2px;
}

.texture-item {
  position: relative;
  background: #f8f9fa;
  border: 2px solid #e9ecef;
  border-radius: 8px;
  padding: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.texture-item:hover {
  border-color: #3498db;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.texture-item.selected {
  border-color: #3498db;
  background: #e3f2fd;
  box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
}

.texture-thumbnail {
  width: 100%;
  aspect-ratio: 1;
  overflow: hidden;
  border-radius: 4px;
  margin-bottom: 8px;
  background: #fff;
}

.texture-thumbnail img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.texture-info {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.texture-name {
  font-size: 11px;
  font-weight: 500;
  color: #2c3e50;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.texture-rename-input {
  width: 100%;
  padding: 2px 4px;
  border: 1px solid #3498db;
  border-radius: 3px;
  font-size: 11px;
  font-weight: 500;
}

.texture-meta {
  display: flex;
  justify-content: space-between;
  font-size: 9px;
  color: #6c757d;
}

.texture-date {
  font-size: 9px;
  color: #95a5a6;
  font-style: italic;
}

.texture-actions {
  position: absolute;
  top: 4px;
  right: 4px;
  display: flex;
  gap: 4px;
  opacity: 0;
  transition: opacity 0.2s ease;
}

.texture-item:hover .texture-actions {
  opacity: 1;
}

.texture-action-btn {
  width: 24px;
  height: 24px;
  border: none;
  border-radius: 4px;
  background: rgba(255, 255, 255, 0.9);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  transition: all 0.2s ease;
}

.texture-action-btn:hover {
  transform: scale(1.1);
  background: #fff;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.texture-action-btn.rename:hover {
  background: #3498db;
}

.texture-action-btn.delete:hover {
  background: #e74c3c;
}

.texture-apply-section {
  margin-top: 15px;
  padding-top: 15px;
  border-top: 1px solid #e9ecef;
}

.texture-apply-button {
  width: 100%;
  padding: 10px 16px;
  background: #27ae60;
  color: white;
  border: none;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
}

.texture-apply-button:hover {
  background: #219a52;
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(39, 174, 96, 0.3);
}

.texture-apply-button:active {
  transform: translateY(0);
}

/* Texture grid scrollbar styling */
.texture-grid::-webkit-scrollbar {
  width: 6px;
}

.texture-grid::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 3px;
}

.texture-grid::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 3px;
}

.texture-grid::-webkit-scrollbar-thumb:hover {
  background: #a8a8a8;
}

/* Texture Library Section Styles */
.texture-sections {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.texture-section {
  background-color: rgba(0, 0, 0, 0.05);
  border-radius: 6px;
  overflow: hidden;
}

.texture-section-header {
  display: flex;
  align-items: center;
  padding: 10px 15px;
  background-color: rgba(0, 0, 0, 0.1);
  cursor: pointer;
  user-select: none;
  transition: background-color 0.2s ease;
}

.texture-section-header:hover {
  background-color: rgba(0, 0, 0, 0.15);
}

.section-toggle {
  margin-right: 8px;
  font-size: 12px;
  color: #7f8c8d;
}

.texture-section-header h4 {
  margin: 0;
  font-size: 14px;
  font-weight: 600;
  color: #2c3e50;
}

.texture-item.default-texture {
  position: relative;
}

.texture-item.default-texture::after {
  content: '‚úì';
  position: absolute;
  top: 5px;
  right: 5px;
  background-color: #27ae60;
  color: white;
  width: 20px;
  height: 20px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: bold;
}

/* API Key Setup */
.api-key-setup {
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  padding: 20px;
}

.api-key-container {
  background: white;
  padding: 40px;
  border-radius: 12px;
  box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
  max-width: 500px;
  width: 100%;
  text-align: center;
}

.api-key-container h2 {
  color: #2c3e50;
  margin-bottom: 20px;
  font-size: 2em;
}

.api-key-container p {
  color: #7f8c8d;
  margin-bottom: 20px;
  line-height: 1.6;
}

.api-key-input {
  width: 100%;
  padding: 15px;
  border: 2px solid #e9ecef;
  border-radius: 8px;
  font-size: 16px;
  margin-bottom: 20px;
  transition: border-color 0.3s ease;
}

.api-key-input:focus {
  outline: none;
  border-color: #3498db;
}

.api-key-submit {
  width: 100%;
  padding: 15px;
  background: #3498db;
  color: white;
  border: none;
  border-radius: 8px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: background-color 0.3s ease;
  margin-bottom: 15px;
}

.api-key-submit:hover:not(:disabled) {
  background: #2980b9;
}

.api-key-submit:disabled {
  background: #bdc3c7;
  cursor: not-allowed;
}

.api-key-note {
  font-size: 12px;
  color: #95a5a6;
  font-style: italic;
}

/* Responsive design */
@media (max-width: 768px) {
  .app-container {
    flex-direction: column;
  }
  
  .main-content {
    flex-direction: column;
  }
  
  .ai-sidebar {
    width: 100%;
    height: 350px;
    border-left: none;
    border-top: 1px solid #e9ecef;
    box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
  }
  
  .ai-sidebar.collapsed {
    width: 100%;
    height: 50px;
  }
  
  .ai-sidebar-header {
    padding: 12px 15px;
    min-height: 50px;
  }
  
  .ai-sidebar-header h3 {
    font-size: 1.1em;
  }
  
  .ai-sidebar-content {
    padding: 15px;
    gap: 15px;
  }
  
  .ai-text-input {
    min-height: 80px;
  }
  
  .ai-response-log {
    max-height: 120px;
  }
  
  .scene-objects {
    max-height: 120px;
  }
  
  .toolbar-menu {
    flex-wrap: wrap;
    height: auto;
    min-height: 48px;
    padding: 8px 15px;
  }
  
  .toolbar-brand {
    margin-right: 15px;
    margin-bottom: 8px;
  }

  .toolbar-status {
    display: none;
  }
  
  .dropdown-menu {
    position: fixed;
    top: auto;
    left: 50%;
    transform: translateX(-50%);
    max-width: 90vw;
  }
  
  .dropdown-menu.show {
    transform: translateX(-50%) translateY(0);
  }
}

/* NURBS Properties Panel Styles */
.nurbs-properties {
  background: #f8f9fa;
  border: 1px solid #e9ecef;
  border-radius: 6px;
  padding: 12px;
  margin-top: 8px;
}

.nurbs-info {
  display: flex;
  flex-direction: column;
  gap: 6px;
  margin-bottom: 12px;
  padding: 8px;
  background: #ffffff;
  border-radius: 4px;
  border: 1px solid #e9ecef;
}

.nurbs-info-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 11px;
}

.nurbs-label {
  color: #6c757d;
  font-weight: 500;
}

.nurbs-value {
  color: #2c3e50;
  font-weight: 600;
  font-family: monospace;
}

.nurbs-control-section {
  margin-bottom: 12px;
  padding: 8px;
  background: #ffffff;
  border-radius: 4px;
  border: 1px solid #e9ecef;
}

.nurbs-section-title {
  font-size: 11px;
  font-weight: 600;
  color: #495057;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 8px;
  padding-bottom: 4px;
  border-bottom: 1px solid #e9ecef;
}

.nurbs-quality-control {
  display: flex;
  align-items: center;
  gap: 8px;
}

.nurbs-quality-slider {
  flex: 1;
  height: 4px;
  background: #e9ecef;
  border-radius: 2px;
  outline: none;
  cursor: pointer;
  -webkit-appearance: none;
}

.nurbs-quality-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px;
  height: 16px;
  background: #3498db;
  border-radius: 50%;
  cursor: pointer;
  border: 2px solid #ffffff;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.nurbs-quality-slider::-moz-range-thumb {
  width: 16px;
  height: 16px;
  background: #3498db;
  border-radius: 50%;
  cursor: pointer;
  border: 2px solid #ffffff;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
}

.nurbs-quality-value {
  font-size: 11px;
  font-weight: 600;
  color: #2c3e50;
  font-family: monospace;
  min-width: 20px;
  text-align: center;
}

.control-points-list {
  max-height: 200px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.control-point-item {
  padding: 8px;
  background: #f8f9fa;
  border: 1px solid #e9ecef;
  border-radius: 4px;
  transition: all 0.2s ease;
}

.control-point-item.selected {
  background: #e3f2fd;
  border-color: #3498db;
  box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
}

.control-point-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 6px;
}

.control-point-label {
  font-size: 10px;
  font-weight: 600;
  color: #495057;
  font-family: monospace;
}

.control-point-selected-indicator {
  color: #27ae60;
  font-size: 12px;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.control-point-coords {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 4px;
}

.control-point-coord {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 2px;
}

.control-point-coord label {
  font-size: 9px;
  color: #6c757d;
  font-weight: 500;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.control-point-input {
  width: 100%;
  padding: 4px 6px;
  border: 1px solid #dee2e6;
  border-radius: 3px;
  font-size: 10px;
  font-family: monospace;
  text-align: center;
  transition: border-color 0.2s ease;
}

.control-point-input:focus {
  outline: none;
  border-color: #3498db;
  box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
}

.control-point-item.selected .control-point-input {
  border-color: #3498db;
  background: #ffffff;
}

.nurbs-export-controls {
  display: flex;
  gap: 8px;
}

.nurbs-export-button {
  flex: 1;
  padding: 8px 12px;
  background: #28a745;
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 11px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.nurbs-export-button:hover {
  background: #218838;
  transform: translateY(-1px);
}

.nurbs-export-button:active {
  transform: translateY(0);
}

.nurbs-help {
  margin-top: 8px;
  padding: 8px;
  background: #fff3cd;
  border: 1px solid #ffeaa7;
  border-radius: 4px;
  color: #856404;
  font-size: 10px;
  line-height: 1.4;
}

.nurbs-help small {
  margin: 0;
}

/* Control point visualization styles in 3D scene */
.control-point-sphere {
  cursor: pointer;
}

.control-point-sphere:hover {
  transform: scale(1.1);
}

/* Scrollbar styling for control points list */
.control-points-list::-webkit-scrollbar {
  width: 4px;
}

.control-points-list::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 2px;
}

.control-points-list::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 2px;
}

.control-points-list::-webkit-scrollbar-thumb:hover {
  background: #a8a8a8;
}

/* Responsive adjustments for NURBS panel */
@media (max-width: 768px) {
  .nurbs-properties {
    padding: 8px;
  }
  
  .control-point-coords {
    grid-template-columns: 1fr;
    gap: 6px;
  }
  
  .control-point-coord {
    flex-direction: row;
    align-items: center;
    justify-content: space-between;
  }
  
  .control-point-coord label {
    min-width: 20px;
  }
  
  .control-point-input {
    width: 60px;
  }
  
  .control-points-list {
    max-height: 150px;
  }
}

/* Enhanced Housing-specific styles for Sprint 2 */
.wall-thickness-control {
  display: flex;
  align-items: center;
  gap: 10px;
}

.thickness-slider {
  flex: 1;
  cursor: pointer;
  appearance: none;
  height: 4px;
  background: #ddd;
  border-radius: 2px;
  outline: none;
}

.thickness-slider::-webkit-slider-thumb {
  appearance: none;
  width: 16px;
  height: 16px;
  background: #3498db;
  border-radius: 50%;
  cursor: pointer;
}

.thickness-slider::-moz-range-thumb {
  width: 16px;
  height: 16px;
  background: #3498db;
  border-radius: 50%;
  cursor: pointer;
  border: none;
}

.thickness-value {
  color: #3498db;
  font-weight: 500;
  font-size: 11px;
  min-width: 40px;
  text-align: center;
}

.thickness-hint {
  color: #6c757d;
  font-size: 10px;
  margin-top: 4px;
  font-style: italic;
}

.height-control {
  display: flex;
  align-items: center;
  gap: 8px;
}

.height-input {
  flex: 1;
  padding: 4px 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 12px;
}

.auto-adjust-btn {
  padding: 4px 8px;
  background: #17a2b8;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  transition: background-color 0.2s;
}

.auto-adjust-btn:hover {
  background: #138496;
}

.length-display {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 8px;
  background: #f8f9fa;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.length-value {
  font-weight: 500;
  color: #2c3e50;
  font-family: monospace;
}

.edit-length-btn {
  padding: 2px 6px;
  background: #ffc107;
  color: #212529;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-size: 10px;
  transition: background-color 0.2s;
}

.edit-length-btn:hover {
  background: #e0a800;
}

.load-bearing-control {
  display: flex;
  align-items: center;
  gap: 8px;
}

.structural-warning {
  color: #dc3545;
  font-size: 10px;
  font-weight: 500;
}

.connected-walls-list {
  border: 1px solid #ddd;
  border-radius: 4px;
  max-height: 120px;
  overflow-y: auto;
  background: #f8f9fa;
}

.connected-wall-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 6px 8px;
  border-bottom: 1px solid #eee;
}

.connected-wall-item:last-child {
  border-bottom: none;
}

.connected-wall-id {
  font-size: 11px;
  color: #495057;
}

.disconnect-btn {
  padding: 2px 6px;
  background: #dc3545;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-size: 10px;
  transition: background-color 0.2s;
}

.disconnect-btn:hover {
  background: #c82333;
}

.no-connections {
  padding: 8px;
  text-align: center;
  color: #6c757d;
  font-size: 11px;
  font-style: italic;
}

.wall-actions {
  display: flex;
  gap: 6px;
  margin-top: 8px;
}

.wall-action-btn {
  flex: 1;
  padding: 6px 8px;
  background: #17a2b8;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 10px;
  transition: background-color 0.2s;
}

.wall-action-btn:hover {
  background: #138496;
}

.wall-action-btn.danger {
  background: #dc3545;
}

.wall-action-btn.danger:hover {
  background: #c82333;
}

.dimension-controls {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.dimension-input {
  display: flex;
  align-items: center;
  gap: 8px;
}

.dimension-input label {
  min-width: 60px;
  font-size: 11px;
  color: #495057;
}

.dimension-field {
  flex: 1;
  padding: 4px 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 11px;
}

.dimension-field:focus {
  outline: none;
  border-color: #3498db;
}

.position-controls {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.position-slider {
  display: flex;
  align-items: center;
  gap: 8px;
}

.position-range {
  flex: 1;
  cursor: pointer;
  appearance: none;
  height: 4px;
  background: #ddd;
  border-radius: 2px;
  outline: none;
}

.position-range::-webkit-slider-thumb {
  appearance: none;
  width: 16px;
  height: 16px;
  background: #28a745;
  border-radius: 50%;
  cursor: pointer;
}

.position-range::-moz-range-thumb {
  width: 16px;
  height: 16px;
  background: #28a745;
  border-radius: 50%;
  cursor: pointer;
  border: none;
}

.position-value {
  color: #28a745;
  font-weight: 500;
  font-size: 11px;
  min-width: 30px;
  text-align: center;
}

.drag-position-btn {
  padding: 6px 12px;
  background: #28a745;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 11px;
  transition: background-color 0.2s;
}

.drag-position-btn:hover {
  background: #218838;
}

.operation-controls {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.operation-setting {
  display: flex;
  align-items: center;
  gap: 8px;
}

.operation-setting label {
  min-width: 80px;
  font-size: 11px;
  color: #495057;
}

.operation-setting select {
  flex: 1;
  padding: 4px 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 11px;
}

.operation-setting input[type="checkbox"] {
  transform: scale(1.2);
}

.cutout-controls {
  display: flex;
  gap: 6px;
}

.cutout-btn {
  flex: 1;
  padding: 6px 8px;
  background: #6f42c1;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 10px;
  transition: background-color 0.2s;
}

.cutout-btn:hover {
  background: #5a32a3;
}

.door-actions, .window-actions {
  display: flex;
  gap: 6px;
  margin-top: 8px;
}

.door-action-btn, .window-action-btn {
  flex: 1;
  padding: 6px 8px;
  background: #17a2b8;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 10px;
  transition: background-color 0.2s;
}

.door-action-btn:hover, .window-action-btn:hover {
  background: #138496;
}

.frame-controls {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.frame-setting {
  display: flex;
  align-items: center;
  gap: 8px;
}

.frame-setting label {
  min-width: 80px;
  font-size: 11px;
  color: #495057;
}

.frame-setting input[type="checkbox"] {
  transform: scale(1.2);
}

.ceiling-features, .floor-features {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.feature-option {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 8px;
  background: #f8f9fa;
  border: 1px solid #e9ecef;
  border-radius: 4px;
}

.feature-option input[type="checkbox"] {
  transform: scale(1.1);
}

.feature-option label {
  flex: 1;
  font-size: 11px;
  color: #495057;
  cursor: pointer;
}

.ceiling-actions {
  display: flex;
  gap: 6px;
}

.ceiling-action-btn {
  flex: 1;
  padding: 6px 8px;
  background: #fd7e14;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 10px;
  transition: background-color 0.2s;
}

.ceiling-action-btn:hover {
  background: #e8650e;
}

.thickness-control {
  display: flex;
  align-items: center;
  gap: 10px;
}

.ceiling-type-select,
.ceiling-material-select,
.floor-material-select {
  width: 100%;
  padding: 4px 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 11px;
  background: white;
}

.ceiling-type-select:focus,
.ceiling-material-select:focus,
.floor-material-select:focus {
  outline: none;
  border-color: #3498db;
}

.room-type-select {
  width: 100%;
  padding: 6px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: white;
  color: #333;
  font-size: 12px;
}

.room-type-select:focus {
  outline: none;
  border-color: #3498db;
  box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
}

.walls-list, .doors-list, .windows-list {
  border: 1px solid #ddd;
  border-radius: 4px;
  background: white;
  max-height: 150px;
  overflow-y: auto;
}

.wall-item, .door-item, .window-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px;
  border-bottom: 1px solid #eee;
  cursor: pointer;
  transition: background-color 0.2s;
}

.wall-item:hover, .door-item:hover, .window-item:hover {
  background: #f8f9fa;
}

.wall-item.selected, .door-item.selected, .window-item.selected {
  background: #3498db;
  color: white;
}

.wall-item:last-child, .door-item:last-child, .window-item:last-child {
  border-bottom: none;
}

.wall-name, .door-name, .window-name {
  font-weight: 500;
  font-size: 12px;
}

.wall-info, .door-info, .window-info {
  color: #666;
  font-size: 11px;
}

.wall-item.selected .wall-info,
.door-item.selected .door-info,
.window-item.selected .window-info {
  color: #f0f0f0;
}

.add-component-btn {
  width: 100%;
  padding: 8px;
  background: #3498db;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  margin-top: 8px;
  transition: background-color 0.2s;
}

.add-component-btn:hover {
  background: #2980b9;
}

.selected-wall-properties, .selected-door-properties, .selected-window-properties {
  background: #f8f9fa;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 10px;
  margin-top: 10px;
}

.selected-wall-properties h5, .selected-door-properties h5, .selected-window-properties h5 {
  margin: 0 0 10px 0;
  color: #3498db;
  font-size: 13px;
}

.wall-property, .door-property, .window-property {
  display: flex;
  flex-direction: column;
  margin-bottom: 12px;
}

.wall-property label, .door-property label, .window-property label {
  color: #495057;
  font-size: 11px;
  font-weight: 500;
  margin-bottom: 4px;
}

.wall-property input, .door-property input, .window-property input,
.wall-property select, .door-property select, .window-property select {
  width: 100%;
  padding: 4px 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: white;
  color: #333;
  font-size: 11px;
}

.wall-property input:focus, .door-property input:focus, .window-property input:focus,
.wall-property select:focus, .door-property select:focus, .window-property select:focus {
  outline: none;
  border-color: #3498db;
  box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
}

.remove-component-btn {
  width: 100%;
  padding: 6px;
  background: #e74c3c;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 11px;
  margin-top: 10px;
  transition: background-color 0.2s;
}

.remove-component-btn:hover {
  background: #c0392b;
}

.building-info {
  background: #f8f9fa;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 10px;
  font-size: 11px;
  color: #666;
}

.building-info > div {
  margin-bottom: 4px;
}

.building-info > div:last-child {
  margin-bottom: 0;
}

.properties-section {
  margin-bottom: 20px;
  padding: 15px;
  background: white;
  border: 1px solid #ddd;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.properties-section h4 {
  margin: 0 0 15px 0;
  color: #333;
  font-size: 14px;
  font-weight: 600;
  border-bottom: 1px solid #eee;
  padding-bottom: 8px;
}

.property-group {
  margin-bottom: 15px;
}

.property-group label {
  display: block;
  margin-bottom: 5px;
  color: #555;
  font-size: 12px;
  font-weight: 500;
}

.property-group input[type="number"],
.property-group input[type="text"] {
  width: 100%;
  padding: 6px 8px;
  border: 1px solid #ddd;
  border-radius: 4px;
  background: white;
  color: #333;
  font-size: 12px;
  transition: border-color 0.2s;
}

.property-group input[type="number"]:focus,
.property-group input[type="text"]:focus {
  outline: none;
  border-color: #3498db;
  box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
}

.property-group input[type="checkbox"] {
  margin-right: 8px;
  transform: scale(1.1);
}

.property-group input[type="checkbox"]:checked {
  accent-color: #3498db;
}

/* Texture Properties in Properties Panel */
.applied-textures-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.applied-texture-item {
  display: flex;
  align-items: center;
  padding: 6px 10px;
  background: #f8f9fa;
  border: 1px solid #e9ecef;
  border-radius: 4px;
  font-size: 11px;
}

.texture-type-label {
  font-weight: 600;
  color: #495057;
  margin-right: 8px;
  text-transform: capitalize;
}

.texture-name {
  flex: 1;
  color: #2c3e50;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.remove-texture-btn {
  background: none;
  border: none;
  cursor: pointer;
  font-size: 12px;
  padding: 4px;
  transition: all 0.2s ease;
}

.remove-texture-btn:hover {
  transform: scale(1.2);
}

.texture-scale-controls,
.texture-offset-controls {
  display: flex;
  gap: 12px;
}

.scale-input,
.offset-input {
  display: flex;
  align-items: center;
  gap: 6px;
}

.scale-input label,
.offset-input label {
  font-weight: 600;
  color: #6c757d;
  font-size: 11px;
  min-width: 20px;
}

.scale-component,
.offset-component {
  width: 60px;
  padding: 4px 8px;
  border: 1px solid #dee2e6;
  border-radius: 4px;
  font-size: 11px;
  text-align: center;
}

.scale-component:focus,
.offset-component:focus {
  outline: none;
  border-color: #3498db;
  box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
}

/* Properties panel texture upload/library styling */
.properties-texture-upload {
  margin-top: 8px;
}

.properties-texture-upload .texture-upload-area {
  min-height: 80px;
  padding: 12px;
}

.properties-texture-upload .upload-icon {
  font-size: 24px;
}

.properties-texture-upload .upload-text {
  font-size: 12px;
}

.properties-texture-upload .upload-hint {
  font-size: 10px;
}

.properties-texture-library {
  margin-top: 8px;
  border: 1px solid #e9ecef;
  border-radius: 6px;
  padding: 8px;
  background: #f8f9fa;
}

.properties-texture-library .texture-grid {
  max-height: 200px;
  grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
  gap: 8px;
}

.properties-texture-library .texture-item {
  padding: 6px;
}

.properties-texture-library .texture-thumbnail {
  margin-bottom: 4px;
}

.properties-texture-library .texture-name {
  font-size: 9px;
}

.properties-texture-library .texture-meta {
  font-size: 8px;
}

.properties-texture-library .texture-search-input {
  padding: 6px 10px;
  font-size: 11px;
  margin-bottom: 8px;
}

.properties-texture-library .texture-type-select {
  padding: 4px 8px;
  font-size: 11px;
}

.properties-texture-library .texture-apply-button {
  padding: 8px 12px;
  font-size: 11px;
}

.properties-texture-library .texture-library-empty {
  padding: 20px 10px;
}

.properties-texture-library .empty-icon {
  font-size: 32px;
}

.properties-texture-library .empty-text {
  font-size: 12px;
}

.properties-texture-library .empty-hint {
  font-size: 10px;
}

/* Additional styling */
</file>

<file path="src/ai/ai.service.ts">
import OpenAI from 'openai';
import type { SceneObject } from '../types/types';
import { Vector3 } from 'babylonjs';

export interface SceneCommand {
  action: 'move' | 'color' | 'scale' | 'create' | 'delete' | 'rotate' | 'align';
  objectId?: string;
  type?: 'cube' | 'sphere' | 'cylinder' | 'plane' | 'torus' | 'cone' | 
    'house-basic' | 'house-room' | 'house-hallway' | 'house-roof-flat' | 'house-roof-pitched' |
    'house-room-modular' | 'house-wall' | 'house-ceiling' | 'house-floor' |
    'house-door-single' | 'house-door-double' | 'house-door-sliding' | 'house-door-french' | 'house-door-garage' |
    'house-window-single' | 'house-window-double' | 'house-window-bay' | 'house-window-casement' | 'house-window-sliding' | 'house-window-skylight';
  x?: number;
  y?: number;
  z?: number;
  color?: string;
  size?: number;
  scaleX?: number;
  scaleY?: number;
  scaleZ?: number;
  rotationX?: number;
  rotationY?: number;
  rotationZ?: number;
  relativeToObject?: string;
  spatialRelation?: 'on-top-of' | 'beside' | 'in-front-of' | 'behind' | 'above' | 'below' | 'inside';
  matchDimensions?: boolean;
  contactType?: 'direct' | 'gap' | 'overlap';
  // New align-specific properties
  edge?: 'north' | 'south' | 'east' | 'west';
  offset?: number;
}

export interface AIServiceResult {
  success: boolean;
  commands?: SceneCommand[];
  error?: string;
  userPrompt?: string;
  aiResponse?: string;
}

/**
 * AI Service for handling OpenAI API interactions and scene command generation
 */
export class AIService {
  private openai: OpenAI;

  constructor(apiKey: string) {
    this.openai = new OpenAI({ 
      apiKey, 
      dangerouslyAllowBrowser: true 
    });
  }

  /**
   * Calculate the effective size of an object based on its type and scale
   */
  private getObjectDimensions(obj: SceneObject): { width: number; height: number; depth: number } {
    // Base dimensions for different object types (as used in sceneManager.ts)
    const baseDimensions: { [key: string]: { width: number; height: number; depth: number } } = {
      'cube': { width: 2, height: 2, depth: 2 },
      'sphere': { width: 2, height: 2, depth: 2 },
      'cylinder': { width: 2, height: 2, depth: 2 },
      'plane': { width: 2, height: 0.1, depth: 2 },
      'torus': { width: 2, height: 0.5, depth: 2 },
      'cone': { width: 2, height: 2, depth: 2 },
      'house-basic': { width: 2, height: 2, depth: 1.5 },
      'house-room': { width: 2, height: 1.5, depth: 2 },
      'house-hallway': { width: 1, height: 1.5, depth: 3 },
      'house-roof-flat': { width: 2, height: 0.1, depth: 1.5 },
      'house-roof-pitched': { width: 2, height: 0.8, depth: 1.5 },
      'house-room-modular': { width: 4, height: 2.5, depth: 4 },
      'house-wall': { width: 4, height: 1.5, depth: 0.2 },
      'house-ceiling': { width: 4, height: 0.1, depth: 4 },
      'house-floor': { width: 4, height: 0.1, depth: 4 },
      'house-door-single': { width: 0.9, height: 2, depth: 0.05 },
      'house-door-double': { width: 1.8, height: 2, depth: 0.05 },
      'house-door-sliding': { width: 1.2, height: 2, depth: 0.05 },
      'house-door-french': { width: 1.2, height: 2, depth: 0.05 },
      'house-door-garage': { width: 2.4, height: 2, depth: 0.05 },
      'house-window-single': { width: 0.6, height: 0.8, depth: 0.05 },
      'house-window-double': { width: 1.2, height: 0.8, depth: 0.05 },
      'house-window-bay': { width: 1.5, height: 0.8, depth: 0.3 },
      'house-window-casement': { width: 0.8, height: 1, depth: 0.05 },
      'house-window-sliding': { width: 1.2, height: 0.8, depth: 0.05 },
      'house-window-skylight': { width: 0.8, height: 0.8, depth: 0.05 },
      'ground': { width: 10, height: 1, depth: 10 }
    };

    const base = baseDimensions[obj.type] || { width: 1, height: 1, depth: 1 };
    
    // Apply scale factors
    return {
      width: base.width * obj.scale.x,
      height: base.height * obj.scale.y,
      depth: base.depth * obj.scale.z
    };
  }

  /**
   * Calculate the bounding box of an object
   */
  private getBoundingBox(obj: SceneObject): { min: Vector3; max: Vector3 } {
    const dimensions = this.getObjectDimensions(obj);
    const halfWidth = dimensions.width / 2;
    const halfHeight = dimensions.height / 2;
    const halfDepth = dimensions.depth / 2;

    return {
      min: new Vector3(
        obj.position.x - halfWidth,
        obj.position.y - halfHeight,
        obj.position.z - halfDepth
      ),
      max: new Vector3(
        obj.position.x + halfWidth,
        obj.position.y + halfHeight,
        obj.position.z + halfDepth
      )
    };
  }

  /**
   * Find an object by color or name from the scene
   */
  private findObjectByDescription(description: string, sceneObjects: SceneObject[]): SceneObject | undefined {
    const lowerDesc = description.toLowerCase();
    
    // First try to find by color
    const colorMatches = sceneObjects.filter(obj => {
      if (obj.color) {
        const colorName = this.getColorName(obj.color);
        return colorName.includes(lowerDesc) || lowerDesc.includes(colorName);
      }
      return false;
    });

    if (colorMatches.length === 1) {
      return colorMatches[0];
    }

    // Then try to find by type
    const typeMatches = sceneObjects.filter(obj => 
      obj.type.toLowerCase().includes(lowerDesc) || lowerDesc.includes(obj.type.toLowerCase())
    );

    if (typeMatches.length === 1) {
      return typeMatches[0];
    }

    // Finally try to find by ID
    const idMatch = sceneObjects.find(obj => 
      obj.id.toLowerCase().includes(lowerDesc) || lowerDesc.includes(obj.id.toLowerCase())
    );

    return idMatch || undefined;
  }

  /**
   * Convert degrees to radians for rotation calculations
   */
  private degreesToRadians(degrees: number): number {
    return degrees * (Math.PI / 180);
  }

  /**
   * Convert radians to degrees for human-readable output
   */
  private radiansToDegrees(radians: number): number {
    return radians * (180 / Math.PI);
  }

  /**
   * Get a human-readable color name from hex value
   */
  private getColorName(hex: string): string {
    const colorMap: { [key: string]: string } = {
      '#ff6b6b': 'red',
      '#4ecdc4': 'blue',
      '#95e1d3': 'green',
      '#fce38a': 'yellow',
      '#a8e6cf': 'purple',
      '#ffb347': 'orange',
      '#ff8fab': 'pink',
      '#87ceeb': 'cyan',
      '#808080': 'gray',
      '#8B4513': 'brown',
      '#DEB887': 'tan',
      '#654321': 'dark brown'
    };

    return colorMap[hex.toLowerCase()] || 'unknown';
  }

  /**
   * Calculate precise position and scaling for spatial relationships
   */
  private calculatePreciseSpatialPlacement(
    targetObject: SceneObject,
    referenceObject: SceneObject,
    relation: string,
    sceneObjects: SceneObject[]
  ): { 
    position: { x: number; y: number; z: number };
    scale?: { x: number; y: number; z: number };
    matchDimensions: boolean;
  } {
    const refDimensions = this.getObjectDimensions(referenceObject);
    const targetDimensions = this.getObjectDimensions(targetObject);
    const refBox = this.getBoundingBox(referenceObject);
    
    // Determine if we should match dimensions based on relationship and object types
    const shouldMatchDimensions = this.shouldMatchDimensions(targetObject, referenceObject, relation);
    
    let position: { x: number; y: number; z: number };
    let scale: { x: number; y: number; z: number } | undefined;
    
    if (shouldMatchDimensions) {
      // Calculate scale factors to match reference object dimensions
      const scaleFactors = this.calculateDimensionMatchingScale(targetObject, referenceObject, relation);
      scale = scaleFactors;
      
      // Recalculate target dimensions with new scale
      const scaledTargetDimensions = {
        width: targetDimensions.width * scaleFactors.x,
        height: targetDimensions.height * scaleFactors.y,
        depth: targetDimensions.depth * scaleFactors.z
      };
      
      position = this.calculatePreciseContactPosition(
        referenceObject, 
        scaledTargetDimensions, 
        relation
      );
    } else {
      // Use original dimensions for positioning
      position = this.calculatePreciseContactPosition(
        referenceObject, 
        targetDimensions, 
        relation
      );
    }
    
    return {
      position,
      scale,
      matchDimensions: shouldMatchDimensions
    };
  }

  /**
   * Determine if objects should match dimensions based on relationship
   */
  private shouldMatchDimensions(
    targetObject: SceneObject, 
    referenceObject: SceneObject, 
    relation: string
  ): boolean {
    // Housing objects should match dimensions for roofs on rooms/buildings
    if (targetObject.type.includes('roof') && referenceObject.type.startsWith('house-')) {
      return true;
    }
    
    // Basic objects placed "on top of" each other should match dimensions
    if (relation === 'on-top-of' && 
        !targetObject.type.startsWith('house-') && 
        !referenceObject.type.startsWith('house-')) {
      return true;
    }
    
    // Spheres and cylinders on cubes should match the cube's footprint
    if (relation === 'on-top-of' && 
        referenceObject.type === 'cube' && 
        (targetObject.type === 'sphere' || targetObject.type === 'cylinder')) {
      return true;
    }
    
    return false;
  }

  /**
   * Calculate scale factors to match reference object dimensions
   */
  private calculateDimensionMatchingScale(
    targetObject: SceneObject,
    referenceObject: SceneObject,
    relation: string
  ): { x: number; y: number; z: number } {
    const refDimensions = this.getObjectDimensions(referenceObject);
    const targetDimensions = this.getObjectDimensions(targetObject);
    
    // Special case: roofs should match building footprint but keep their own height
    if (targetObject.type.includes('roof')) {
      return {
        x: refDimensions.width / targetDimensions.width,
        y: 1, // Keep original roof height
        z: refDimensions.depth / targetDimensions.depth
      };
    }
    
    // For "on-top-of" relationships, match the footprint but keep original height
    if (relation === 'on-top-of') {
      return {
        x: refDimensions.width / targetDimensions.width,
        y: 1, // Keep original height unless it's a cube on cube
        z: refDimensions.depth / targetDimensions.depth
      };
    }
    
    // Default: match all dimensions
    return {
      x: refDimensions.width / targetDimensions.width,
      y: refDimensions.height / targetDimensions.height,
      z: refDimensions.depth / targetDimensions.depth
    };
  }

  /**
   * Calculate precise contact position for direct contact
   */
  private calculatePreciseContactPosition(
    referenceObject: SceneObject,
    targetDimensions: { width: number; height: number; depth: number },
    relation: string
  ): { x: number; y: number; z: number } {
    const refDimensions = this.getObjectDimensions(referenceObject);
    const refBox = this.getBoundingBox(referenceObject);
    
    switch (relation) {
      case 'on-top-of':
        // Place object directly on top with perfect contact
        return {
          x: referenceObject.position.x, // Same X position (centered)
          y: refBox.max.y + targetDimensions.height / 2, // Bottom of target touches top of reference
          z: referenceObject.position.z  // Same Z position (centered)
        };
      
      case 'above':
        // Place object above with small gap
        return {
          x: referenceObject.position.x,
          y: refBox.max.y + targetDimensions.height / 2 + 0.2, // Small gap
          z: referenceObject.position.z
        };
      
      case 'below':
        // Place object below with direct contact
        return {
          x: referenceObject.position.x,
          y: refBox.min.y - targetDimensions.height / 2, // Top of target touches bottom of reference
          z: referenceObject.position.z
        };
      
      case 'beside':
      case 'next-to':
        // Place object beside with direct contact
        return {
          x: refBox.max.x + targetDimensions.width / 2, // Direct contact on X axis
          y: referenceObject.position.y, // Same Y position (aligned)
          z: referenceObject.position.z  // Same Z position (aligned)
        };
      
      case 'in-front-of':
        // Place object in front with direct contact
        return {
          x: referenceObject.position.x,
          y: referenceObject.position.y,
          z: refBox.max.z + targetDimensions.depth / 2 // Direct contact on Z axis
        };
      
      case 'behind':
        // Place object behind with direct contact
        return {
          x: referenceObject.position.x,
          y: referenceObject.position.y,
          z: refBox.min.z - targetDimensions.depth / 2 // Direct contact on Z axis
        };
      
      default:
        // Default: same position
        return {
          x: referenceObject.position.x,
          y: referenceObject.position.y,
          z: referenceObject.position.z
        };
    }
  }

  /**
   * Enhanced roof positioning for housing objects
   */
  private calculateRoofPlacement(
    roofType: string,
    targetStructure: SceneObject,
    sceneObjects: SceneObject[]
  ): { 
    position: { x: number; y: number; z: number };
    scale: { x: number; y: number; z: number };
  } {
    const structureDimensions = this.getObjectDimensions(targetStructure);
    const structureBox = this.getBoundingBox(targetStructure);
    
    // Get base dimensions for roof type
    const baseDimensions = this.getBaseDimensionsForType(roofType);
    
    // Calculate scale to match structure footprint
    const scale = {
      x: structureDimensions.width / baseDimensions.width,
      y: 1, // Keep original roof height
      z: structureDimensions.depth / baseDimensions.depth
    };
    
    // Calculate roof height with scale
    const roofHeight = baseDimensions.height * scale.y;
    
    // Position roof directly on top of structure
    const position = {
      x: targetStructure.position.x,
      y: structureBox.max.y + roofHeight / 2, // Bottom of roof touches top of structure
      z: targetStructure.position.z
    };
    
    return { position, scale };
  }

  /**
   * Get base dimensions for object type
   */
  private getBaseDimensionsForType(type: string): { width: number; height: number; depth: number } {
    const baseDimensions: { [key: string]: { width: number; height: number; depth: number } } = {
      'cube': { width: 2, height: 2, depth: 2 },
      'sphere': { width: 2, height: 2, depth: 2 },
      'cylinder': { width: 2, height: 2, depth: 2 },
      'plane': { width: 2, height: 0.1, depth: 2 },
      'torus': { width: 2, height: 0.5, depth: 2 },
      'cone': { width: 2, height: 2, depth: 2 },
      'house-basic': { width: 2, height: 2, depth: 1.5 },
      'house-room': { width: 2, height: 1.5, depth: 2 },
      'house-hallway': { width: 1, height: 1.5, depth: 3 },
      'house-roof-flat': { width: 2, height: 0.1, depth: 1.5 },
      'house-roof-pitched': { width: 2, height: 0.8, depth: 1.5 },
      'house-room-modular': { width: 4, height: 2.5, depth: 4 },
      'house-wall': { width: 4, height: 1.5, depth: 0.2 },
      'house-ceiling': { width: 4, height: 0.1, depth: 4 },
      'house-floor': { width: 4, height: 0.1, depth: 4 },
      'house-door-single': { width: 0.9, height: 2, depth: 0.05 },
      'house-door-double': { width: 1.8, height: 2, depth: 0.05 },
      'house-door-sliding': { width: 1.2, height: 2, depth: 0.05 },
      'house-door-french': { width: 1.2, height: 2, depth: 0.05 },
      'house-door-garage': { width: 2.4, height: 2, depth: 0.05 },
      'house-window-single': { width: 0.6, height: 0.8, depth: 0.05 },
      'house-window-double': { width: 1.2, height: 0.8, depth: 0.05 },
      'house-window-bay': { width: 1.5, height: 0.8, depth: 0.3 },
      'house-window-casement': { width: 0.8, height: 1, depth: 0.05 },
      'house-window-sliding': { width: 1.2, height: 0.8, depth: 0.05 },
      'house-window-skylight': { width: 0.8, height: 0.8, depth: 0.05 }
    };
    
    return baseDimensions[type] || { width: 1, height: 1, depth: 1 };
  }

  /**
   * Generate a description of the current scene with spatial relationships
   */
  public describeScene(sceneObjects: SceneObject[]): string {
    // Debug: Log received scene objects
    console.log('ü§ñ AI Service received scene objects:');
    sceneObjects.forEach(obj => {
      console.log(`  - ${obj.id} (${obj.type}): position (${obj.position.x.toFixed(2)}, ${obj.position.y.toFixed(2)}, ${obj.position.z.toFixed(2)})`);
    });

    const housingObjects = sceneObjects.filter(obj => obj.type.startsWith('house-'));
    const primitiveObjects = sceneObjects.filter(obj => !obj.type.startsWith('house-') && obj.type !== 'ground');
    const groundObject = sceneObjects.find(obj => obj.type === 'ground');
    
    let description = '';
    
    if (groundObject) {
      description += `Ground plane at (0, 0, 0). `;
    }
    
    if (primitiveObjects.length > 0) {
      const primitiveDescription = primitiveObjects
        .map(obj => {
          const dimensions = this.getObjectDimensions(obj);
          const colorName = this.getColorName(obj.color);
          const sizeDesc = dimensions.width !== dimensions.height || dimensions.height !== dimensions.depth 
            ? `${dimensions.width.toFixed(1)}√ó${dimensions.height.toFixed(1)}√ó${dimensions.depth.toFixed(1)}` 
            : `${dimensions.width.toFixed(1)} units`;
          
          // Include rotation information if object is rotated
          const rotationDesc = (obj.rotation.x !== 0 || obj.rotation.y !== 0 || obj.rotation.z !== 0) 
            ? ` rotated (${obj.rotation.x.toFixed(2)}, ${obj.rotation.y.toFixed(2)}, ${obj.rotation.z.toFixed(2)}) rad`
            : '';
          
          return `${colorName} ${obj.type} "${obj.id}" (${sizeDesc}) at (${obj.position.x.toFixed(1)}, ${obj.position.y.toFixed(1)}, ${obj.position.z.toFixed(1)})${rotationDesc}`;
        })
        .join(', ');
      description += `Objects: ${primitiveDescription}`;
    }
    
    if (housingObjects.length > 0) {
      const housingDescription = housingObjects
        .map(obj => {
          const friendlyType = obj.type.replace('house-', '').replace('-', ' ');
          const dimensions = this.getObjectDimensions(obj);
          const colorName = this.getColorName(obj.color);
          
          // Include rotation information if object is rotated
          const rotationDesc = (obj.rotation.x !== 0 || obj.rotation.y !== 0 || obj.rotation.z !== 0) 
            ? ` rotated (${obj.rotation.x.toFixed(2)}, ${obj.rotation.y.toFixed(2)}, ${obj.rotation.z.toFixed(2)}) rad`
            : '';
          
          return `${colorName} ${friendlyType} "${obj.id}" (${dimensions.width.toFixed(1)}√ó${dimensions.height.toFixed(1)}√ó${dimensions.depth.toFixed(1)}) at (${obj.position.x.toFixed(1)}, ${obj.position.y.toFixed(1)}, ${obj.position.z.toFixed(1)})${rotationDesc}`;
        })
        .join(', ');
      description += (description ? '. ' : '') + `Housing structures: ${housingDescription}`;
    }
    
    const finalDescription = `Current scene: ${description || 'just a ground plane'}`;
    
    // Debug: Log generated scene description
    console.log('ü§ñ AI Service generated scene description:', finalDescription);
    
    return finalDescription;
  }

  /**
   * Generate the system prompt for the AI with enhanced spatial reasoning
   */
  private generateSystemPrompt(sceneDescription: string, objectIds: string[]): string {
    return `You are a 3D scene assistant with advanced spatial reasoning and precise positioning capabilities. You can modify a Babylon.js scene with millimeter-accurate positioning and automatic dimension matching.

${sceneDescription}

Available actions:
1. move: Move an object to x,y,z coordinates
2. color: Change object color (use hex colors like #ff6b6b, #4ecdc4, #95e1d3, etc.)
3. scale: Scale an object by scaleX, scaleY, scaleZ factors
4. create: Create new objects with intelligent positioning and automatic scaling
5. delete: Remove an object
6. rotate: Rotate an object by rotationX, rotationY, rotationZ angles in radians
7. align: Align an object to a specific edge of another object with perfect perpendicularity and flush contact

OBJECT TYPES:
Basic: cube, sphere, cylinder, plane, torus, cone
Housing: house-basic, house-room, house-hallway, house-roof-flat, house-roof-pitched

PRECISION SPATIAL INTELLIGENCE:
- Objects have exact dimensions and bounding boxes
- Automatic dimension matching for "on top of" relationships
- Direct contact positioning (no gaps unless specified)
- Identical orientation for stacked objects
- Specialized housing logic for roofs matching room dimensions

AUTOMATIC DIMENSION MATCHING:
- Blue cube "on top of" red cube ‚Üí Blue cube automatically scaled to match red cube's footprint
- Roof on room ‚Üí Roof automatically scaled to match room's exact dimensions
- Sphere on cube ‚Üí Sphere scaled to match cube's width and depth
- All objects maintain their original height unless explicitly scaling cubes

POSITIONING PRECISION:
- "on top of" = Perfect contact, no gaps, centered alignment, matching dimensions
- "beside" = Direct contact on sides, aligned heights
- "in front of" = Direct contact on front face, aligned positions
- "behind" = Direct contact on back face, aligned positions
- "above" = Small gap above, centered alignment
- "below" = Direct contact below, centered alignment

QUANTITY HANDLING:
- If the prompt specifies a quantity (for example, "two", "three", "5") or uses a plural noun (such as "cubes"), you MUST create exactly that number of objects.
- Do NOT introduce a 'count' or 'quantity' property. Instead, output that many individual 'create' commands inside the JSON array.
- When the user does not specify how the objects should be arranged, position them sensibly (e.g. in a straight line) **with at least one unit of empty space between their bounding boxes**.  For standard 2√ó2√ó2 cubes this means keeping their centres ‚â• 2.2 units apart (e.g. ‚Äì1.5 and 1.5 on the X axis).  Always provide explicit 'x', 'y', and 'z' that do not overlap with other objects.

ROTATION PRECISION:
- Rotation values are in radians (not degrees)
- rotationX: Rotation around X-axis (pitch)
- rotationY: Rotation around Y-axis (yaw)
- rotationZ: Rotation around Z-axis (roll)
- Common values: 0 = no rotation, œÄ/2 ‚âà 1.57 = 90¬∞, œÄ ‚âà 3.14 = 180¬∞, 3œÄ/2 ‚âà 4.71 = 270¬∞
- For 45¬∞ rotation: œÄ/4 ‚âà 0.785 radians
- For 30¬∞ rotation: œÄ/6 ‚âà 0.524 radians

ALIGNMENT BEHAVIOR:
- The align action creates perfect perpendicular alignment (90 degrees)
- The moving object is positioned flush with the specified edge
- The object is rotated to face outward from the edge
- North = positive Z direction, South = negative Z direction
- East = positive X direction, West = negative X direction
- Optional offset value moves the object away from the edge by the specified amount

SPATIAL COMMAND EXAMPLES:
"Put a blue cube on top of the red cube":
[{"action": "create", "type": "cube", "color": "#4ecdc4", "x": 0, "y": 2.0, "z": 0, "scaleX": 1.0, "scaleY": 1.0, "scaleZ": 1.0}]

"Create two red cubes side by side":
[{"action": "create", "type": "cube", "color": "#ff6b6b", "x": -1.5, "y": 0, "z": 0, "scaleX": 1.0, "scaleY": 1.0, "scaleZ": 1.0},
 {"action": "create", "type": "cube", "color": "#ff6b6b", "x": 1.5, "y": 0, "z": 0, "scaleX": 1.0, "scaleY": 1.0, "scaleZ": 1.0}]

"Place a yellow sphere on the green cube":
[{"action": "create", "type": "sphere", "color": "#fce38a", "x": 0, "y": 2.0, "z": 0, "scaleX": 1.0, "scaleY": 1.0, "scaleZ": 1.0}]

"Add a roof to the room":
[{"action": "create", "type": "house-roof-pitched", "color": "#654321", "x": 0, "y": 2.25, "z": 0, "scaleX": 1.0, "scaleY": 1.0, "scaleZ": 1.33}]

"Move the red sphere on top of the blue cube":
[{"action": "move", "objectId": "sphere-id", "x": 0, "y": 2.0, "z": 0}]

ROTATION COMMAND EXAMPLES:
"Rotate the blue cube 45 degrees around the Y-axis":
[{"action": "rotate", "objectId": "cube-id", "rotationX": 0, "rotationY": 0.785, "rotationZ": 0}]

"Tilt the red sphere 30 degrees forward":
[{"action": "rotate", "objectId": "sphere-id", "rotationX": 0.524, "rotationY": 0, "rotationZ": 0}]

"Spin the green cylinder 90 degrees around its vertical axis":
[{"action": "rotate", "objectId": "cylinder-id", "rotationX": 0, "rotationY": 1.57, "rotationZ": 0}]

"Flip the cube upside down":
[{"action": "rotate", "objectId": "cube-id", "rotationX": 3.14, "rotationY": 0, "rotationZ": 0}]

"Rotate the house 180 degrees to face the opposite direction":
[{"action": "rotate", "objectId": "house-id", "rotationX": 0, "rotationY": 3.14, "rotationZ": 0}]

ALIGNMENT COMMAND EXAMPLES:
"Align the wall to the north edge of the floor":
[{"action": "align", "objectId": "wall-id", "relativeToObject": "floor-id", "edge": "north"}]

"Line up the wall with the south side of the room":
[{"action": "align", "objectId": "wall-id", "relativeToObject": "room-id", "edge": "south"}]

"Move the wall flush with the east edge of the floor":
[{"action": "align", "objectId": "wall-id", "relativeToObject": "floor-id", "edge": "east"}]

"Snap the wall to the west side of the foundation":
[{"action": "align", "objectId": "wall-id", "relativeToObject": "foundation-id", "edge": "west"}]

"Align the wall to the north edge of the floor with 0.1 offset":
[{"action": "align", "objectId": "wall-id", "relativeToObject": "floor-id", "edge": "north", "offset": 0.1}]



HOUSING OBJECT LOGIC:
- Roofs automatically match underlying structure dimensions
- Rooms and hallways connect at ground level
- Proper architectural proportions maintained
- Direct contact between walls and roofs

CRITICAL REQUIREMENTS:
1. ALWAYS identify the reference object from the scene when spatial relationships are mentioned
2. ALWAYS calculate precise x, y, z coordinates based on exact object dimensions
3. ALWAYS include calculated coordinates in your JSON response
4. For "on top of" positioning: place bottom of target object touching top of reference object
5. For dimension matching: automatically calculate scaleX, scaleY, scaleZ factors
6. Use exact object dimensions from the scene description for all calculations
7. Ensure perfect contact - no gaps, no overlaps, just touching surfaces
8. For rotation: ALWAYS provide rotation values in radians, not degrees
9. When rotating objects, consider their current rotation state from the scene description

DIMENSION MATCHING RULES:
- Objects placed "on top of" automatically match the footprint (width √ó depth) of the reference object
- Roofs automatically match the exact dimensions of the building they're placed on
- Heights are preserved unless explicitly scaling identical object types
- Spheres and cylinders on cubes match the cube's footprint dimensions

When creating objects with spatial relationships, you MUST:
1. Identify the reference object from the scene
2. Calculate precise position for direct contact
3. Calculate scale factors for dimension matching when appropriate
4. Include x, y, z coordinates AND scaleX, scaleY, scaleZ factors in your response

Respond ONLY with valid JSON array of commands.
DO NOT INCLUDE ANY OTHER TEXT IN YOUR RESPONSE. YOU MUST ONLY RESPOND WITH VALID JSON.
DO NOT INCLUDE ANY COMMENTS IN THE JSON BLOCK.

Object IDs currently in scene: ${objectIds.join(', ')}`;
  }

  /**
   * Clean AI response by removing markdown code blocks
   */
  private cleanResponse(response: string): string {
    let cleanedResponse = response.trim();
    
    // Remove markdown code blocks
    cleanedResponse = cleanedResponse.replace(/```json\s*/g, '');
    cleanedResponse = cleanedResponse.replace(/```\s*/g, '');
    cleanedResponse = cleanedResponse.trim();
    
    return cleanedResponse;
  }

  /**
   * Parse commands with enhanced spatial understanding
   */
  private parseCommandsWithSpatialLogic(response: string, sceneObjects: SceneObject[]): SceneCommand[] {
    const cleanedResponse = this.cleanResponse(response);
    
    try {
      const parsed = JSON.parse(cleanedResponse);
      const commands = Array.isArray(parsed) ? parsed : [parsed];
      
      // Extract spatial relationships from command structure
      return commands.map((command: any) => {
        // Look for spatial relationship patterns in the command
        if (command.action === 'create' || command.action === 'move') {
          // Check for implicit spatial relationships based on missing coordinates
          if (command.x === undefined && command.y === undefined && command.z === undefined) {
            // This might be a spatial relationship command
            // The AI should have provided explicit coordinates, but we can try to infer
            const enhancedCommand = this.enhanceCommandsWithSpatialLogic([command], sceneObjects)[0];
            return enhancedCommand;
          }
        }
        
        return command as SceneCommand;
      });
    } catch (error) {
      throw new Error(`Failed to parse AI response: ${error instanceof Error ? error.message : 'Unknown parsing error'}`);
    }
  }

  /**
   * Get scene commands from user prompt with enhanced spatial reasoning
   */
  public async getSceneCommands(
    prompt: string, 
    sceneObjects: SceneObject[]
  ): Promise<AIServiceResult> {
    if (!prompt.trim()) {
      return {
        success: false,
        error: 'Empty prompt provided'
      };
    }

    try {
      const sceneDescription = this.describeScene(sceneObjects);
      const objectIds = sceneObjects.map(obj => obj.id);
      const spatialContext = this.extractSpatialContext(prompt, sceneObjects);
      const systemPrompt = this.generateSystemPrompt(sceneDescription, objectIds);

      // Enhanced prompt with spatial context
      const enhancedPrompt = spatialContext.spatialRelationDetected 
        ? `${prompt}\n\nSpatial context: ${spatialContext.description}`
        : prompt;

      const response = await this.openai.chat.completions.create({
        model: 'gpt-4o',
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: enhancedPrompt }
        ],
        temperature: 0.1
      });

      const aiResponse = response.choices[0]?.message?.content;
      
      if (!aiResponse) {
        return {
          success: false,
          error: 'No response from AI',
          userPrompt: prompt
        };
      }

      try {
        const rawCommands = this.parseCommandsWithSpatialLogic(aiResponse, sceneObjects);
        const commands = this.enhanceCommandsWithSpatialLogic(rawCommands, sceneObjects);
        
        return {
          success: true,
          commands,
          userPrompt: prompt,
          aiResponse
        };
      } catch (parseError) {
        return {
          success: false,
          error: parseError instanceof Error ? parseError.message : 'Unknown parsing error',
          userPrompt: prompt,
          aiResponse
        };
      }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown API error',
        userPrompt: prompt
      };
    }
  }

  /**
   * Find the best position to place a roof above existing structures
   */
  private findRoofPosition(sceneObjects: SceneObject[], targetStructure?: string): { x: number, y: number, z: number } | null {
    // If a specific structure is mentioned, try to find it
    if (targetStructure) {
      const target = sceneObjects.find(obj => 
        obj.id.toLowerCase().includes(targetStructure.toLowerCase()) || 
        obj.type.toLowerCase().includes(targetStructure.toLowerCase())
      );
      if (target) {
        return { x: target.position.x, y: target.position.y + 2.5, z: target.position.z };
      }
    }
    
    // Otherwise, find the first house or room structure
    const structures = sceneObjects.filter(obj => 
      obj.type.startsWith('house-') && 
      !obj.type.includes('roof') &&
      obj.type !== 'ground'
    );
    
    if (structures.length > 0) {
      const structure = structures[0];
      return { x: structure.position.x, y: structure.position.y + 2.5, z: structure.position.z };
    }
    
    return null;
  }

  /**
   * Find the best position to connect structures (like rooms with hallways)
   */
  private findConnectionPosition(sceneObjects: SceneObject[], type: string): { x: number, y: number, z: number } {
    const structures = sceneObjects.filter(obj => 
      obj.type.startsWith('house-') && 
      !obj.type.includes('roof') &&
      obj.type !== 'ground'
    );
    
    if (structures.length === 0) {
      return { x: 0, y: 0, z: 0 };
    }
    
    if (structures.length === 1) {
      // Position next to the existing structure
      const existing = structures[0];
      return { x: existing.position.x + 4, y: 0, z: existing.position.z };
    }
    
    // If multiple structures, try to position between them or extend the layout
    const avgX = structures.reduce((sum, obj) => sum + obj.position.x, 0) / structures.length;
    const avgZ = structures.reduce((sum, obj) => sum + obj.position.z, 0) / structures.length;
    
    if (type === 'house-hallway') {
      // Hallways should connect structures
      return { x: avgX, y: 0, z: avgZ };
    } else {
      // Other structures should extend the layout
      const maxX = Math.max(...structures.map(obj => obj.position.x));
      return { x: maxX + 4, y: 0, z: avgZ };
    }
  }

  /**
   * Extract spatial context from user prompt
   */
  private extractSpatialContext(prompt: string, sceneObjects: SceneObject[]): { 
    spatialRelationDetected: boolean; 
    description: string;
    referenceObject?: SceneObject;
    relation?: string;
  } {
    const lowerPrompt = prompt.toLowerCase();
    
    // Spatial relationship patterns
    const spatialPatterns = [
      { pattern: /on top of|on|above/, relation: 'on-top-of' },
      { pattern: /beside|next to|near/, relation: 'beside' },
      { pattern: /in front of|front/, relation: 'in-front-of' },
      { pattern: /behind/, relation: 'behind' },
      { pattern: /below|under/, relation: 'below' }
    ];

    let detectedRelation: string | undefined;
    let description = '';

    for (const { pattern, relation } of spatialPatterns) {
      if (pattern.test(lowerPrompt)) {
        detectedRelation = relation;
        break;
      }
    }

    if (detectedRelation) {
      // Try to find the reference object
      const colorMatches = lowerPrompt.match(/(red|blue|green|yellow|purple|orange|pink|cyan|brown|gray|tan)\s+(cube|sphere|cylinder|box|ball)/g);
      const typeMatches = lowerPrompt.match(/(cube|sphere|cylinder|box|ball|house|room|hallway)/g);
      
      let referenceObject: SceneObject | undefined;
      
      if (colorMatches && colorMatches.length > 0) {
        const colorMatch = colorMatches[0];
        referenceObject = this.findObjectByDescription(colorMatch, sceneObjects);
      } else if (typeMatches && typeMatches.length > 0) {
        const typeMatch = typeMatches[0];
        referenceObject = this.findObjectByDescription(typeMatch, sceneObjects);
      }

      if (referenceObject) {
        const refDimensions = this.getObjectDimensions(referenceObject);
        const colorName = this.getColorName(referenceObject.color);
        description = `Reference object: ${colorName} ${referenceObject.type} at (${referenceObject.position.x.toFixed(1)}, ${referenceObject.position.y.toFixed(1)}, ${referenceObject.position.z.toFixed(1)}) with dimensions ${refDimensions.width.toFixed(1)}√ó${refDimensions.height.toFixed(1)}√ó${refDimensions.depth.toFixed(1)}`;
        
        return {
          spatialRelationDetected: true,
          description,
          referenceObject,
          relation: detectedRelation
        };
      }
    }

    return {
      spatialRelationDetected: false,
      description: ''
    };
  }

  /**
   * Enhance the AI response with spatial intelligence
   */
  private enhanceCommandsWithSpatialLogic(commands: SceneCommand[], sceneObjects: SceneObject[]): SceneCommand[] {
    const enhancedCommands: SceneCommand[] = [];
    
    commands.forEach(command => {
      // Handle align commands - pass through without modification as they contain all needed info
      if (command.action === 'align') {
        enhancedCommands.push(command);
        return;
      }
      
      // Handle spatial relationships for creation, movement, and rotation
      if ((command.action === 'create' || command.action === 'move' || command.action === 'rotate') && command.relativeToObject && command.spatialRelation) {
        const referenceObject = this.findObjectByDescription(command.relativeToObject, sceneObjects);
        
        if (referenceObject) {
          // Create a temporary object to calculate dimensions
          const tempObject: SceneObject = {
            id: 'temp',
            type: command.type || 'cube',
            position: new Vector3(0, 0, 0),
            scale: new Vector3(1, 1, 1),
            rotation: new Vector3(0, 0, 0),
            color: command.color || '#ffffff',
            isNurbs: false
          };

          const placementResult = this.calculatePreciseSpatialPlacement(
            tempObject,
            referenceObject,
            command.spatialRelation,
            sceneObjects
          );

          // Create the primary command (create/move) with position and embedded scale
          const primaryCommand: SceneCommand = {
            ...command,
            x: placementResult.position.x,
            y: placementResult.position.y,
            z: placementResult.position.z,
            matchDimensions: placementResult.matchDimensions,
            contactType: 'direct'
          };

          // If dimension matching is needed, embed scale in the create command
          if (placementResult.scale && command.action === 'create') {
            primaryCommand.scaleX = placementResult.scale.x;
            primaryCommand.scaleY = placementResult.scale.y;
            primaryCommand.scaleZ = placementResult.scale.z;
          }

          enhancedCommands.push(primaryCommand);

          // For move commands, add a separate scale command if needed
          if (placementResult.scale && command.action === 'move' && command.objectId) {
            const scaleCommand: SceneCommand = {
              action: 'scale',
              objectId: command.objectId,
              scaleX: placementResult.scale.x,
              scaleY: placementResult.scale.y,
              scaleZ: placementResult.scale.z
            };
            enhancedCommands.push(scaleCommand);
          }
        } else {
          // If reference object not found, use original command
          enhancedCommands.push(command);
        }
      } else {
        // Handle architectural positioning (existing logic)
        if (command.action === 'create') {
          if (command.type?.startsWith('house-')) {
            if (command.type.includes('roof')) {
              // Enhanced roof positioning
              const targetStructure = this.findBestStructureForRoof(sceneObjects);
              if (targetStructure) {
                const roofPlacement = this.calculateRoofPlacement(
                  command.type,
                  targetStructure,
                  sceneObjects
                );
                
                const roofCommand: SceneCommand = {
                  ...command,
                  x: roofPlacement.position.x,
                  y: roofPlacement.position.y,
                  z: roofPlacement.position.z,
                  scaleX: roofPlacement.scale.x,
                  scaleY: roofPlacement.scale.y,
                  scaleZ: roofPlacement.scale.z,
                  matchDimensions: true,
                  contactType: 'direct'
                };
                
                enhancedCommands.push(roofCommand);
              } else {
                // No structure found, use original logic
                const roofPos = this.findRoofPosition(sceneObjects);
                if (roofPos && command.x === undefined && command.y === undefined && command.z === undefined) {
                  enhancedCommands.push({ ...command, ...roofPos });
                } else {
                  enhancedCommands.push(command);
                }
              }
            } else {
              // Other housing structures
              const connectionPos = this.findConnectionPosition(sceneObjects, command.type);
              if (command.x === undefined && command.y === undefined && command.z === undefined) {
                enhancedCommands.push({ ...command, ...connectionPos });
              } else {
                enhancedCommands.push(command);
              }
            }
          } else {
            // Non-housing objects
            enhancedCommands.push(command);
          }
          
          // Set default colors for housing objects if not specified
          if (command.type?.startsWith('house-') && !command.color) {
            const colorMap: { [key: string]: string } = {
              'house-basic': '#8B4513',
              'house-room': '#DEB887',
              'house-hallway': '#808080',
              'house-roof-flat': '#654321',
              'house-roof-pitched': '#654321'
            };
            const lastCommand = enhancedCommands[enhancedCommands.length - 1];
            if (lastCommand) {
              lastCommand.color = colorMap[command.type] || '#8B4513';
            }
          }
        } else {
          // Non-create actions
          enhancedCommands.push(command);
        }
      }
    });
    
    return enhancedCommands;
  }

  /**
   * Find the best structure to place a roof on
   */
  private findBestStructureForRoof(sceneObjects: SceneObject[]): SceneObject | null {
    // Look for rooms first, then basic houses
    const structures = sceneObjects.filter(obj => 
      obj.type.startsWith('house-') && 
      !obj.type.includes('roof') &&
      obj.type !== 'ground'
    );
    
    // Prioritize rooms over basic houses
    const room = structures.find(obj => obj.type === 'house-room');
    if (room) return room;
    
    const basicHouse = structures.find(obj => obj.type === 'house-basic');
    if (basicHouse) return basicHouse;
    
    // Return first available structure
    return structures[0] || null;
  }

  /**
   * Validate if the service is properly initialized
   */
  public isReady(): boolean {
    return !!this.openai;
  }
}

/**
 * Factory function to create AI service instance
 */
export const createAIService = (apiKey: string): AIService => {
  return new AIService(apiKey);
};
</file>

<file path="src/babylon/sceneManager.ts">
import { 
  Engine, 
  Scene, 
  ArcRotateCamera, 
  Vector3, 
  HemisphericLight, 
  MeshBuilder, 
  StandardMaterial, 
  Color3, 
  Mesh, 
  GizmoManager,
  PointerEventTypes,
  PickingInfo,
  Matrix,
  Quaternion,
  Texture
} from 'babylonjs'
import type { SceneObject, PrimitiveType, TransformMode, ConnectionPoint, TextureAsset, TextureType } from '../types/types'
import { createHousingMesh } from './housingFactory'
import { TextureManager } from './textureManager'


export class SceneManager {
  private engine: Engine | null = null
  private scene: Scene | null = null
  private camera: ArcRotateCamera | null = null
  private gizmoManager: GizmoManager | null = null
  private meshMap: Map<string, Mesh> = new Map()
  private gridMesh: Mesh | null = null
  private multiSelectPivot: Mesh | null = null
  private pointerDownPosition: { x: number, y: number } | null = null
  private collisionDetectionEnabled: boolean = false
  private textureManager: TextureManager | null = null
  
  // Event callbacks
  private onObjectClickCallback?: (pickInfo: PickingInfo, isCtrlHeld: boolean) => void
  private onObjectHoverCallback?: (pickInfo: PickingInfo) => void
  private getTextureAssetCallback?: (textureId: string) => TextureAsset | undefined

  constructor() {
    // Initialize empty - call initialize() after construction
  }

  public initialize(canvas: HTMLCanvasElement): boolean {
    try {
      console.log('üöÄ Initializing Babylon.js scene...')
      
      // Create engine and scene
      this.engine = new Engine(canvas, true)
      this.scene = new Scene(this.engine)
      
      // Initialize texture manager
      this.textureManager = new TextureManager(this.scene)
      
      // Enable collision detection by default
      this.scene.collisionsEnabled = this.collisionDetectionEnabled
      
      // Create camera
      this.camera = new ArcRotateCamera('camera', -Math.PI / 2, Math.PI / 2.5, 10, Vector3.Zero(), this.scene)
      this.camera.attachControl(canvas, true)
      
      // Create gizmo manager
      this.gizmoManager = new GizmoManager(this.scene)
      this.gizmoManager.positionGizmoEnabled = false
      this.gizmoManager.rotationGizmoEnabled = false
      this.gizmoManager.scaleGizmoEnabled = false
      this.gizmoManager.boundingBoxGizmoEnabled = false
      this.gizmoManager.usePointerToAttachGizmos = false
      
      // Create light
      const light = new HemisphericLight('light', new Vector3(0, 1, 0), this.scene)
      light.intensity = 0.7
      
      // Set up pointer events
      this.setupPointerEvents()
      
      // Start render loop
      this.engine.runRenderLoop(() => {
        this.scene?.render()
      })
      
      // Handle resize
      const handleResize = () => {
        this.engine?.resize()
      }
      window.addEventListener('resize', handleResize)
      
      console.log('‚úÖ Scene initialized successfully')
      return true
    } catch (error) {
      console.error('‚ùå Error initializing Babylon.js scene:', error)
      return false
    }
  }



  private setupPointerEvents(): void {
    if (!this.scene) return;

    // Use POINTERPICK for reliable click-selection events (fires when a mesh is picked)
    // and fall back to computing a fresh pick result if the provided pickInfo is undefined.
    this.scene.onPointerObservable.add((pointerInfo) => {
      switch (pointerInfo.type) {
        case PointerEventTypes.POINTERDOWN: {
          // Record initial pointer location for click-vs-drag test
          this.pointerDownPosition = { x: this.scene!.pointerX, y: this.scene!.pointerY }
          break
        }

        case PointerEventTypes.POINTERUP: {
          // Treat as a click only if pointer hasn‚Äôt moved too far
          const clickThreshold = 5 // pixels
          if (this.pointerDownPosition) {
            const deltaX = Math.abs(this.pointerDownPosition.x - this.scene!.pointerX)
            const deltaY = Math.abs(this.pointerDownPosition.y - this.scene!.pointerY)

            if (deltaX < clickThreshold && deltaY < clickThreshold) {
              const pickInfo = pointerInfo.pickInfo ?? this.scene?.pick(this.scene.pointerX, this.scene.pointerY)
              const isGizmoClick = pickInfo?.pickedMesh?.name?.toLowerCase().includes('gizmo')

              if (pickInfo && pickInfo.hit && !isGizmoClick) {
                const isCtrlHeld = (pointerInfo.event as PointerEvent).ctrlKey || (pointerInfo.event as PointerEvent).metaKey
                this.onObjectClickCallback?.(pickInfo, isCtrlHeld)
              } else if (!pickInfo?.hit) {
                // Clicked empty space ‚Äì still notify for deselection logic
                this.onObjectClickCallback?.(pickInfo as any, false)
              }
            }
          }
          // reset tracker
          this.pointerDownPosition = null
          break
        }
        
        case PointerEventTypes.POINTERMOVE:
          // For hover events, we can use POINTERMOVE.
          if (this.onObjectHoverCallback) {
            const pickInfo = this.scene?.pick(this.scene.pointerX, this.scene.pointerY);
            if (pickInfo) {
              this.onObjectHoverCallback(pickInfo);
            }
          }
          break;
      }
    });
  }

  public addMesh(sceneObject: SceneObject): boolean {
    if (!this.scene) return false
    
    console.log(`üîß SceneManager.addMesh called for: ${sceneObject.id} (${sceneObject.type})`)
    
    try {
      let mesh: Mesh
      
      // Check if it's a housing type
      if (sceneObject.type.startsWith('house-')) {
        mesh = createHousingMesh(sceneObject.type, this.scene, {
          name: sceneObject.id,
          color: sceneObject.color
        })
      } else {
        switch (sceneObject.type) {
          case 'cube':
            mesh = MeshBuilder.CreateBox(sceneObject.id, { size: 2 }, this.scene)
            break
          case 'sphere':
            mesh = MeshBuilder.CreateSphere(sceneObject.id, { diameter: 2 }, this.scene)
            break
          case 'cylinder':
            mesh = MeshBuilder.CreateCylinder(sceneObject.id, { diameter: 2, height: 2 }, this.scene)
            break
          case 'plane':
            mesh = MeshBuilder.CreatePlane(sceneObject.id, { size: 2 }, this.scene)
            break
          case 'torus':
            mesh = MeshBuilder.CreateTorus(sceneObject.id, { diameter: 2, thickness: 0.5 }, this.scene)
            break
          case 'cone':
            mesh = MeshBuilder.CreateCylinder(sceneObject.id, { diameterTop: 0, diameterBottom: 2, height: 2 }, this.scene)
            break
          case 'ground':
            // Ground already exists, just update properties and ensure it's stored with the correct ID
            const existingGround = this.meshMap.get('ground')
            if (existingGround) {
              // Update the ground mesh's name to match the scene object ID
              existingGround.name = sceneObject.id
              // If the ID is different, also store it with the new key
              if (sceneObject.id !== 'ground') {
                this.meshMap.set(sceneObject.id, existingGround)
              }
              this.updateMeshProperties(sceneObject.id, sceneObject)
            }
            return true
          case 'imported-glb':
          case 'imported-stl':
          case 'imported-obj':
            // For imported models, we need to retrieve the mesh from scene by ID
            // The mesh should already be in the scene from the import process
            const importedMesh = this.scene.getMeshById(sceneObject.id)
            if (!importedMesh || !(importedMesh instanceof Mesh)) {
              console.error(`‚ùå Imported mesh ${sceneObject.id} not found in scene`)
              return false
            }
            mesh = importedMesh
            break
          case 'custom-room':
            // Custom rooms are generated procedurally outside the factory (e.g., via cloning)
            // Simply look up an existing mesh with the same ID that should have been
            // added via addPreExistingMesh. If it exists, register it; otherwise warn.
            const roomMesh = this.scene.getMeshById(sceneObject.id)
            if (!roomMesh || !(roomMesh instanceof Mesh)) {
              console.error(`‚ùå Custom room mesh ${sceneObject.id} not found in scene`)
              return false
            }
            mesh = roomMesh
            break
          default:
            console.warn(`Unknown primitive type: ${sceneObject.type}`)
            return false
        }
      }
      
      // Generate default connection points (face centers) for box-like meshes
      const bounding = mesh.getBoundingInfo()
      if (bounding) {
        const min = bounding.minimum.clone()
        const max = bounding.maximum.clone()
        const halfX = (max.x - min.x) / 2
        const halfY = (max.y - min.y) / 2
        const halfZ = (max.z - min.z) / 2
        const cps: ConnectionPoint[] = [
          { id: 'px', position: new Vector3(halfX, 0, 0), normal: new Vector3(1, 0, 0) },
          { id: 'nx', position: new Vector3(-halfX, 0, 0), normal: new Vector3(-1, 0, 0) },
          { id: 'py', position: new Vector3(0, halfY, 0), normal: new Vector3(0, 1, 0) },
          { id: 'ny', position: new Vector3(0, -halfY, 0), normal: new Vector3(0, -1, 0) },
          { id: 'pz', position: new Vector3(0, 0, halfZ), normal: new Vector3(0, 0, 1) },
          { id: 'nz', position: new Vector3(0, 0, -halfZ), normal: new Vector3(0, 0, -1) },
        ]
        if (!mesh.metadata) mesh.metadata = {}
        ;(mesh.metadata as any).connectionPoints = cps
      }

      // Set initial properties
      mesh.position = sceneObject.position.clone()
      mesh.rotation = sceneObject.rotation.clone()
      mesh.scaling = sceneObject.scale.clone()
      
      // Ensure the mesh ID and name are set to our object ID for reliable picking
      mesh.id = sceneObject.id
      mesh.name = sceneObject.id
      
      // Create material (for non-housing types or if housing mesh doesn't have material)
      if (!sceneObject.type.startsWith('house-') && !sceneObject.type.startsWith('imported-') || !mesh.material) {
        const material = new StandardMaterial(`${sceneObject.id}-material`, this.scene)
        material.diffuseColor = Color3.FromHexString(sceneObject.color)
        mesh.material = material
      }
      
      mesh.isPickable = true
      mesh.checkCollisions = this.collisionDetectionEnabled
      
      // Store mesh reference
      this.meshMap.set(sceneObject.id, mesh)
      
      console.log(`‚úÖ Added mesh: ${sceneObject.id}`, {
        meshName: mesh.name,
        meshId: mesh.id,
        isPickable: mesh.isPickable,
        position: mesh.position,
        hasMap: this.meshMap.has(sceneObject.id)
      })
      return true
    } catch (error) {
      console.error(`‚ùå Error adding mesh ${sceneObject.id}:`, error)
      return false
    }
  }

  public removeMeshById(id: string): boolean {
    const mesh = this.meshMap.get(id)
    if (!mesh) return false
    
    try {
      mesh.dispose()
      this.meshMap.delete(id)
      console.log(`‚úÖ Removed mesh: ${id}`)
      return true
    } catch (error) {
      console.error(`‚ùå Error removing mesh ${id}:`, error)
      return false
    }
  }

  public updateMeshProperties(id: string, sceneObject: Partial<SceneObject>): boolean {
    const mesh = this.meshMap.get(id)
    if (!mesh) return false
    
    try {
      // Update transform properties only if they've been provided
      if (sceneObject.position && !mesh.position.equals(sceneObject.position)) {
        mesh.position.copyFrom(sceneObject.position)
      }
      if (sceneObject.rotation && !mesh.rotation.equals(sceneObject.rotation)) {
        if (mesh.rotationQuaternion) {
          // Keep quaternion in sync with requested Euler to satisfy gizmo / bounding-box expectations
          const newQuat = Quaternion.RotationYawPitchRoll(
            sceneObject.rotation.y,
            sceneObject.rotation.x,
            sceneObject.rotation.z
          )
          mesh.rotationQuaternion.copyFrom(newQuat)
          // Also store Euler (helps when gizmos are detached later)
          mesh.rotation.copyFrom(sceneObject.rotation)
          console.log(`üîÑ SceneManager: Updated rotationQuaternion for mesh ${id}`)
        } else {
          mesh.rotation.copyFrom(sceneObject.rotation)
        }
        console.log(`üîÑ SceneManager: Applied rotation to mesh ${id}: (${sceneObject.rotation.x.toFixed(3)}, ${sceneObject.rotation.y.toFixed(3)}, ${sceneObject.rotation.z.toFixed(3)})`)
      }
      if (sceneObject.scale && !mesh.scaling.equals(sceneObject.scale)) {
        mesh.scaling.copyFrom(sceneObject.scale)
      }
      
      // Update material color if it has been provided and changed
      if (sceneObject.color && mesh.material && mesh.material instanceof StandardMaterial) {
        if (mesh.material.diffuseColor.toHexString() !== sceneObject.color) {
          mesh.material.diffuseColor = Color3.FromHexString(sceneObject.color)
        }
      }
      
      // Handle texture updates
      if ('textureIds' in sceneObject && this.textureManager && mesh.material) {
        console.log('üé® Texture update detected:', {
          meshId: id,
          textureIds: sceneObject.textureIds,
          hasMaterial: !!mesh.material,
          materialType: mesh.material.constructor.name
        });
        
        // If textureIds is empty, null, or undefined, remove all textures
        if (!sceneObject.textureIds || Object.keys(sceneObject.textureIds).length === 0) {
          const material = mesh.material as StandardMaterial;
          console.log('üóëÔ∏è Removing all textures from mesh:', id);
          // Remove all textures
          material.diffuseTexture = null;
          material.bumpTexture = null;
          material.specularTexture = null;
          material.emissiveTexture = null;
          
          // Restore the original diffuse color from the scene object
          // The color should be passed in the update when textures are removed
          if (sceneObject.color) {
            console.log('üé® Restoring original color:', sceneObject.color);
            material.diffuseColor = Color3.FromHexString(sceneObject.color);
          }
        } else {
          // Apply each texture type
          for (const [textureType, textureId] of Object.entries(sceneObject.textureIds)) {
            console.log(`üñºÔ∏è Applying ${textureType} texture:`, textureId);
            const textureAsset = this.getTextureAssetCallback?.(textureId);
            console.log('üì¶ Texture asset retrieved:', textureAsset);
            
            if (textureAsset) {
              // Create or get cached texture
              const texture = this.textureManager.createBabylonTexture(textureAsset);
              console.log('‚ú® Babylon texture created:', {
                name: texture.name,
                url: texture.url,
                hasTexture: !!texture
              });
              
              // Apply texture based on type
              const material = mesh.material as StandardMaterial;
              switch (textureType) {
                case 'diffuse':
                  console.log('üé® Applying diffuse texture');
                  this.textureManager.applyDiffuseTexture(material, texture);
                  // Ensure the texture is visible by setting diffuse color to white
                  // This allows the texture to show properly without color tinting
                  material.diffuseColor = new Color3(1, 1, 1);
                  break;
                case 'normal':
                  console.log('üèîÔ∏è Applying normal/bump texture');
                  this.textureManager.applyNormalTexture(material, texture);
                  break;
                case 'specular':
                  console.log('‚ú® Applying specular texture');
                  this.textureManager.applySpecularTexture(material, texture);
                  break;
                case 'emissive':
                  console.log('üí° Applying emissive texture');
                  this.textureManager.applyEmissiveTexture(material, texture);
                  break;
              }
              
              // Apply scale and offset if they exist
              if (sceneObject.textureScale) {
                this.textureManager.setTextureScale(texture, sceneObject.textureScale);
              }
              if (sceneObject.textureOffset) {
                this.textureManager.setTextureOffset(texture, sceneObject.textureOffset);
              }
              
              console.log('‚úÖ Texture applied successfully');
            } else {
              console.error('‚ùå Failed to retrieve texture asset for:', textureId);
            }
          }
        }
      }
      
      // Handle texture scale for existing textures
      if (sceneObject.textureScale && mesh.material instanceof StandardMaterial && this.textureManager) {
        const material = mesh.material;
        if (material.diffuseTexture) {
          this.textureManager.setTextureScale(material.diffuseTexture as Texture, sceneObject.textureScale);
        }
        if (material.bumpTexture) {
          this.textureManager.setTextureScale(material.bumpTexture as Texture, sceneObject.textureScale);
        }
        if (material.specularTexture) {
          this.textureManager.setTextureScale(material.specularTexture as Texture, sceneObject.textureScale);
        }
        if (material.emissiveTexture) {
          this.textureManager.setTextureScale(material.emissiveTexture as Texture, sceneObject.textureScale);
        }
      }
      
      // Handle texture offset for existing textures
      if (sceneObject.textureOffset && mesh.material instanceof StandardMaterial && this.textureManager) {
        const material = mesh.material;
        if (material.diffuseTexture) {
          this.textureManager.setTextureOffset(material.diffuseTexture as Texture, sceneObject.textureOffset);
        }
        if (material.bumpTexture) {
          this.textureManager.setTextureOffset(material.bumpTexture as Texture, sceneObject.textureOffset);
        }
        if (material.specularTexture) {
          this.textureManager.setTextureOffset(material.specularTexture as Texture, sceneObject.textureOffset);
        }
        if (material.emissiveTexture) {
          this.textureManager.setTextureOffset(material.emissiveTexture as Texture, sceneObject.textureOffset);
        }
      }
      
      return true
    } catch (error) {
      console.error(`‚ùå Error updating mesh ${id}:`, error)
      return false
    }
  }

  public getMeshById(id: string): Mesh | null {
    // Direct lookup
    const direct = this.meshMap.get(id)
    if (direct) return direct

    // Fallback: the id may belong to a child mesh: climb each stored mesh‚Äôs parent tree
    for (const root of this.meshMap.values()) {
      if (!root) continue
      let current: Mesh | null = root
      while (current) {
        if (current.name === id || current.id === id) {
          return root // return the top-level mesh we manage
        }
        current = current.parent as Mesh | null
      }
    }
    return null
  }

  /**
   * Adds a pre-existing mesh to the scene manager
   * Used for imported meshes that are already created (like from GLB import)
   */
  public addPreExistingMesh(mesh: Mesh, id: string): boolean {
    if (!this.scene || !mesh) return false
    
    try {
      // Ensure the mesh is part of this scene
      if (mesh.getScene() !== this.scene) {
        console.error(`‚ùå Mesh ${id} is not part of the current scene`)
        return false
      }
      
      // Set mesh properties for proper management
      mesh.id = id
      mesh.name = id
      mesh.isPickable = true
      mesh.checkCollisions = this.collisionDetectionEnabled
      
      // Store mesh reference
      this.meshMap.set(id, mesh)
      
      console.log(`‚úÖ Added pre-existing mesh: ${id}`, {
        meshName: mesh.name,
        meshId: mesh.id,
        isPickable: mesh.isPickable,
        hasMap: this.meshMap.has(id)
      })
      
      return true
    } catch (error) {
      console.error(`‚ùå Error adding pre-existing mesh ${id}:`, error)
      return false
    }
  }

  public setWireframeMode(enabled: boolean): void {
    this.meshMap.forEach((mesh, id) => {
      if (id !== 'ground' && mesh.material instanceof StandardMaterial) {
        mesh.material.wireframe = enabled
      }
    })
  }

  public setMeshVisibility(id: string, visible: boolean): void {
    const mesh = this.meshMap.get(id)
    if (mesh) {
      mesh.isVisible = visible
    }
  }

  public setMeshEmissive(id: string, color: Color3): void {
    const mesh = this.meshMap.get(id)
    if (mesh && mesh.material instanceof StandardMaterial) {
      mesh.material.emissiveColor = color
    }
  }

  public setCollisionDetectionEnabled(enabled: boolean): void {
    this.collisionDetectionEnabled = enabled
    console.log(`üîß Collision detection ${enabled ? 'enabled' : 'disabled'}`)
    
    // Update all existing meshes
    this.meshMap.forEach((mesh, id) => {
      if (id !== 'ground') { // Ground should always have collision
        mesh.checkCollisions = enabled
        if (this.scene) {
          // Enable/disable collision detection for the scene
          this.scene.collisionsEnabled = enabled
        }
      }
    })
  }

  public isCollisionDetectionEnabled(): boolean {
    return this.collisionDetectionEnabled
  }

  public checkCollisionAtPosition(meshId: string, newPosition: Vector3): boolean {
    if (!this.collisionDetectionEnabled || !this.scene) return false
    
    const mesh = this.meshMap.get(meshId)
    if (!mesh) return false
    
    // Store original position
    const originalPosition = mesh.position.clone()
    
    // Temporarily move mesh to new position for collision testing
    mesh.position = newPosition
    mesh.computeWorldMatrix(true)
    
    let hasCollision = false
    
    // Check collision with all other meshes (except ground and itself)
    this.meshMap.forEach((otherMesh, otherId) => {
      if (otherId !== meshId && otherId !== 'ground' && !hasCollision) {
        if (mesh.intersectsMesh(otherMesh, true)) {
          hasCollision = true
          console.log(`üö´ Collision detected between ${meshId} and ${otherId}`)
        }
      }
    })
    
    // Restore original position
    mesh.position = originalPosition
    mesh.computeWorldMatrix(true)
    
    return hasCollision
  }

  public checkCollisionAtTransform(meshId: string, newPosition: Vector3, newRotation?: Vector3, newScale?: Vector3): boolean {
    if (!this.collisionDetectionEnabled || !this.scene) return false
    
    const mesh = this.meshMap.get(meshId)
    if (!mesh) return false
    
    // Store original transform
    const originalPosition = mesh.position.clone()
    const originalRotation = mesh.rotation.clone()
    const originalScale = mesh.scaling.clone()
    
    // Apply new transform for collision testing
    mesh.position = newPosition
    if (newRotation) mesh.rotation = newRotation
    if (newScale) mesh.scaling = newScale
    mesh.computeWorldMatrix(true)
    
    let hasCollision = false
    
    // Check collision with all other meshes (except ground and itself)
    this.meshMap.forEach((otherMesh, otherId) => {
      if (otherId !== meshId && otherId !== 'ground' && !hasCollision) {
        if (mesh.intersectsMesh(otherMesh, true)) {
          hasCollision = true
          console.log(`üö´ Transform collision detected between ${meshId} and ${otherId}`)
        }
      }
    })
    
    // Restore original transform
    mesh.position = originalPosition
    mesh.rotation = originalRotation
    mesh.scaling = originalScale
    mesh.computeWorldMatrix(true)
    
    return hasCollision
  }

  public createVisualGrid(enabled: boolean, gridSize: number): void {
    // Remove existing grid
    if (this.gridMesh) {
      this.gridMesh.dispose()
      this.gridMesh = null
    }
    
    if (!enabled || !this.scene) return
    
    // Create grid lines
    const gridExtent = 20
    const lines = []
    
    // Vertical lines (along Z-axis)
    for (let i = -gridExtent; i <= gridExtent; i += gridSize) {
      lines.push([
        new Vector3(i, 0, -gridExtent),
        new Vector3(i, 0, gridExtent)
      ])
    }
    
    // Horizontal lines (along X-axis)
    for (let i = -gridExtent; i <= gridExtent; i += gridSize) {
      lines.push([
        new Vector3(-gridExtent, 0, i),
        new Vector3(gridExtent, 0, i)
      ])
    }
    
    // Create line system
    const lineSystem = MeshBuilder.CreateLineSystem('grid', { lines }, this.scene)
    lineSystem.color = new Color3(0.5, 0.5, 0.5)
    lineSystem.alpha = 0.3
    lineSystem.isPickable = false
    
    this.gridMesh = lineSystem
  }

  public createMultiSelectPivot(centerPosition: Vector3): Mesh | null {
    if (!this.scene) return null
    
    // Remove existing pivot
    if (this.multiSelectPivot) {
      this.multiSelectPivot.dispose()
      this.multiSelectPivot = null
    }
    
    // Create invisible pivot mesh
    const pivot = MeshBuilder.CreateSphere('multi-select-pivot', { diameter: 0.1 }, this.scene)
    pivot.position = centerPosition
    pivot.rotation = new Vector3(0, 0, 0)
    pivot.scaling = new Vector3(1, 1, 1)
    pivot.isVisible = false
    pivot.isPickable = false
    
    this.multiSelectPivot = pivot
    return pivot
  }

  public removeMultiSelectPivot(): void {
    if (this.multiSelectPivot) {
      this.multiSelectPivot.dispose()
      this.multiSelectPivot = null
    }
  }

  public setCameraView(view: 'front' | 'back' | 'left' | 'right' | 'top' | 'bottom' | 'home'): void {
    if (!this.camera) return
    
    const camera = this.camera
    const radius = camera.radius
    
    switch (view) {
      case 'front':
        camera.setTarget(Vector3.Zero())
        camera.setPosition(new Vector3(0, 0, radius))
        break
      case 'back':
        camera.setTarget(Vector3.Zero())
        camera.setPosition(new Vector3(0, 0, -radius))
        break
      case 'left':
        camera.setTarget(Vector3.Zero())
        camera.setPosition(new Vector3(-radius, 0, 0))
        break
      case 'right':
        camera.setTarget(Vector3.Zero())
        camera.setPosition(new Vector3(radius, 0, 0))
        break
      case 'top':
        camera.setTarget(Vector3.Zero())
        camera.setPosition(new Vector3(0, radius, 0))
        break
      case 'bottom':
        camera.setTarget(Vector3.Zero())
        camera.setPosition(new Vector3(0, -radius, 0))
        break
      case 'home':
        camera.setTarget(Vector3.Zero())
        camera.setPosition(new Vector3(10, 10, 10))
        break
    }
  }

  public focusOnPosition(position: Vector3): void {
    if (this.camera) {
      this.camera.setTarget(position)
    }
  }

  public setupGizmos(
    transformMode: TransformMode,
    targetMesh: Mesh | null,
    onDragEnd: (position: Vector3, rotation: Vector3, scale: Vector3) => void
  ): void {
    if (!this.gizmoManager) return
    
    // Clean up existing observers
    this.cleanupGizmoObservers()
    
    // Detach from any previous mesh and disable all gizmos
    this.gizmoManager.attachToMesh(null)
    this.gizmoManager.positionGizmoEnabled = false
    this.gizmoManager.rotationGizmoEnabled = false
    this.gizmoManager.scaleGizmoEnabled = false
    this.gizmoManager.boundingBoxGizmoEnabled = false
    
    if (!targetMesh) return
    
    // Attach to target mesh
    this.gizmoManager.attachToMesh(targetMesh)
    
    // Enable the correct gizmo based on transform mode
    switch (transformMode) {
      case 'move':
        this.gizmoManager.positionGizmoEnabled = true
        break
      case 'rotate':
        this.gizmoManager.rotationGizmoEnabled = true
        break
      case 'scale':
        this.gizmoManager.scaleGizmoEnabled = true
        break
      case 'select':
        this.gizmoManager.boundingBoxGizmoEnabled = true
        break
    }
    
    // Set up observers
    this.setupGizmoObservers(onDragEnd)
  }

  private gizmoObservers: any[] = []

  private setupGizmoObservers(onDragEnd: (position: Vector3, rotation: Vector3, scale: Vector3) => void): void {
    if (!this.gizmoManager) return
    
    const { positionGizmo, rotationGizmo, scaleGizmo } = this.gizmoManager.gizmos
    
    if (positionGizmo) {
      const observer = positionGizmo.onDragEndObservable.add(() => {
        const attachedMesh = this.gizmoManager?.attachedMesh
        if (attachedMesh) {
          onDragEnd(attachedMesh.position, attachedMesh.rotation, attachedMesh.scaling)
        }
      })
      this.gizmoObservers.push({ gizmo: positionGizmo, observer })
    }
    
    if (rotationGizmo) {
      const observer = rotationGizmo.onDragEndObservable.add(() => {
        const attachedMesh = this.gizmoManager?.attachedMesh
        if (attachedMesh) {
          onDragEnd(attachedMesh.position, attachedMesh.rotation, attachedMesh.scaling)
        }
      })
      this.gizmoObservers.push({ gizmo: rotationGizmo, observer })
    }
    
    if (scaleGizmo) {
      const observer = scaleGizmo.onDragEndObservable.add(() => {
        const attachedMesh = this.gizmoManager?.attachedMesh
        if (attachedMesh) {
          onDragEnd(attachedMesh.position, attachedMesh.rotation, attachedMesh.scaling)
        }
      })
      this.gizmoObservers.push({ gizmo: scaleGizmo, observer })
    }
  }

  private cleanupGizmoObservers(): void {
    this.gizmoObservers.forEach(({ gizmo, observer }) => {
      gizmo.onDragEndObservable.remove(observer)
    })
    this.gizmoObservers = []
  }

  // Direct object selection handling (removed - now handled in React hooks)

  public setObjectClickCallback(callback: (pickInfo: PickingInfo, isCtrlHeld: boolean) => void): void {
    console.log('üîó SceneManager: Setting object click callback')
    this.onObjectClickCallback = callback
    console.log('üîó SceneManager: Callback set, type:', typeof callback)
  }

  public setObjectHoverCallback(callback: (pickInfo: PickingInfo) => void): void {
    console.log('üîó SceneManager: Setting object hover callback')
    this.onObjectHoverCallback = callback
  }

  public setTextureAssetCallback(callback: (textureId: string) => TextureAsset | undefined): void {
    console.log('üîó SceneManager: Setting texture asset callback')
    this.getTextureAssetCallback = callback
  }

  public snapToGrid(position: Vector3, gridSize: number): Vector3 {
    return new Vector3(
      Math.round(position.x / gridSize) * gridSize,
      Math.round(position.y / gridSize) * gridSize,
      Math.round(position.z / gridSize) * gridSize
    )
  }

  /**
   * Aligns the closest compatible connection-point pair and returns adjusted position & rotation.
   */
  public computeSnapTransform(
    meshId: string,
    desiredPosition: Vector3,
    desiredRotation: Vector3
  ): { position: Vector3; rotation: Vector3 } {
    const movingMesh = this.meshMap.get(meshId)
    if (!movingMesh) return { position: desiredPosition.clone(), rotation: desiredRotation.clone() }

    const movingCPs = ((movingMesh.metadata as any)?.connectionPoints || []) as ConnectionPoint[]
    if (!movingCPs.length) return { position: desiredPosition.clone(), rotation: desiredRotation.clone() }

    // Convert desiredRotation Euler -> Quaternion and matrix
    const desiredQuat = Quaternion.RotationYawPitchRoll(
      desiredRotation.y,
      desiredRotation.x,
      desiredRotation.z
    )
    const rotMatrixMoving = Matrix.Identity()
    desiredQuat.toRotationMatrix(rotMatrixMoving)

    const scaled = (v: Vector3, s: Vector3) => new Vector3(v.x * s.x, v.y * s.y, v.z * s.z)

    const SNAP_DISTANCE = 0.3
    let best: {
      delta: Vector3
      newQuat: Quaternion
      dist: number
    } | null = null

    const quatFromUnitVectors = (vFrom: Vector3, vTo: Vector3): Quaternion => {
      const EPS = 1e-6
      let r = vFrom.dot(vTo) + 1
      let q: Quaternion
      if (r < EPS) {
        // 180¬∞ rotation, pick orthogonal axis
        let axis = Math.abs(vFrom.x) > Math.abs(vFrom.z)
          ? new Vector3(-vFrom.y, vFrom.x, 0)
          : new Vector3(0, -vFrom.z, vFrom.y)
        axis.normalize()
        q = new Quaternion(axis.x, axis.y, axis.z, 0)
      } else {
        const axis = vFrom.cross(vTo)
        q = new Quaternion(axis.x, axis.y, axis.z, r)
        q.normalize()
      }
      return q
    }

    for (const [otherId, otherMesh] of this.meshMap.entries()) {
      if (otherId === meshId) continue
      const otherCPs = ((otherMesh.metadata as any)?.connectionPoints || []) as ConnectionPoint[]
      if (!otherCPs.length) continue

      const otherQuat = otherMesh.rotationQuaternion ?? Quaternion.RotationYawPitchRoll(
        otherMesh.rotation.y,
        otherMesh.rotation.x,
        otherMesh.rotation.z
      )
      const rotMatrixOther = Matrix.Identity()
      otherQuat.toRotationMatrix(rotMatrixOther)

      for (const cpMoving of movingCPs) {
        // moving point/normal in world after desired transform
        const worldPosMoving = Vector3.TransformCoordinates(
          scaled(cpMoving.position, movingMesh.scaling),
          rotMatrixMoving
        ).add(desiredPosition)
        const worldNormalMoving = Vector3.TransformNormal(cpMoving.normal, rotMatrixMoving).normalize()

        for (const cpOther of otherCPs) {
          const worldPosOther = Vector3.TransformCoordinates(
            scaled(cpOther.position, otherMesh.scaling),
            rotMatrixOther
          ).add(otherMesh.position)
          const worldNormalOther = Vector3.TransformNormal(cpOther.normal, rotMatrixOther).normalize()

          const dist = Vector3.Distance(worldPosMoving, worldPosOther)
          if (dist > SNAP_DISTANCE) continue

          const dot = worldNormalMoving.dot(worldNormalOther)
          const isOpposite = dot < -0.95
          const isPerp = Math.abs(dot) < 0.05
          if (!isOpposite && !isPerp) continue

          // Alignment quaternion: rotate moving normal to -otherNormal
          const alignQuat = quatFromUnitVectors(worldNormalMoving, worldNormalOther.scale(-1))
          const newQuat = alignQuat.multiply(desiredQuat)

          // Recompute moving connection point world position after rotation
          const newRotMatrix = Matrix.Identity()
          newQuat.toRotationMatrix(newRotMatrix)
          const newWorldPosMoving = Vector3.TransformCoordinates(
            scaled(cpMoving.position, movingMesh.scaling),
            newRotMatrix
          ).add(desiredPosition)

          const delta = worldPosOther.subtract(newWorldPosMoving)

          const score = dist // simple; could combine angle
          if (!best || score < best.dist) {
            best = { delta, newQuat, dist: score }
          }
        }
      }
    }

    if (best) {
      const finalPos = desiredPosition.add(best.delta)
      const finalRot = best.newQuat.toEulerAngles()
      return { position: finalPos, rotation: finalRot }
    }

    return { position: desiredPosition.clone(), rotation: desiredRotation.clone() }
  }
  // (OPTIONAL) keep old method for backward compatibility
  public computeSnapPosition(meshId: string, pos: Vector3, rot: Vector3): Vector3 {
    return this.computeSnapTransform(meshId, pos, rot).position
  }

  public getScene(): Scene | null {
    return this.scene
  }

  private connectionPointDebugMeshes: Mesh[] = []

  public visualizeConnectionPoints(enabled: boolean): void {
    if (!this.scene) return

    // Clear previous
    this.connectionPointDebugMeshes.forEach(m => m.dispose())
    this.connectionPointDebugMeshes = []

    if (!enabled) return

    const sphereMat = new StandardMaterial('cp-debug-mat', this.scene)
    sphereMat.diffuseColor = new Color3(1, 0, 1) // magenta

    this.meshMap.forEach(mesh => {
      const cps = ((mesh.metadata as any)?.connectionPoints || []) as ConnectionPoint[]
      if (!cps.length) return
      const rotMatrix = Matrix.RotationYawPitchRoll(mesh.rotation.y, mesh.rotation.x, mesh.rotation.z)
      cps.forEach(cp => {
        const s = MeshBuilder.CreateSphere('cp-debug', { diameter: 0.1 }, this.scene!)
        s.material = sphereMat
        s.isPickable = false
        // Position sphere in local space and parent to mesh so it tracks movement/rotation/scale
        s.position = cp.position.clone()
        s.parent = mesh
        this.connectionPointDebugMeshes.push(s)
      })
    })
  }

  public dispose(): void {
    this.cleanupGizmoObservers()
    // dispose debug spheres
    this.connectionPointDebugMeshes.forEach(m => m.dispose())
    this.connectionPointDebugMeshes = []
    
    if (this.gridMesh) {
      this.gridMesh.dispose()
      this.gridMesh = null
    }
    
    if (this.multiSelectPivot) {
      this.multiSelectPivot.dispose()
      this.multiSelectPivot = null
    }
    
    this.meshMap.clear()
    
    if (this.engine) {
      this.engine.dispose()
      this.engine = null
    }
    
    this.scene = null
    this.camera = null
    this.gizmoManager = null
  }
}
</file>

<file path="src/App.tsx">
import { useEffect, useRef, useMemo, useState } from 'react'
import { Vector3, Vector2, StandardMaterial, Color3, Mesh, PolygonMeshBuilder, DynamicTexture } from 'babylonjs'
import { computeCompositeBoundary, generateDefaultConnectionPoints } from './babylon/boundaryUtils'
import type { ConnectionPoint } from './types/types'
import './App.css'

// Import material presets constant (value)
import { materialPresets } from './types/types'

// Import the new hook
import { useBabylonScene } from './babylon/hooks/useBabylonScene'

// Import the new AISidebar component
import { AISidebar } from './components/sidebar/AISidebar'

// Import the CompassOverlay component
import { CompassOverlay } from './components/ui/CompassOverlay'

// Import the keyboard shortcuts hook
import { useKeyboardShortcuts } from './hooks/useKeyboardShortcuts'

import { useSceneStore } from './state/sceneStore'
import type { SceneObject, PrimitiveType, TransformMode, ControlPointVisualization } from './types/types'
import { CustomRoomModal } from './components/modals/CustomRoomModal'
import { MeshBuilder } from 'babylonjs'

function App() {
  const canvasRef = useRef<HTMLCanvasElement>(null)
  
  // Modal state for custom room drawing
  const [showCustomRoomModal, setShowCustomRoomModal] = useState(false)
  
  // Use the new babylon scene hook
  const { sceneAPI, sceneInitialized } = useBabylonScene(canvasRef)

  // Use keyboard shortcuts hook
  useKeyboardShortcuts()
  
  // Load default textures when scene is initialized
  useEffect(() => {
    if (sceneInitialized) {
      const loadDefaults = async () => {
        const { loadDefaultTextures } = useSceneStore.getState();
        await loadDefaultTextures();
      };
      loadDefaults();
    }
  }, [sceneInitialized]);

  // --- START: Reading state from the Zustand store ---
  const {
    // State properties
    sceneObjects,
    selectedObjectId,
    selectedObjectIds,
    transformMode,
    currentColor,
    isLoading,
    apiKey,
    showApiKeyInput,
    responseLog,
    wireframeMode,
    hoveredObjectId,
    multiSelectMode,
    snapToGrid,
    gridSize,
    objectLocked,
    showGrid,
    objectVisibility,
    multiSelectPivot,
    gridMesh,
    multiSelectInitialStates,
    textInput,
    sidebarCollapsed,
    activeDropdown,
    collisionDetectionEnabled,
    snapToObjects,
    showConnectionPoints,

    // Actions
    setSceneObjects,
    setSelectedObjectId,
    setSelectedObjectIds,
    setTransformMode,
    setCurrentColor,
    setIsLoading,
    setApiKey,
    setShowApiKeyInput,
    addToResponseLog,
    setWireframeMode,
    setShowGrid,
    setHoveredObjectId,
    setMultiSelectMode,
    setSnapToGrid,
    setGridSize,
    setObjectVisibility,
    setObjectLocked,
    setMultiSelectPivot,
    setGridMesh,
    setMultiSelectInitialStates,
    setTextInput,
    setSidebarCollapsed,
    setActiveDropdown,
    setResponseLog,
    clearSelection,
    clearAllObjects,
    updateObject,
    addObject,
    removeObject,
    setCollisionDetectionEnabled,
    setSnapToObjects,
    setShowConnectionPoints,
    
    // Getters from store (for checking object status)
    hasSelection,
    isObjectLocked,
    isObjectVisible,
  } = useSceneStore();
  // --- END: Reading state from the Zustand store ---

  // ---------------------------------------------------------------------------
  // Helper utils (state write) & placeholders for removed NURBS functionality
  // ---------------------------------------------------------------------------

  /**
   * Functional updater helper that keeps the ergonomic `(prev) => newArray` style
   * while complying with the store API which expects the full object array.
   */
  // Scene objects are now managed by the useBabylonScene hook

  // The application no longer supports NURBS control-points.  We define inert
  // placeholders so that the few remaining references compile but have no
  // runtime effect.
  const selectedControlPointMesh: Mesh | null = null
  const selectedControlPointIndex: number | null = null
  // No-op stubs replacing the old setters
  const setSelectedControlPointMesh = (_?: any) => {}
  const setSelectedControlPointIndex = (_?: any) => {}

  // OpenAI client initialization is now handled by the AI service

  // now use getters from the store
  // something is wrong here....
  const selectedObject = useMemo(() => 
    sceneObjects.find(obj => obj.id === selectedObjectId), 
    [sceneObjects, selectedObjectId]
  );

  const selectedObjects = useMemo(() => 
    sceneObjects.filter(obj => selectedObjectIds.includes(obj.id)), 
    [sceneObjects, selectedObjectIds]
  );

  // Boolean flag for current selection
  const hasSelectionFlag = hasSelection();

  // Scene synchronization is now handled by the useBabylonScene hook

  // Track canvas ref changes
  /*
  useEffect(() => {
    console.log('üéØ App.tsx: Canvas ref changed:', {
      hasCanvas: !!canvasRef.current,
      showApiKeyInput,
      canvasElement: canvasRef.current
    })
  }, [canvasRef.current, showApiKeyInput])
  */
  
  // Keyboard shortcuts are now handled by the useKeyboardShortcuts hook

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (activeDropdown && !(event.target as Element).closest('.toolbar-item')) {
        setActiveDropdown(null)
      }
    }

    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [activeDropdown])

  // Gizmo management is now handled by the useGizmoManager hook in useBabylonScene

  // Visual grid, multi-select pivot, and object selection feedback are now handled by the useBabylonScene hook

  // Handle NURBS control point visualizations when selection changes
  /*
  useEffect(() => {
    if (selectedObject && selectedObject.isNurbs && selectedObject.verbData) {
      // Create control point visualizations for selected NURBS object
      createControlPointVisualizations(selectedObject.id, selectedObject.verbData)
    } else {
      // Remove all control point visualizations when no NURBS object is selected
      controlPointVisualizations.forEach(viz => {
        removeControlPointVisualizations(viz.objectId)
      })
      setSelectedControlPointIndex(null)
      setSelectedControlPointMesh(null)
    }
  }, [selectedObjectId, selectedObject?.isNurbs])
  */

  const toggleDropdown = (dropdownName: string) => {
    setActiveDropdown(activeDropdown === dropdownName ? null : dropdownName)
  }

  // Object click and hover handling is now managed directly in the useBabylonScene hook

  const createPrimitive = (type: Exclude<PrimitiveType, 'nurbs'>) => {
    if (!sceneInitialized) return;
    
    const newId = `${type}-${Date.now()}`;
    const position = new Vector3(Math.random() * 4 - 2, 2, Math.random() * 4 - 2);

    const newObj: SceneObject = {
      id: newId, 
      type, 
      position: position,
      scale: new Vector3(1, 1, 1), 
      rotation: new Vector3(0, 0, 0),
      color: currentColor, 
      isNurbs: false
    };

    addObject(newObj);
    setSelectedObjectId(newId);
    setActiveDropdown(null);
  }

  const createModularRoom = () => {
    if (!sceneInitialized) return;
    
    const newId = `house-room-modular-${Date.now()}`;
    const position = new Vector3(Math.random() * 4 - 2, 0, Math.random() * 4 - 2);

    const newObj: SceneObject = {
      id: newId,
      type: 'house-room-modular',
      position: position,
      scale: new Vector3(1, 1, 1),
      rotation: new Vector3(0, 0, 0),
      color: '#DEB887',
      isNurbs: false
    };

    addObject(newObj);
    setSelectedObjectId(newId);
    setActiveDropdown(null);
  }

  // Helper function to get parametric position of a point on a line segment
  const getParametricPosition = (lineStart: Vector3, lineEnd: Vector3, point: Vector3): number => {
    const lineDir = lineEnd.subtract(lineStart)
    const lineLengthSq = lineDir.lengthSquared()
    
    if (lineLengthSq < 0.0001) return 0 // Degenerate line
    
    const toPoint = point.subtract(lineStart)
    const t = Vector3.Dot(toPoint, lineDir) / lineLengthSq
    
    return t
  }
  
  // Helper function to check if a point is on a line segment
  const isPointOnSegment = (point: Vector3, segStart: Vector3, segEnd: Vector3): boolean => {
    const t = getParametricPosition(segStart, segEnd, point)
    if (t < 0 || t > 1) return false
    
    const projectedPoint = Vector3.Lerp(segStart, segEnd, t)
    const distance = Vector3.Distance(point, projectedPoint)
    
    return distance < 0.01 // Tolerance for floating point comparison
  }

  /**
   * Callback invoked when the user finishes drawing a custom room shape in the modal.
   * Converts 2D SVG coordinates to 3D world-space points, extrudes the polygon,
   * registers the mesh with the scene, and stores a SceneObject entry.
   */
  const handleCreateCustomRoom = (roomData: { points: { x: number; y: number }[]; openings?: { start: { x: number; y: number }; end: { x: number; y: number } }[]; name?: string; allSegments?: { start: { x: number; y: number }; end: { x: number; y: number }; isOpening?: boolean }[] }) => {
    if (!sceneInitialized) return

    const sceneManager = sceneAPI.getSceneManager()
    const scene = sceneManager?.getScene()
    if (!scene || !sceneManager) return

    const SVG_SIZE = 400 // matches modal SVG dimension
    const SCALE = 0.05 // px -> world units (adjust as desired)
    const WALL_HEIGHT = 2.0
    const WALL_THICKNESS = 0.15

    const { points, openings, name, allSegments } = roomData

    // Convert SVG (origin top-left, +y down) to Babylon XZ plane (origin center, +z forward)
    const vertices2D = points.map(p => new Vector2(
      (p.x - SVG_SIZE / 2) * SCALE,
      ((SVG_SIZE / 2) - p.y) * SCALE // flip Y
    ))

    if (vertices2D.length < 3) return

    const newId = `custom-room-${Date.now()}`

    // -------------------------------------------------------------
    // Determine polygon orientation (CW vs CCW)
    // Used to ensure outward normals always point outside even for
    // concave polygons, without relying on a centroid approximation.
    // -------------------------------------------------------------
    const signedArea = vertices2D.reduce((acc, curr, idx) => {
      const next = vertices2D[(idx + 1) % vertices2D.length]
      return acc + (curr.x * next.y - next.x * curr.y)
    }, 0)
    // For a counter-clockwise (positive area) polygon, the vector
    // Up √ó direction already points outward. For clockwise polygons
    // (negative area), invert the sign.
    const orientationSign = signedArea >= 0 ? 1 : -1

    // Create a root mesh to act as the parent for all room components
    const rootMesh = new Mesh(newId, scene)

    // --- Create Floor ---
    // Convert 2D vertices to 3D for the floor polygon
    const floorVertices = vertices2D.map(p => new Vector3(p.x, 0, p.y))

    // Use CreatePolygon to build a solid floor with thickness (depth)
    const floor = MeshBuilder.CreatePolygon(`${newId}-floor`, {
      shape: floorVertices,
      depth: WALL_THICKNESS
    }, scene)
    floor.position.y -= WALL_THICKNESS / 2 // Position floor correctly
    const floorMaterial = new StandardMaterial(`${newId}-floor-mat`, scene)
    floorMaterial.diffuseColor = Color3.FromHexString('#A0522D') // Sienna brown
    floor.material = floorMaterial
    floor.parent = rootMesh

    // --- Create Walls ---
    const wallMaterial = new StandardMaterial(`${newId}-wall-mat`, scene)
    wallMaterial.diffuseColor = Color3.FromHexString('#DEB887') // BurlyWood

    const wallTopConnectionPoints: ConnectionPoint[] = []

    // Convert openings to world coordinates for comparison
    const worldOpenings = openings?.map(opening => ({
      start: new Vector2(
        (opening.start.x - SVG_SIZE / 2) * SCALE,
        ((SVG_SIZE / 2) - opening.start.y) * SCALE
      ),
      end: new Vector2(
        (opening.end.x - SVG_SIZE / 2) * SCALE,
        ((SVG_SIZE / 2) - opening.end.y) * SCALE
      )
    })) || []

    for (let i = 0; i < vertices2D.length; i++) {
      const p1 = new Vector3(vertices2D[i].x, 0, vertices2D[i].y)
      const p2 = new Vector3(vertices2D[(i + 1) % vertices2D.length].x, 0, vertices2D[(i + 1) % vertices2D.length].y)

      const wallLength = Vector3.Distance(p1, p2)
      if (wallLength < 0.01) continue // Skip zero-length walls

      // Find all openings that intersect with this wall segment
      const wallDirection = p2.subtract(p1).normalize()
      const wallSegments: Array<{ start: Vector3; end: Vector3 }> = []
      
      // Collect all opening intersections along this wall
      const intersections: number[] = [0, 1] // Start with wall endpoints (in parametric form)
      
      worldOpenings.forEach(opening => {
        // Check if opening is on the same line as the wall
        const openingStart = new Vector3(opening.start.x, 0, opening.start.y)
        const openingEnd = new Vector3(opening.end.x, 0, opening.end.y)
        
        // Calculate parametric positions of opening points on the wall line
        const t1 = getParametricPosition(p1, p2, openingStart)
        const t2 = getParametricPosition(p1, p2, openingEnd)
        
        // Check if opening overlaps with this wall segment
        if ((t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1) || (t1 < 0 && t2 > 1)) {
          // Add intersection points
          if (t1 >= 0 && t1 <= 1) intersections.push(t1)
          if (t2 >= 0 && t2 <= 1) intersections.push(t2)
        }
      })
      
      // Sort intersection points
      intersections.sort((a, b) => a - b)
      
      // Create wall segments between openings
      for (let j = 0; j < intersections.length - 1; j++) {
        const t1 = intersections[j]
        const t2 = intersections[j + 1]
        
        if (Math.abs(t2 - t1) < 0.001) continue // Skip tiny segments
        
        const segmentStart = Vector3.Lerp(p1, p2, t1)
        const segmentEnd = Vector3.Lerp(p1, p2, t2)
        
        // Check if this segment is inside an opening
        const segmentMid = Vector3.Lerp(segmentStart, segmentEnd, 0.5)
        const isInOpening = worldOpenings.some(opening => {
          return isPointOnSegment(
            segmentMid,
            new Vector3(opening.start.x, 0, opening.start.y),
            new Vector3(opening.end.x, 0, opening.end.y)
          )
        })
        
        if (!isInOpening) {
          wallSegments.push({ start: segmentStart, end: segmentEnd })
        }
      }
      
      // Create wall meshes for each segment
      wallSegments.forEach((segment, segIdx) => {
        const segmentLength = Vector3.Distance(segment.start, segment.end)
        if (segmentLength < 0.01) return
        
        const wall = MeshBuilder.CreateBox(`${newId}-wall-${i}-${segIdx}`, {
          width: segmentLength,
          height: WALL_HEIGHT,
          depth: WALL_THICKNESS
        }, scene)

        // Position and orient the wall segment
        const direction = segment.end.subtract(segment.start).normalize()
        const midPoint = Vector3.Lerp(segment.start, segment.end, 0.5)
        const outward = Vector3.Cross(Vector3.Up(), direction).normalize().scale(orientationSign)
        const wallPos = midPoint.add(outward.scale(WALL_THICKNESS / 2))

        wall.position = wallPos
        wall.position.y += WALL_HEIGHT / 2
        wall.rotation.y = -Math.atan2(direction.z, direction.x)
        wall.material = wallMaterial
        wall.parent = rootMesh

        // Add connection point at the top middle of wall segment
        const cpMid = Vector3.Lerp(segment.start, segment.end, 0.5)
        const cpPosLocal = new Vector3(cpMid.x, WALL_HEIGHT, cpMid.z)
        const cp: ConnectionPoint = {
          id: `wall-top-${i}-${segIdx}`,
          position: cpPosLocal,
          normal: new Vector3(0, 1, 0),
          kind: 'edge'
        }
        wallTopConnectionPoints.push(cp)
      })
    }
    
    // --- Create Interior Walls ---
    // Find all wall segments that are not openings and create 3D walls for them
    // This includes both perimeter walls (already created above) and interior walls
    const allWallSegments = allSegments?.filter((segment: { isOpening?: boolean }) => !segment.isOpening) || []
    
    // Convert line segments to world coordinates for comparison
    const worldWallSegments = allWallSegments.map((segment: { start: { x: number; y: number }; end: { x: number; y: number } }) => ({
      start: new Vector2(
        (segment.start.x - SVG_SIZE / 2) * SCALE,
        ((SVG_SIZE / 2) - segment.start.y) * SCALE
      ),
      end: new Vector2(
        (segment.end.x - SVG_SIZE / 2) * SCALE,
        ((SVG_SIZE / 2) - segment.end.y) * SCALE
      )
    }))
    
    // Track which wall segments have already been created as perimeter walls
    const createdWalls = new Set<string>()
    
    // Mark perimeter walls as created
    for (let i = 0; i < vertices2D.length; i++) {
      const p1 = vertices2D[i]
      const p2 = vertices2D[(i + 1) % vertices2D.length]
      
      // Find matching wall segment
      worldWallSegments.forEach((segment: { start: Vector2; end: Vector2 }, idx: number) => {
        const matchesForward = 
          (Math.abs(p1.x - segment.start.x) < 0.01 && Math.abs(p1.y - segment.start.y) < 0.01 &&
           Math.abs(p2.x - segment.end.x) < 0.01 && Math.abs(p2.y - segment.end.y) < 0.01)
        
        const matchesReverse = 
          (Math.abs(p1.x - segment.end.x) < 0.01 && Math.abs(p1.y - segment.end.y) < 0.01 &&
           Math.abs(p2.x - segment.start.x) < 0.01 && Math.abs(p2.y - segment.start.y) < 0.01)
        
        if (matchesForward || matchesReverse) {
          createdWalls.add(`wall-${idx}`)
        }
      })
    }
    
    // Create interior walls (walls not part of the perimeter)
    worldWallSegments.forEach((segment: { start: Vector2; end: Vector2 }, idx: number) => {
      if (createdWalls.has(`wall-${idx}`)) return // Skip if already created as perimeter
      
      const p1 = new Vector3(segment.start.x, 0, segment.start.y)
      const p2 = new Vector3(segment.end.x, 0, segment.end.y)
      
      const wallLength = Vector3.Distance(p1, p2)
      if (wallLength < 0.01) return // Skip zero-length walls
      
      const interiorWall = MeshBuilder.CreateBox(`${newId}-interior-wall-${idx}`, {
        width: wallLength,
        height: WALL_HEIGHT,
        depth: WALL_THICKNESS
      }, scene)
      
      // Position and orient the interior wall
      const direction = p2.subtract(p1).normalize()
      const midPoint = Vector3.Lerp(p1, p2, 0.5)
      
      interiorWall.position = midPoint
      interiorWall.position.y += WALL_HEIGHT / 2
      interiorWall.rotation.y = -Math.atan2(direction.z, direction.x)
      
      // Apply the same material as perimeter walls
      interiorWall.material = wallMaterial
      interiorWall.parent = rootMesh
      
      console.log(`[CustomRoom] Created interior wall ${idx}`)
    })
    
    // -------------------------------------------------------------
    // Attach connection points after geometry created so boundary
    // includes floor and walls (important for correct snapping)
    // -------------------------------------------------------------
    const compositeBoundary = computeCompositeBoundary(rootMesh)
    const defaultCPs = generateDefaultConnectionPoints(rootMesh, compositeBoundary)
    const cps = [...defaultCPs, ...wallTopConnectionPoints]
    if (!rootMesh.metadata) rootMesh.metadata = {}
    ;(rootMesh.metadata as any).connectionPoints = cps
    
    // Store room name in metadata
    if (name) {
      (rootMesh.metadata as any).roomName = name
      
      // Create text label for the room
      const labelPlane = MeshBuilder.CreatePlane(`${newId}-label`, {
        width: 2,
        height: 0.5
      }, scene)
      
      // Position label at the center of the room, slightly above floor
      const centerX = vertices2D.reduce((sum, v) => sum + v.x, 0) / vertices2D.length
      const centerZ = vertices2D.reduce((sum, v) => sum + v.y, 0) / vertices2D.length
      labelPlane.position = new Vector3(centerX, 0.1, centerZ)
      labelPlane.rotation.x = -Math.PI / 2 // Make it horizontal
      labelPlane.parent = rootMesh
      
      // Create dynamic texture for the text
      const labelTexture = new DynamicTexture(`${newId}-label-texture`, {
        width: 512,
        height: 128
      }, scene)
      
      // Configure text
      labelTexture.hasAlpha = true
      const ctx = labelTexture.getContext() as any // Cast to avoid TS issues with canvas context
      ctx.clearRect(0, 0, 512, 128)
      
      // Draw text
      const fontSize = 48
      ctx.font = `bold ${fontSize}px Arial`
      ctx.fillStyle = '#2c3e50'
      ctx.textAlign = 'center'
      ctx.textBaseline = 'middle'
      ctx.fillText(name, 256, 64)
      
      labelTexture.update()
      
      // Create material for the label
      const labelMaterial = new StandardMaterial(`${newId}-label-mat`, scene)
      labelMaterial.diffuseTexture = labelTexture
      labelMaterial.specularColor = new Color3(0, 0, 0)
      labelMaterial.emissiveColor = new Color3(1, 1, 1)
      labelMaterial.backFaceCulling = false
      labelPlane.material = labelMaterial
    }

    // Debugging: log connection point info
    console.log(`[CustomRoom] Generated ${cps.length} connection points for ${newId}:`, cps.map(cp => ({ id: cp.id, pos: cp.position.toString(), normal: cp.normal.toString() })))

    // Register the root mesh with the SceneManager
    sceneManager.addPreExistingMesh(rootMesh, newId)

    // Store SceneObject
    const newObj: SceneObject = {
      id: newId,
      type: 'custom-room',
      position: rootMesh.position.clone(),
      scale: rootMesh.scaling.clone(),
      rotation: rootMesh.rotation.clone(),
      color: '#DEB887',
      isNurbs: false,
      roomName: name
    }

    addObject(newObj)
    setSelectedObjectId(newId)

    // Close modal
    setShowCustomRoomModal(false)
    setActiveDropdown(null)
  }

  const handleCreateMultipleCustomRooms = (roomsData: Array<{ points: { x: number; y: number }[]; openings?: { start: { x: number; y: number }; end: { x: number; y: number } }[]; name?: string; allSegments?: { start: { x: number; y: number }; end: { x: number; y: number }; isOpening?: boolean }[] }>) => {
    // Create all rooms with slight delays to ensure unique IDs
    roomsData.forEach((roomData, index) => {
      setTimeout(() => {
        handleCreateCustomRoom(roomData)
      }, index * 100)
    })
  }

  const createHousingComponent = (componentType: string, subType?: string) => {
    if (!sceneInitialized) return;
    
    const typeString = subType ? `house-${componentType}-${subType}` : `house-${componentType}`;
    const newId = `${typeString}-${Date.now()}`;
    const position = new Vector3(Math.random() * 4 - 2, 1, Math.random() * 4 - 2);

    // Set appropriate heights for different components
    let yPosition = 1;
    let defaultColor = currentColor;
    
    switch (componentType) {
      case 'wall':
        yPosition = 0.75; // Half of standard wall height
        defaultColor = '#8B4513'; // Brown for walls
        break;
      case 'door':
        yPosition = 1; // Standard door height
        defaultColor = '#654321'; // Dark brown for doors
        break;
      case 'window':
        yPosition = 1; // Standard window height
        defaultColor = '#87CEEB'; // Sky blue for windows
        break;
      case 'ceiling':
        yPosition = 2.5; // Standard ceiling height
        defaultColor = '#F5F5DC'; // Beige for ceilings
        break;
      case 'floor':
        yPosition = 0.05; // Just above ground
        defaultColor = '#8B4513'; // Brown for floors
        break;
    }

    const newObj: SceneObject = {
      id: newId,
      type: typeString as PrimitiveType,
      position: new Vector3(position.x, yPosition, position.z),
      scale: new Vector3(1, 1, 1),
      rotation: new Vector3(0, 0, 0),
      color: defaultColor,
      isNurbs: false
    };

    addObject(newObj);
    setSelectedObjectId(newId);
    setActiveDropdown(null);
  }

  const duplicateObject = () => {
    if (!selectedObject || !sceneInitialized) return

    const newId = `${selectedObject.type}-${Date.now()}`
    
    console.log('Duplicating object:', selectedObject.id, 'as', newId)

    // Compute new position with optional grid snapping
    const offsetPosition = selectedObject.position.clone().add(new Vector3(2, 0, 0))
    const snappedPosition = snapToGrid ? sceneAPI.snapToGrid(offsetPosition) : offsetPosition

    const newObj: SceneObject = {
      id: newId,
      type: selectedObject.type,
      position: snappedPosition,
      scale: selectedObject.scale.clone(),
      rotation: selectedObject.rotation.clone(),
      color: selectedObject.color,
      isNurbs: selectedObject.isNurbs,
      verbData: selectedObject.isNurbs ? selectedObject.verbData : undefined
    }

    // --- Special handling for mesh-based types that cannot be recreated via the factory (e.g. custom-room) ---
    if (selectedObject.type === 'custom-room') {
      const sceneManager = sceneAPI.getSceneManager()
      const originalMesh = sceneManager?.getMeshById(selectedObject.id)
      if (sceneManager && originalMesh) {
        const clonedMesh = originalMesh.clone(newId, null, false) as Mesh
        clonedMesh.position = snappedPosition.clone()
        sceneManager.addPreExistingMesh(clonedMesh, newId)
        newObj.mesh = clonedMesh
      }
    }

    addObject(newObj)
    setSelectedObjectId(newId)
    setActiveDropdown(null)
  }

  const deleteSelectedObject = () => {
    if (!selectedObject) return

    console.log('üóëÔ∏è Deleting object:', selectedObject.id)
    
    removeObject(selectedObject.id)
    setSelectedObjectId(null)
    setActiveDropdown(null)
    console.log('‚úÖ Deleted object')
  }


  // TODO: fix store useage here
  const changeSelectedObjectColor = (color: string) => {
    const objectsToColor = selectedObjectId ? [selectedObjectId] : selectedObjectIds;
    if (objectsToColor.length === 0) return;

    objectsToColor.forEach(id => {
        updateObject(id, { color });
    });
  }

  const applyCurrentColorToSelection = () => {
    changeSelectedObjectColor(currentColor)
    setActiveDropdown(null)
  }

  const applyPresetColor = (color: string) => {
    setCurrentColor(color)
    changeSelectedObjectColor(color)
  }

  const setCameraView = (view: 'front' | 'back' | 'left' | 'right' | 'top' | 'bottom' | 'home') => {
    sceneAPI.setCameraView(view)
    setActiveDropdown(null)
    console.log('üì∑ Camera set to:', view)
  }

  const toggleWireframe = () => {
    const newWireframeMode = !wireframeMode
    setWireframeMode(newWireframeMode)

    sceneObjects.forEach(obj => {
      if (obj.mesh?.material && obj.type !== 'ground') {
        const material = obj.mesh.material as StandardMaterial
        material.wireframe = newWireframeMode
      }
    })
    
    console.log('üî≤ Wireframe mode:', newWireframeMode ? 'ON' : 'OFF')
  }



  // Snap position to grid
  const snapToGridPosition = (position: Vector3): Vector3 => {
    if (!snapToGrid) return position
    return new Vector3(
      Math.round(position.x / gridSize) * gridSize,
      Math.round(position.y / gridSize) * gridSize,
      Math.round(position.z / gridSize) * gridSize
    )
  }

  // Visual grid, multi-select pivot, and transform operations are now handled by the useBabylonScene hook

  // Select all objects
  const selectAllObjects = () => {
    const selectableObjects = sceneObjects.filter(obj => obj.type !== 'ground' && !objectLocked[obj.id])
    setSelectedObjectIds(selectableObjects.map(obj => obj.id))
    setSelectedObjectId(null)
    setActiveDropdown(null)
    console.log('üîç Selected all objects')
  }

  // Deselect all objects
  const deselectAllObjects = () => {
    setSelectedObjectId(null)
    setSelectedObjectIds([])
    setActiveDropdown(null)
    console.log('üîç Deselected all objects')
  }

  // Invert selection
  const invertSelection = () => {
    const selectableObjects = sceneObjects.filter(obj => obj.type !== 'ground' && !objectLocked[obj.id])
    const currentlySelected = selectedObjectIds
    const newSelection = selectableObjects.filter(obj => !currentlySelected.includes(obj.id)).map(obj => obj.id)
    setSelectedObjectIds(newSelection)
    setSelectedObjectId(null)
    setActiveDropdown(null)
    console.log('üîç Inverted selection')
  }



  // Reset transform for selected objects
  const resetTransforms = () => {
    const objectsToReset = selectedObjectId ? [selectedObjectId] : selectedObjectIds;
    const defaultPosition = new Vector3(0, 1, 0);
    const defaultRotation = new Vector3(0, 0, 0);
    const defaultScale = new Vector3(1, 1, 1);
    
    objectsToReset.forEach(id => {
        updateObject(id, {
            position: defaultPosition,
            rotation: defaultRotation,
            scale: defaultScale
        });
    });
  }

  // Duplicate selected objects
  const duplicateSelectedObjects = () => {
    if (!sceneInitialized) return
    
    const objectsToDuplicate = selectedObjectId ? [selectedObjectId] : selectedObjectIds
    const newObjects: SceneObject[] = []
    
    objectsToDuplicate.forEach(objectId => {
      const originalObject = sceneObjects.find(obj => obj.id === objectId)
      if (!originalObject) return
      
      const newId = `${originalObject.type}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
      
      // Copy properties and offset position
      const offsetPosition = originalObject.position.clone().add(new Vector3(2, 0, 0))
      const snappedPosition = snapToGrid ? sceneAPI.snapToGrid(offsetPosition) : offsetPosition
      
      const newObj: SceneObject = {
        id: newId,
        type: originalObject.type,
        position: snappedPosition,
        scale: originalObject.scale.clone(),
        rotation: originalObject.rotation.clone(),
        color: originalObject.color,
        isNurbs: originalObject.isNurbs,
        verbData: originalObject.isNurbs ? originalObject.verbData : undefined
      }
      
      // Handle custom-room duplication by cloning the existing mesh hierarchy
      if (originalObject.type === 'custom-room') {
        const sceneManager = sceneAPI.getSceneManager()
        const originalMesh = sceneManager?.getMeshById(originalObject.id)
        if (sceneManager && originalMesh) {
          const clonedMesh = originalMesh.clone(newId, null, false) as Mesh
          clonedMesh.position = snappedPosition.clone()
          sceneManager.addPreExistingMesh(clonedMesh, newId)
          newObj.mesh = clonedMesh
        }
      }
      
      newObjects.push(newObj)
    })
    
    newObjects.forEach(addObject)
    
    // Select the new objects
    if (newObjects.length === 1) {
      setSelectedObjectId(newObjects[0].id)
      setSelectedObjectIds([])
    } else {
      setSelectedObjectIds(newObjects.map(obj => obj.id))
      setSelectedObjectId(null)
    }
    
    setActiveDropdown(null)
    console.log('üìã Duplicated selected objects')
  }

  // Scene initialization is now handled by the useBabylonScene hook

  // Top Toolbar Component
  const renderTopToolbar = () => (
    <div className="top-toolbar">
      <div className="toolbar-menu">
        <div className="toolbar-brand">VibeCad Pro</div>
        
        <div className="toolbar-status">
          <span className="status-item">
            <span className="status-label">Mode:</span>
            <span className={`status-value ${transformMode}`}>{transformMode.toUpperCase()}</span>
          </span>
          <span className="status-item">
            <span className="status-label">Grid:</span>
            <span className={`status-value ${snapToGrid ? 'on' : 'off'}`}>
              {snapToGrid ? `ON (${gridSize})` : 'OFF'}
            </span>
          </span>
          <span className="status-item">
            <span className="status-label">Collision:</span>
            <span className={`status-value ${collisionDetectionEnabled ? 'on' : 'off'}`}>
              {collisionDetectionEnabled ? 'ON' : 'OFF'}
            </span>
          </span>
          <span className="status-item">
            <span className="status-label">Selected:</span>
            <span className="status-value">
              {selectedObjectId ? '1' : selectedObjectIds.length}
            </span>
          </span>
          {/* Quick test button */}
          <button 
            className="test-button"
            onClick={() => createPrimitive('cube')}
            disabled={!sceneInitialized}
            style={{
              marginLeft: '10px',
              padding: '4px 8px',
              backgroundColor: '#3498db',
              color: 'white',
              border: 'none',
              borderRadius: '4px',
              cursor: 'pointer'
            }}
          >
            üß™ Add Test Cube
          </button>
        </div>
        
        {/* Transform Tools */}
        <div className="toolbar-item">
          <button 
            className={`toolbar-button ${transformMode !== 'select' ? 'active' : ''}`}
            onClick={() => toggleDropdown('transform')}
          >
            Transform <span className="dropdown-arrow">‚ñº</span>
          </button>
          <div className={`dropdown-menu ${activeDropdown === 'transform' ? 'show' : ''}`}>
            <div className="dropdown-section">
              <div className="dropdown-section-title">Transform Mode</div>
              <div className="dropdown-grid">
                <button 
                  className={`dropdown-button ${transformMode === 'select' ? 'active' : ''}`}
                  onClick={() => {
                    setTransformMode('select')
                    setActiveDropdown(null)
                  }}
                >
                  <span className="dropdown-icon">üîç</span>
                  Select
                </button>
                <button 
                  className={`dropdown-button ${transformMode === 'move' ? 'active' : ''}`}
                  onClick={() => {
                    setTransformMode('move')
                    setActiveDropdown(null)
                  }}
                >
                  <span className="dropdown-icon">‚¨ÜÔ∏è</span>
                  Move
                </button>
                <button 
                  className={`dropdown-button ${transformMode === 'rotate' ? 'active' : ''}`}
                  onClick={() => {
                    setTransformMode('rotate')
                    setActiveDropdown(null)
                  }}
                >
                  <span className="dropdown-icon">üîÑ</span>
                  Rotate
                </button>
                <button 
                  className={`dropdown-button ${transformMode === 'scale' ? 'active' : ''}`}
                  onClick={() => {
                    setTransformMode('scale')
                    setActiveDropdown(null)
                  }}
                >
                  <span className="dropdown-icon">üìè</span>
                  Scale
                </button>
              </div>
            </div>
          </div>
        </div>

        {/* Create Menu */}
        <div className="toolbar-item">
          <button 
            className="toolbar-button"
            onClick={() => toggleDropdown('create')}
          >
            Create <span className="dropdown-arrow">‚ñº</span>
          </button>
          <div className={`dropdown-menu ${activeDropdown === 'create' ? 'show' : ''}`}>
            <div className="dropdown-section">
              <div className="dropdown-section-title">Primitives</div>
              <div className="dropdown-grid">
                <button className="dropdown-button" onClick={() => createPrimitive('cube')}>
                  <span className="dropdown-icon">‚¨ú</span>
                  Cube
                </button>
                <button className="dropdown-button" onClick={() => createPrimitive('sphere')}>
                  <span className="dropdown-icon">‚ö™</span>
                  Sphere
                </button>
                <button className="dropdown-button" onClick={() => createPrimitive('cylinder')}>
                  <span className="dropdown-icon">‚ö´</span>
                  Cylinder
                </button>
                <button className="dropdown-button" onClick={() => createPrimitive('plane')}>
                  <span className="dropdown-icon">‚ñ¨</span>
                  Plane
                </button>
                <button className="dropdown-button" onClick={() => createPrimitive('torus')}>
                  <span className="dropdown-icon">üîò</span>
                  Torus
                </button>
                <button className="dropdown-button" onClick={() => createPrimitive('cone')}>
                  <span className="dropdown-icon">üî∫</span>
                  Cone
                </button>
                {/* NURBS option removed */}
              </div>
            </div>
            <div className="dropdown-section">
              <div className="dropdown-section-title">Basic Housing</div>
              <div className="dropdown-grid">
                <button className="dropdown-button" onClick={() => createPrimitive('house-basic')}>
                  <span className="dropdown-icon">üè†</span>
                  Basic House
                </button>
                <button className="dropdown-button" onClick={() => createPrimitive('house-room')}>
                  <span className="dropdown-icon">üè†</span>
                  Room
                </button>
                <button className="dropdown-button" onClick={() => createPrimitive('house-hallway')}>
                  <span className="dropdown-icon">üö™</span>
                  Hallway
                </button>
                <button className="dropdown-button" onClick={() => createPrimitive('house-roof-flat')}>
                  <span className="dropdown-icon">üè¢</span>
                  Flat Roof
                </button>
                <button className="dropdown-button" onClick={() => createPrimitive('house-roof-pitched')}>
                  <span className="dropdown-icon">üè†</span>
                  Pitched Roof
                </button>
              </div>
            </div>
            <div className="dropdown-section">
              <div className="dropdown-section-title">Modular Rooms</div>
              <div className="dropdown-grid">
                <button className="dropdown-button" onClick={() => createModularRoom()}>
                  <span className="dropdown-icon">üèóÔ∏è</span>
                  Modular Room
                </button>
              </div>
            </div>
            <div className="dropdown-section">
              <div className="dropdown-section-title">Foundation & Structure</div>
              <div className="dropdown-grid">
                <button className="dropdown-button" onClick={() => createPrimitive('house-foundation')}>
                  <span className="dropdown-icon">üèóÔ∏è</span>
                  Foundation
                </button>
                <button className="dropdown-button" onClick={() => createPrimitive('house-stairs')}>
                  <span className="dropdown-icon">ü™ú</span>
                  Stairs
                </button>
              </div>
            </div>
            <div className="dropdown-section">
              <div className="dropdown-section-title">Walls & Structure</div>
              <div className="dropdown-grid">
                <button className="dropdown-button" onClick={() => createHousingComponent('wall')}>
                  <span className="dropdown-icon">üß±</span>
                  Wall
                </button>
                <button className="dropdown-button" onClick={() => createHousingComponent('ceiling')}>
                  <span className="dropdown-icon">üèóÔ∏è</span>
                  Ceiling
                </button>
                <button className="dropdown-button" onClick={() => createHousingComponent('floor')}>
                  <span className="dropdown-icon">üü´</span>
                  Floor
                </button>
              </div>
            </div>
            <div className="dropdown-section">
              <div className="dropdown-section-title">Doors</div>
              <div className="dropdown-grid">
                <button className="dropdown-button" onClick={() => createHousingComponent('door', 'single')}>
                  <span className="dropdown-icon">üö™</span>
                  Single Door
                </button>
                <button className="dropdown-button" onClick={() => createHousingComponent('door', 'double')}>
                  <span className="dropdown-icon">üö™</span>
                  Double Door
                </button>
                <button className="dropdown-button" onClick={() => createHousingComponent('door', 'sliding')}>
                  <span className="dropdown-icon">üö™</span>
                  Sliding Door
                </button>
                <button className="dropdown-button" onClick={() => createHousingComponent('door', 'french')}>
                  <span className="dropdown-icon">üö™</span>
                  French Door
                </button>
                <button className="dropdown-button" onClick={() => createHousingComponent('door', 'garage')}>
                  <span className="dropdown-icon">üö™</span>
                  Garage Door
                </button>
              </div>
            </div>
            <div className="dropdown-section">
              <div className="dropdown-section-title">Windows</div>
              <div className="dropdown-grid">
                <button className="dropdown-button" onClick={() => createHousingComponent('window', 'single')}>
                  <span className="dropdown-icon">ü™ü</span>
                  Single Window
                </button>
                <button className="dropdown-button" onClick={() => createHousingComponent('window', 'double')}>
                  <span className="dropdown-icon">ü™ü</span>
                  Double Window
                </button>
                <button className="dropdown-button" onClick={() => createHousingComponent('window', 'bay')}>
                  <span className="dropdown-icon">ü™ü</span>
                  Bay Window
                </button>
                <button className="dropdown-button" onClick={() => createHousingComponent('window', 'casement')}>
                  <span className="dropdown-icon">ü™ü</span>
                  Casement Window
                </button>
                <button className="dropdown-button" onClick={() => createHousingComponent('window', 'sliding')}>
                  <span className="dropdown-icon">ü™ü</span>
                  Sliding Window
                </button>
                <button className="dropdown-button" onClick={() => createHousingComponent('window', 'skylight')}>
                  <span className="dropdown-icon">ü™ü</span>
                  Skylight
                </button>
              </div>
            </div>
            {/* Custom */}
            <div className="dropdown-section">
              <div className="dropdown-section-title">Custom</div>
              <div className="dropdown-grid">
                <button className="dropdown-button" onClick={() => { setShowCustomRoomModal(true); setActiveDropdown(null) }}>
                  <span className="dropdown-icon">üìê</span>
                  Custom Room
                </button>
              </div>
            </div>
          </div>
        </div>

        {/* Material Menu */}
        <div className="toolbar-item">
          <button 
            className={`toolbar-button ${hasSelectionFlag ? 'active' : ''}`}
            onClick={() => toggleDropdown('material')}
          >
            Material <span className="dropdown-arrow">‚ñº</span>
          </button>
          <div className={`dropdown-menu ${activeDropdown === 'material' ? 'show' : ''}`}>
            <div className="dropdown-section">
              <div className="dropdown-section-title">RGB Color Picker</div>
              <div className="dropdown-controls">
                <div className="control-row">
                  <span className="control-label">Color:</span>
                  <input
                    type="color"
                    value={currentColor}
                    onChange={(e) => {
                      setCurrentColor(e.target.value)
                      if (hasSelectionFlag) {
                        changeSelectedObjectColor(e.target.value)
                      }
                    }}
                    className="color-picker-large"
                  />
                </div>
                <div className="control-row">
                  <span className="control-label">Hex:</span>
                  <input
                    type="text"
                    value={currentColor}
                    onChange={(e) => {
                      const hexValue = e.target.value
                      if (/^#[0-9A-F]{6}$/i.test(hexValue)) {
                        setCurrentColor(hexValue)
                        if (hasSelectionFlag) {
                          changeSelectedObjectColor(hexValue)
                        }
                      }
                    }}
                    className="hex-input"
                    placeholder="#FFFFFF"
                  />
                </div>
                <div className="control-row">
                  <span className="control-label">RGB:</span>
                  <div className="rgb-inputs">
                    <input
                      type="number"
                      min="0"
                      max="255"
                      value={parseInt(currentColor.substr(1, 2), 16)}
                      onChange={(e) => {
                        const r = Math.max(0, Math.min(255, parseInt(e.target.value) || 0))
                        const g = parseInt(currentColor.substr(3, 2), 16)
                        const b = parseInt(currentColor.substr(5, 2), 16)
                        const newColor = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`
                        setCurrentColor(newColor)
                        if (hasSelectionFlag) {
                          changeSelectedObjectColor(newColor)
                        }
                      }}
                      className="rgb-input"
                      placeholder="R"
                    />
                    <input
                      type="number"
                      min="0"
                      max="255"
                      value={parseInt(currentColor.substr(3, 2), 16)}
                      onChange={(e) => {
                        const r = parseInt(currentColor.substr(1, 2), 16)
                        const g = Math.max(0, Math.min(255, parseInt(e.target.value) || 0))
                        const b = parseInt(currentColor.substr(5, 2), 16)
                        const newColor = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`
                        setCurrentColor(newColor)
                        if (hasSelectionFlag) {
                          changeSelectedObjectColor(newColor)
                        }
                      }}
                      className="rgb-input"
                      placeholder="G"
                    />
                    <input
                      type="number"
                      min="0"
                      max="255"
                      value={parseInt(currentColor.substr(5, 2), 16)}
                      onChange={(e) => {
                        const r = parseInt(currentColor.substr(1, 2), 16)
                        const g = parseInt(currentColor.substr(3, 2), 16)
                        const b = Math.max(0, Math.min(255, parseInt(e.target.value) || 0))
                        const newColor = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`
                        setCurrentColor(newColor)
                        if (hasSelectionFlag) {
                          changeSelectedObjectColor(newColor)
                        }
                      }}
                      className="rgb-input"
                      placeholder="B"
                    />
                  </div>
                </div>
              </div>
            </div>
            <div className="dropdown-section">
              <div className="dropdown-section-title">Quick Colors</div>
              <div className="dropdown-controls">
                <div className="control-row">
                  <div className="material-chips">
                    {materialPresets.map((preset) => (
                      <button
                        key={preset.name}
                        className={`material-chip ${currentColor === preset.color ? 'active' : ''}`}
                        style={{ backgroundColor: preset.color }}
                        onClick={() => applyPresetColor(preset.color)}
                        title={preset.name}
                      />
                    ))}
                  </div>
                </div>
              </div>
            </div>
            {hasSelectionFlag && (
              <div className="dropdown-section">
                <div className="dropdown-section-title">
                  Apply to: {selectedObject ? selectedObject.type.toUpperCase() : `${selectedObjectIds.length} OBJECTS`}
                </div>
                <div className="dropdown-actions">
                  <button 
                    className="dropdown-action"
                    onClick={applyCurrentColorToSelection}
                  >
                    Apply Current Color
                  </button>
                  <button 
                    className="dropdown-action"
                    onClick={() => {
                      // Random color generator
                      const randomColor = `#${Math.floor(Math.random()*16777215).toString(16).padStart(6, '0')}`
                      setCurrentColor(randomColor)
                      changeSelectedObjectColor(randomColor)
                    }}
                  >
                    Random Color
                  </button>
                </div>
              </div>
            )}
          </div>
        </div>

        {/* Edit Menu */}
        <div className="toolbar-item">
          <button 
            className={`toolbar-button ${hasSelectionFlag ? 'active' : ''}`}
            onClick={() => toggleDropdown('edit')}
          >
            Edit <span className="dropdown-arrow">‚ñº</span>
          </button>
          <div className={`dropdown-menu ${activeDropdown === 'edit' ? 'show' : ''}`}>
            <div className="dropdown-section">
              <div className="dropdown-section-title">Selection Mode</div>
              <div className="dropdown-actions">
                <button 
                  className={`dropdown-action ${!multiSelectMode ? 'active' : ''}`}
                  onClick={() => {
                    setMultiSelectMode(false)
                    setSelectedObjectIds([])
                    setActiveDropdown(null)
                  }}
                >
                  Single Select
                </button>
                <button 
                  className={`dropdown-action ${multiSelectMode ? 'active' : ''}`}
                  onClick={() => {
                    setMultiSelectMode(true)
                    setSelectedObjectId(null)
                    setActiveDropdown(null)
                  }}
                >
                  Multi Select
                </button>
              </div>
            </div>
            <div className="dropdown-section">
              <div className="dropdown-section-title">Selection Tools</div>
              <div className="dropdown-actions">
                <button 
                  className="dropdown-action"
                  onClick={selectAllObjects}
                >
                  Select All
                </button>
                <button 
                  className="dropdown-action"
                  onClick={deselectAllObjects}
                >
                  Deselect All
                </button>
                <button 
                  className="dropdown-action"
                  onClick={invertSelection}
                >
                  Invert Selection
                </button>
              </div>
            </div>
            <div className="dropdown-section">
              <div className="dropdown-section-title">Current Selection</div>
              <div className={`selection-info ${hasSelectionFlag ? 'has-selection' : ''}`}>
                {selectedObject ? (
                  <>
                    <div className="selected-object-name">{selectedObject.type.toUpperCase()}</div>
                    <div className="selected-object-details">
                      ID: {selectedObject.id}<br/>
                      Position: ({selectedObject.position.x.toFixed(1)}, {selectedObject.position.y.toFixed(1)}, {selectedObject.position.z.toFixed(1)})
                    </div>
                  </>
                ) : selectedObjectIds.length > 0 ? (
                  <>
                    <div className="selected-object-name">MULTIPLE OBJECTS</div>
                    <div className="selected-object-details">
                      {selectedObjectIds.length} objects selected<br/>
                      {selectedObjectIds.slice(0, 3).join(', ')}
                      {selectedObjectIds.length > 3 ? '...' : ''}
                    </div>
                  </>
                ) : (
                  <div className="no-selection-text">
                    {multiSelectMode ? 'Ctrl+Click objects to select multiple' : 'Click objects in the 3D scene to select them'}
                    <br/>
                    <small>üí° You can also select from the sidebar</small>
                  </div>
                )}
              </div>
            </div>
            {hasSelectionFlag && (
              <div className="dropdown-section">
                <div className="dropdown-section-title">Actions</div>
                <div className="dropdown-actions">
                  <button 
                    className="dropdown-action"
                    onClick={duplicateSelectedObjects}
                  >
                    Duplicate
                  </button>
                  <button 
                    className="dropdown-action"
                    onClick={resetTransforms}
                  >
                    Reset Transform
                  </button>
                  <button 
                    className="dropdown-action danger"
                                      onClick={() => {
                    const objectsToDelete = selectedObjectId ? [selectedObjectId] : selectedObjectIds
                    
                    objectsToDelete.forEach(id => {
                      removeObject(id)
                    })
                    
                    setSelectedObjectId(null)
                    setSelectedObjectIds([])
                    setActiveDropdown(null)
                    console.log('üóëÔ∏è Deleted selected objects')
                  }}
                  >
                    Delete
                  </button>
                </div>
              </div>
            )}
          </div>
        </div>

        {/* Tools Menu */}
        <div className="toolbar-item">
          <button 
            className="toolbar-button"
            onClick={() => toggleDropdown('tools')}
          >
            Tools <span className="dropdown-arrow">‚ñº</span>
          </button>
          <div className={`dropdown-menu ${activeDropdown === 'tools' ? 'show' : ''}`}>
            <div className="dropdown-section">
              <div className="dropdown-section-title">Snap Settings</div>
              <div className="dropdown-controls">
                <div className="control-row">
                  <label className="control-checkbox">
                    <input
                      type="checkbox"
                      checked={snapToGrid}
                      onChange={(e) => setSnapToGrid(e.target.checked)}
                    />
                    <span>Snap to Grid</span>
                  </label>
                </div>
                <div className="control-row">
                  <label className="control-checkbox">
                    <input
                      type="checkbox"
                      checked={snapToObjects}
                      onChange={(e) => setSnapToObjects(e.target.checked)}
                    />
                    <span>Snap to Objects</span>
                  </label>
                </div>
                <div className="control-row">
                  <label className="control-checkbox">
                    <input
                      type="checkbox"
                      checked={showConnectionPoints}
                      onChange={(e) => setShowConnectionPoints(e.target.checked)}
                    />
                    <span>Show Connection Points</span>
                  </label>
                </div>
                <div className="control-row">
                  <span className="control-label">Grid Size:</span>
                  <input
                    type="number"
                    value={gridSize}
                    onChange={(e) => setGridSize(parseFloat(e.target.value) || 1)}
                    min="0.1"
                    max="5"
                    step="0.1"
                    className="control-input"
                  />
                </div>
              </div>
            </div>
            <div className="dropdown-section">
              <div className="dropdown-section-title">Physics</div>
              <div className="dropdown-controls">
                <div className="control-row">
                  <label className="control-checkbox">
                    <input
                      type="checkbox"
                      checked={collisionDetectionEnabled}
                      onChange={(e) => {
                        setCollisionDetectionEnabled(e.target.checked)
                        if (sceneAPI) {
                          sceneAPI.setCollisionDetectionEnabled(e.target.checked)
                        }
                      }}
                    />
                    <span>Collision Detection</span>
                  </label>
                </div>
              </div>
            </div>
            <div className="dropdown-section">
              <div className="dropdown-section-title">Precision Tools</div>
              <div className="dropdown-actions">
                <button 
                  className="dropdown-action"
                  onClick={() => {
                    // Focus on selected object
                    if (selectedObject) {
                      sceneAPI.focusOnPosition(selectedObject.position)
                    } else if (selectedObjects.length > 0) {
                      // Focus on center of multi-selection
                      const center = selectedObjects.reduce((acc, obj) => {
                        return acc.add(obj.position)
                      }, new Vector3(0, 0, 0)).scale(1 / selectedObjects.length)
                      sceneAPI.focusOnPosition(center)
                    }
                    setActiveDropdown(null)
                  }}
                  disabled={!hasSelectionFlag}
                >
                  Focus Selected
                </button>
                <button 
                  className="dropdown-action"
                  onClick={() => {
                    // Align selected objects to grid
                    const objectsToAlign = selectedObjectId ? [selectedObjectId] : selectedObjectIds
                    objectsToAlign.forEach(id => {
                      const obj = sceneObjects.find(o => o.id === id)
                      if (obj && obj.mesh) {
                        const snappedPos = snapToGridPosition(obj.position)
                        obj.mesh.position = snappedPos
                        updateObject(id, { position: snappedPos })
                      }
                    })
                    setActiveDropdown(null)
                  }}
                  disabled={!hasSelectionFlag}
                >
                  Align to Grid
                </button>
              </div>
            </div>
          </div>
        </div>

        {/* Building Menu */}
        <div className="toolbar-item">
          <button 
            className="toolbar-button"
            onClick={() => toggleDropdown('building')}
          >
            Building <span className="dropdown-arrow">‚ñº</span>
          </button>
          <div className={`dropdown-menu ${activeDropdown === 'building' ? 'show' : ''}`}>
            <div className="dropdown-section">
              <div className="dropdown-section-title">Quick Build</div>
              <div className="dropdown-actions">
                <button 
                  className="dropdown-action"
                  onClick={() => {
                    createModularRoom();
                    setTimeout(() => createHousingComponent('door', 'single'), 100);
                  }}
                >
                  Room with Door
                </button>
                <button 
                  className="dropdown-action"
                  onClick={() => {
                    createModularRoom();
                    setTimeout(() => createHousingComponent('window', 'single'), 100);
                  }}
                >
                  Room with Window
                </button>
                <button 
                  className="dropdown-action"
                  onClick={() => {
                    createModularRoom();
                    setTimeout(() => createHousingComponent('door', 'single'), 100);
                    setTimeout(() => createHousingComponent('window', 'single'), 200);
                  }}
                >
                  Complete Room
                </button>
              </div>
            </div>
            <div className="dropdown-section">
              <div className="dropdown-section-title">Building Tools</div>
              <div className="dropdown-actions">
                <button 
                  className="dropdown-action"
                  onClick={() => {
                    // Select all housing objects
                    const housingObjects = sceneObjects.filter(obj => obj.type.startsWith('house-'));
                    if (housingObjects.length > 0) {
                      setSelectedObjectIds(housingObjects.map(obj => obj.id));
                      setSelectedObjectId(null);
                    }
                    setActiveDropdown(null);
                  }}
                >
                  Select All Housing
                </button>
                <button 
                  className="dropdown-action"
                  onClick={() => {
                    // Focus on housing objects
                    const housingObjects = sceneObjects.filter(obj => obj.type.startsWith('house-'));
                    if (housingObjects.length > 0) {
                      const center = housingObjects.reduce((acc, obj) => {
                        return acc.add(obj.position)
                      }, new Vector3(0, 0, 0)).scale(1 / housingObjects.length);
                      sceneAPI.focusOnPosition(center);
                    }
                    setActiveDropdown(null);
                  }}
                >
                  Focus on Building
                </button>
              </div>
            </div>
            <div className="dropdown-section">
              <div className="dropdown-section-title">Organization</div>
              <div className="dropdown-actions">
                <button 
                  className="dropdown-action"
                  onClick={() => {
                    // Organize housing objects in a grid
                    const housingObjects = sceneObjects.filter(obj => obj.type.startsWith('house-'));
                    housingObjects.forEach((obj, index) => {
                      const gridSize = Math.ceil(Math.sqrt(housingObjects.length));
                      const row = Math.floor(index / gridSize);
                      const col = index % gridSize;
                      const newPosition = new Vector3(col * 4, obj.position.y, row * 4);
                      updateObject(obj.id, { position: newPosition });
                    });
                    setActiveDropdown(null);
                  }}
                >
                  Organize Grid
                </button>
                <button 
                  className="dropdown-action"
                  onClick={() => {
                    // Align housing objects to ground level
                    const housingObjects = sceneObjects.filter(obj => obj.type.startsWith('house-'));
                    housingObjects.forEach(obj => {
                      let groundLevel = 0;
                      if (obj.type.includes('floor')) groundLevel = 0.05;
                      else if (obj.type.includes('wall')) groundLevel = 0.75;
                      else if (obj.type.includes('ceiling')) groundLevel = 2.5;
                      else if (obj.type.includes('door') || obj.type.includes('window')) groundLevel = 1;
                      
                      const newPosition = new Vector3(obj.position.x, groundLevel, obj.position.z);
                      updateObject(obj.id, { position: newPosition });
                    });
                    setActiveDropdown(null);
                  }}
                >
                  Align to Ground
                </button>
              </div>
            </div>
          </div>
        </div>

        {/* View Menu */}
        <div className="toolbar-item">
          <button 
            className="toolbar-button"
            onClick={() => toggleDropdown('view')}
          >
            View <span className="dropdown-arrow">‚ñº</span>
          </button>
          <div className={`dropdown-menu ${activeDropdown === 'view' ? 'show' : ''}`}>
            <div className="dropdown-section">
              <div className="dropdown-section-title">Camera</div>
              <div className="camera-grid">
                <button className="camera-button" onClick={() => setCameraView('front')}>Front</button>
                <button className="camera-button" onClick={() => setCameraView('back')}>Back</button>
                <button className="camera-button" onClick={() => setCameraView('left')}>Left</button>
                <button className="camera-button" onClick={() => setCameraView('right')}>Right</button>
                <button className="camera-button" onClick={() => setCameraView('top')}>Top</button>
                <button className="camera-button" onClick={() => setCameraView('bottom')}>Bottom</button>
                <button className="camera-button" onClick={() => setCameraView('home')}>Home</button>
              </div>
            </div>
            <div className="dropdown-section">
              <div className="dropdown-section-title">Display</div>
              <div className="dropdown-actions">
                <button 
                  className={`dropdown-action ${wireframeMode ? 'active' : ''}`}
                  onClick={toggleWireframe}
                >
                  {wireframeMode ? '‚úì' : ''} Wireframe
                </button>
                <button 
                  className={`dropdown-action ${showGrid ? 'active' : ''}`}
                  onClick={() => setShowGrid(!showGrid)}
                >
                  {showGrid ? '‚úì' : ''} Grid
                </button>
                <button 
                  className={`dropdown-action ${snapToGrid ? 'active' : ''}`}
                  onClick={() => setSnapToGrid(!snapToGrid)}
                >
                  {snapToGrid ? '‚úì' : ''} Snap to Grid
                </button>
              </div>
            </div>
            <div className="dropdown-section">
              <div className="dropdown-section-title">Visibility</div>
              <div className="dropdown-actions">
                <button 
                  className="dropdown-action"
                  onClick={() => {
                    // Show all objects
                    sceneObjects.forEach(obj => {
                      if (obj.type !== 'ground') {
                        setObjectVisibility(obj.id, true)
                        if (obj.mesh) obj.mesh.isVisible = true
                      }
                    })
                    setActiveDropdown(null)
                  }}
                >
                  Show All
                </button>
                <button 
                  className="dropdown-action"
                  onClick={() => {
                    // Hide unselected objects
                    const visibleIds = selectedObjectId ? [selectedObjectId] : selectedObjectIds
                    const newVisibility: {[key: string]: boolean} = {}
                    
                    sceneObjects.forEach(obj => {
                      if (obj.type !== 'ground') {
                        const shouldBeVisible = visibleIds.includes(obj.id)
                        if (obj.mesh) {
                          obj.mesh.isVisible = shouldBeVisible
                        }
                        newVisibility[obj.id] = shouldBeVisible
                      }
                    })
                    
                    // isolate selected handler change
                    Object.entries(newVisibility).forEach(([id, vis]) => setObjectVisibility(id, vis))
                    
                    setActiveDropdown(null)
                  }}
                  disabled={!hasSelectionFlag}
                >
                  Isolate Selected
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  )



  // AI logic is now handled by the AI service in the AISidebar component

  const handleContinue = () => {
    if (apiKey.trim()) {
      console.log('üîë API key entered, switching to main app view')
      setShowApiKeyInput(false)
    }
  }
  /*
  const clearAllObjects = () => {
    // Detach gizmo first
    if (gizmoManagerRef.current) {
      gizmoManagerRef.current.attachToMesh(null)
    }

    setSceneObjects(prev => {
      const objectsToDelete = prev.filter(obj => obj.type !== 'ground')
      console.log('üßπ Clearing all objects:', objectsToDelete.map(obj => obj.id))
      
      // Dispose all meshes
      objectsToDelete.forEach(obj => {
        if (obj.mesh) {
          obj.mesh.dispose()
        }
      })
      
      // Keep only the ground
      const remainingObjects = prev.filter(obj => obj.type === 'ground')
      return remainingObjects
    })
    setSelectedObjectId(null)
    console.log('‚úÖ All objects cleared')
  }
  */

  // Scene initialization is now handled by the useBabylonScene hook
  // No need for manual cleanup since the hook handles it

  if (showApiKeyInput) {
    console.log('üîê App.tsx: Rendering API key input form')
    return (
      <div className="api-key-setup">
        <div className="api-key-container">
          <h2>VibeCad - AI Scene Manipulation</h2>
          <p>Enter your OpenAI API Key to enable AI-powered 3D scene manipulation:</p>
          <input
            type="password"
            value={apiKey}
            onChange={(e) => setApiKey(e.target.value)}
            placeholder="sk-..."
            className="api-key-input"
            onKeyPress={(e) => {
              if (e.key === 'Enter') {
                handleContinue()
              }
            }}
          />
          <button 
            onClick={handleContinue}
            disabled={!apiKey.trim()}
            className="api-key-submit"
          >
            Continue
          </button>
          <p className="api-key-note">
            Your API key is stored locally and never sent to our servers.
          </p>
        </div>
      </div>
    )
  }

  //console.log('üé® App.tsx: Rendering main app with canvas')
  
  return (
    <div className="app-container">
      {renderTopToolbar()}
      <div className="main-content">
        <div className="canvas-container">
          <canvas 
            ref={canvasRef} 
            className="babylon-canvas" 
            onLoad={() => console.log('üì∫ Canvas onLoad event')}
          />
          {/* Compass overlay for directional reference */}
          <CompassOverlay />
        </div>
        <AISidebar 
          apiKey={apiKey}
          sceneInitialized={sceneInitialized}
          sceneAPI={sceneAPI}
        />
      </div>
      {/* Custom Room Drawing Modal */}
      <CustomRoomModal
        isOpen={showCustomRoomModal}
        onCancel={() => setShowCustomRoomModal(false)}
        onCreate={handleCreateCustomRoom}
        onCreateMultiple={handleCreateMultipleCustomRooms}
      />
    </div>
  )
}

export default App
</file>

</files>
